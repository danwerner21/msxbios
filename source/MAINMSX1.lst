0001   0000             ; $Id: main_msx1.asm 525 2008-12-22 22:16:42Z mthuurne $
0002   0000             ; C-BIOS main ROM for a European MSX1 machine
0003   0000             ;
0004   0000             ; Copyright (c) 2005 Maarten ter Huurne.  All rights reserved.
0005   0000             ; Copyright (c) 2005 Joost Yervante Damad.  All rights reserved.
0006   0000             ; Copyright (C) 2005 BouKiCHi. All rights reserved.
0007   0000             ; Copyright (C) 2008 Eric Boon. All rights reserved.
0008   0000             ;
0009   0000             ; Redistribution and use in source and binary forms, with or without
0010   0000             ; modification, are permitted provided that the following conditions
0011   0000             ; are met:
0012   0000             ; 1. Redistributions of source code must retain the above copyright
0013   0000             ;    notice, this list of conditions and the following disclaimer.
0014   0000             ; 2. Redistributions in binary form must reproduce the above copyright
0015   0000             ;    notice, this list of conditions and the following disclaimer in the
0016   0000             ;    documentation and/or other materials provided with the distribution.
0017   0000             ;
0018   0000             ; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
0019   0000             ; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
0020   0000             ; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
0021   0000             ; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
0022   0000             ; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
0023   0000             ; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0024   0000             ; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0025   0000             ; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0026   0000             ; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
0027   0000             ; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0028   0000             ;
0029   0000             
0030   0000                             .include "hardware.asm"
0001+  0000             ; $Id: hardware.asm 525 2008-12-22 22:16:42Z mthuurne $
0002+  0000             ; C-BIOS hardware related declarations
0003+  0000             ;
0004+  0000             ; Copyright (c) 2002-2005 BouKiCHi.  All rights reserved.
0005+  0000             ; Copyright (c) 2003 Reikan.  All rights reserved.
0006+  0000             ; Copyright (c) 2004-2005 Maarten ter Huurne.  All rights reserved.
0007+  0000             ; Copyright (c) 2004 Manuel Bilderbeek.  All rights reserved.
0008+  0000             ; Copyright (c) 2004-2006 Albert Beevendorp.  All rights reserved.
0009+  0000             ; Copyright (c) 2004-2005 Joost Yervante Damad.  All rights reserved.
0010+  0000             ;
0011+  0000             ; Redistribution and use in source and binary forms, with or without
0012+  0000             ; modification, are permitted provided that the following conditions
0013+  0000             ; are met:
0014+  0000             ; 1. Redistributions of source code must retain the above copyright
0015+  0000             ;    notice, this list of conditions and the following disclaimer.
0016+  0000             ; 2. Redistributions in binary form must reproduce the above copyright
0017+  0000             ;    notice, this list of conditions and the following disclaimer in the
0018+  0000             ;    documentation and/or other materials provided with the distribution.
0019+  0000             ;
0020+  0000             ; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
0021+  0000             ; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
0022+  0000             ; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
0023+  0000             ; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
0024+  0000             ; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONS.equENTIAL DAMAGES (INCLUDING, BUT
0025+  0000             ; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0026+  0000             ; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0027+  0000             ; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0028+  0000             ; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
0029+  0000             ; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0030+  0000             ;
0031+  0000             
0032+  0000             ;---------------------------------------------------
0033+  0000             ; I/O ports
0034+  0000             
0035+  0000             DBG_CTRL:       .equ     $2E             ; openMSX debugdevice control (mode)
0036+  0000             DBG_DATA:       .equ     $2F             ; openMSX debugdevice data
0037+  0000             
0038+  0000             PRN_STAT:       .equ     $90             ; printer status
0039+  0000             PRN_DATA:       .equ     $91             ; printer data
0040+  0000             
0041+  0000             VDP_DATA:       .equ     $98             ; VDP data port (VRAM read/write)
0042+  0000             VDP_ADDR:       .equ     $99             ; VDP address (write only)
0043+  0000             VDP_STAT:       .equ     $99             ; VDP status (read only)
0044+  0000             VDP_PALT:       .equ     $9A             ; VDP palette latch (write only)
0045+  0000             VDP_REGS:       .equ     $9B             ; VDP register access (write only)
0046+  0000             
0047+  0000             VDP_ACR:        .equ     $9C             ; VDP ACCESS CONTROL REGISTER
0048+  0000             
0049+  0000             ;PSG_REGS:       .equ     $A0             ; PSG register write port
0050+  0000             ;PSG_DATA:       .equ     $A1             ; PSG value write port
0051+  0000             ;PSG_STAT:       .equ     $A2             ; PSG value read port
0052+  0000             
0053+  0000             PSG_REGS:       .equ     $9A             ; PSG register write port
0054+  0000             PSG_DATA:       .equ     $9B             ; PSG value write port
0055+  0000             PSG_STAT:       .equ     $9A             ; PSG value read port
0056+  0000             
0057+  0000             PSL_STAT:       .equ     $A8             ; slot status
0058+  0000             KBD_STAT:       .equ     $A9             ; keyboard status
0059+  0000             GIO_REGS:       .equ     $AA             ; General IO Register
0060+  0000             PPI_REGS:       .equ     $AB             ; PPI register
0061+  0000             
0062+  0000             RTC_ADDR:       .equ     $B4             ; RTC address
0063+  0000             RTC_DATA:       .equ     $B5             ; RTC data
0064+  0000             
0065+  0000             
0066+  0000             ; N8VEM hardware
0067+  0000             KBPPIA		.EQU	0F4h		; PPI PORT A
0068+  0000             KBPPIB		.EQU	0F5h		; PPI PORT B
0069+  0000             KBPPIC		.EQU	0F6h		; PPI PORT C
0070+  0000             KBPPICONT	.EQU	0F7h		; PPI CONTROL PORT
0071+  0000             
0072+  0000             UART0:		 .EQU	068H		;   DATA IN/OUT
0073+  0000             UART1:		 .EQU	069H		;   CHECK RX
0074+  0000             UART2:		 .EQU	06AH		;   INTERRUPTS
0075+  0000             UART3:		 .EQU	06BH		;   LINE CONTROL
0076+  0000             UART4:		 .EQU	06CH		;   MODEM CONTROL
0077+  0000             UART5:		 .EQU	06DH		;   LINE STATUS
0078+  0000             
0079+  0000                                                                                             
0080+  0000             MAP_REG1:       .equ     $FC             ; memory mapper: bank in $0000-$3FFF
0081+  0000             MAP_REG2:       .equ     $FD             ; memory mapper: bank in $4000-$7FFF
0082+  0000             MAP_REG3:       .equ     $FE             ; memory mapper: bank in $8000-$BFFF
0083+  0000             MAP_REG4:       .equ     $FF             ; memory mapper: bank in $C000-$FFFF
0084+  0000             
0085+  0000             ;---------------------------------------------------
0086+  0000             ; memory mapped I/O
0087+  0000             
0088+  0000             SSL_REGS:       .equ     $FFFF           ; secondary slot select registers
0089+  0000             
0090+  0000             ;---------------------------------------------------
0091+  0000             ; Constants used to define which hardware the BIOS will run on.
0092+  0000             ; Used by the main_<model>.asm sources.
0093+  0000             
0094+  0000             ; VDP models:
0095+  0000             TMS99X8:        .equ     $9918
0096+  0000             V9938:          .equ     $9938
0097+  0000             V9958:          .equ     $9958
0098+  0000             
0099+  0000             ; MSX models:
0100+  0000             MODEL_MSX1:     .equ     0
0101+  0000             MODEL_MSX2:     .equ     1
0102+  0000             MODEL_MSX2P:    .equ     2
0103+  0000             MODEL_MSXTR:    .equ     3
0104+  0000             
0105+  0000             MODEL_SUBROM:   .equ     4
0106+  0000             
0107+  0000             ; Locales:
0108+  0000             ; -- ID byte 0
0109+  0000             LOCAL_CHSET_JP  .equ     $00
0110+  0000             LOCAL_CHSET_US  .equ     $01
0111+  0000             LOCAL_CHSET_KO  .equ     $02
0112+  0000             
0113+  0000             LOCAL_DATE_YMD  .equ     $00
0114+  0000             LOCAL_DATE_MDY  .equ     $10
0115+  0000             LOCAL_DATE_DMY  .equ     $20
0116+  0000             
0117+  0000             LOCAL_INT_60HZ  .equ     $00
0118+  0000             LOCAL_INT_50HZ  .equ     $80
0119+  0000             
0120+  0000             ; -- ID byte 1
0121+  0000             LOCAL_KBD_JP    .equ     $00
0122+  0000             LOCAL_KBD_US    .equ     $01
0123+  0000             LOCAL_KBD_FR    .equ     $02
0124+  0000             LOCAL_KBD_UK    .equ     $03
0125+  0000             LOCAL_KBD_DE    .equ     $04
0126+  0000             
0127+  0000             LOCAL_BASIC_JP  .equ     $00
0128+  0000             LOCAL_BASIC_US  .equ     $01
0129+  0000             
0130+  0000             
0131+  0000             KB_USE_SERIAL	.EQU	1	; SET TO 1 FOR SERIAL INPUT
0132+  0000             KB_USE_PS2	.EQU	0	; SET TO 1 FOR PS/2 INPUT
0133+  0000             
0134+  0000             ; BOOLEAN VALUES
0135+  0000             YES:            .equ     1
0136+  0000             NO:             .equ     0
0137+  0000             
0138+  0000             ; vim:ts=8:expandtab:filetype=z8a:syntax=z8a:
0031   0000             
0032   0000             VDP:            .equ     TMS99X8
0033   0000             MODEL_MSX:      .equ     MODEL_MSX1
0034   0000             N8VEM		.equ	 1
0035   0000             
0036   0000             ; -- generic US config (60Hz, US keyboard layout)
0037   0000             LOCALE_CHSET:   .equ     LOCAL_CHSET_US
0038   0000             LOCALE_DATE:    .equ     LOCAL_DATE_MDY
0039   0000             LOCALE_INT:     .equ     LOCAL_INT_60HZ
0040   0000             LOCALE_KBD:     .equ     LOCAL_KBD_US
0041   0000             LOCALE_BASIC    .equ     LOCAL_BASIC_US
0042   0000             
0043   0000             CALL_SUB:       .equ     NO
0044   0000             
0045   0000                             .include "main.asm"
0001+  0000             ;_CBIOS_N8VEM______________________________________________________________________________________________________
0002+  0000             ;
0003+  0000             ;  
0004+  0000             ;  The following code is a heavily modified version of the C-BIOS ROM. (See below disclaimer)  
0005+  0000             ;  It has been modified for use with the N8VEM, and the N8VEM HC series of computers.   Strict MSX1 compatibility
0006+  0000             ;  is no longer maintained in this version, but, it aims to be as compatible as possible within the contraints
0007+  0000             ;  of the N8VEM hardware.   Extra features not supported by the N8VEM hardware were removed to conserve ROM space
0008+  0000             ;  and improve maintainability of the system.
0009+  0000             ;
0010+  0000             ;  Some features have been added to further support the N8VEM system
0011+  0000             ;
0012+  0000             ;  Conversion done by:   Dan Werner	11/1/2010
0013+  0000             ;__________________________________________________________________________________________________________________
0014+  0000             ;
0015+  0000             ;
0016+  0000             ;
0017+  0000             ; $Id: main.asm 570 2010-05-24 11:36:23Z bifimsx $
0018+  0000             ; C-BIOS main ROM
0019+  0000             ;
0020+  0000             ; Copyright (c) 2002-2005 BouKiCHi.  All rights reserved.
0021+  0000             ; Copyright (c) 2003 Reikan.  All rights reserved.
0022+  0000             ; Copyright (c) 2004-2005 Maarten ter Huurne.  All rights reserved.
0023+  0000             ; Copyright (c) 2004-2009 Albert Beevendorp.  All rights reserved.
0024+  0000             ; Copyright (c) 2004 Manuel Bilderbeek.  All rights reserved.
0025+  0000             ; Copyright (c) 2004-2005 Joost Yervante Damad.  All rights reserved.
0026+  0000             ; Copyright (c) 2004-2005 Jussi Pitkänen.  All rights reserved.
0027+  0000             ; Copyright (c) 2006-2007 Eric Boon.  All rights reserved.
0028+  0000             ;
0029+  0000             ; Redistribution and use in source and binary forms, with or without
0030+  0000             ; modification, are permitted provided that the following conditions
0031+  0000             ; are met:
0032+  0000             ; 1. Redistributions of source code must retain the above copyright
0033+  0000             ;    notice, this list of conditions and the following disclaimer.
0034+  0000             ; 2. Redistributions in binary form must reproduce the above copyright
0035+  0000             ;    notice, this list of conditions and the following disclaimer in the
0036+  0000             ;    documentation and/or other materials provided with the distribution.
0037+  0000             ;
0038+  0000             ; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
0039+  0000             ; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
0040+  0000             ; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
0041+  0000             ; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
0042+  0000             ; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONS.equENTIAL DAMAGES (INCLUDING, BUT
0043+  0000             ; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOO.ds OR SERVICES; LOSS OF USE,
0044+  0000             ; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0045+  0000             ; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0046+  0000             ; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
0047+  0000             ; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0048+  0000             ;
0049+  0000             
0050+  0000                             .include "systemva.asm"
0001++ 0000             ; $Id: systemvars.asm 566 2010-03-02 00:59:42Z mthuurne $
0002++ 0000             ;
0003++ 0000             ; C-BIOS system variable declarations
0004++ 0000             ;
0005++ 0000             ; Copyright (c) 2002-2003 BouKiCHi.  All rights reserved.
0006++ 0000             ; Copyright (c) 2003 Reikan.  All rights reserved.
0007++ 0000             ; Copyright (c) 2004-2005 Maarten ter Huurne.  All rights reserved.
0008++ 0000             ; Copyright (c) 2004 Manuel Bilderbeek.  All rights reserved.
0009++ 0000             ; Copyright (c) 2004-2006 Joost Yervante Damad.  All rights reserved.
0010++ 0000             ; Copyright (c) 2004-2005 Albert Beevendorp.  All rights reserved.
0011++ 0000             ; Copyright (c) 2005 Jussi Pitkänen.  All rights reserved.
0012++ 0000             ;
0013++ 0000             ; Redistribution and use in source and binary forms, with or without
0014++ 0000             ; modification, are permitted provided that the following conditions
0015++ 0000             ; are met:
0016++ 0000             ; 1. Redistributions of source code must retain the above copyright
0017++ 0000             ;    notice, this list of conditions and the following disclaimer.
0018++ 0000             ; 2. Redistributions in binary form must reproduce the above copyright
0019++ 0000             ;    notice, this list of conditions and the following disclaimer in the
0020++ 0000             ;    documentation and/or other materials provided with the distribution.
0021++ 0000             ;
0022++ 0000             ; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
0023++ 0000             ; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
0024++ 0000             ; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
0025++ 0000             ; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
0026++ 0000             ; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONS.equENTIAL DAMAGES (INCLUDING, BUT
0027++ 0000             ; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOO.ds OR SERVICES; LOSS OF USE,
0028++ 0000             ; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0029++ 0000             ; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0030++ 0000             ; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
0031++ 0000             ; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0032++ 0000             ;
0033++ 0000             
0034++ 0000             
0035++ 0000             ;-------------------
0036++ 0000             ; help function area
0037++ 0000             ;-------------------
0038++ 0000             ; Note: Functions defined in "main.asm" are disabled here.
0039++ 0000             
0040++ 0000             
0041++ 0000             ; F39A-F3AD: workarea for the DEF USR statement
0042++ 0000             ; this area is initialized with the 10 times the value $475A, which gives
0043++ 0000             ; the error 'Syntax Error'
0044++ 0000             USRTAB:         .equ     $F39A
0045++ 0000             
0046++ 0000             ;----------------------
0047++ 0000             ; screen parameter area
0048++ 0000             ;----------------------
0049++ 0000             
0050++ 0000             ; F3AE: # of positions on a line in SCREEN 0 (ini:39)
0051++ 0000             LINL40:         .equ     $F3AE
0052++ 0000             
0053++ 0000             ; F3AF: # of positions on a line in SCREEN 1 (ini:29)
0054++ 0000             LINL32:         .equ     $F3AF
0055++ 0000             
0056++ 0000             ; F3B0: # of actually used positions in the current screenmodus (ini:39)
0057++ 0000             LINLEN:         .equ     $F3B0
0058++ 0000             
0059++ 0000             ; F3B1: # of used lines on screen (ini:24)
0060++ 0000             CRTCNT:         .equ     $F3B1
0061++ 0000             
0062++ 0000             ; F3B2: # of positions within a tabulator-column (ini:14)
0063++ 0000             CLMLST:         .equ     $F3B2
0064++ 0000             
0065++ 0000             ; F3B3-F3B4: BASE(0): name table address for SCREEN 0 (ini:$0000)
0066++ 0000             ; used to initialize NAMBAS when SCREEN 0 is activated
0067++ 0000             TXTNAM:         .equ     $F3B3
0068++ 0000             
0069++ 0000             ; F3B5-F3B6: BASE(1): color table address for SCREEN 0, unused? (ini:$0000)
0070++ 0000             TXTCOL:         .equ     $F3B5
0071++ 0000             
0072++ 0000             ; F3B7-F3B8: BASE(2): pattern table address for SCREEN 0 (ini:$0800)
0073++ 0000             ; used to initialize CGPBAS when SCREEN 0 is activated
0074++ 0000             TXTCGP:         .equ     $F3B7
0075++ 0000             
0076++ 0000             ; F3B9-F3BA: BASE(3): sprite attribute table address for SCREEN 0, unused (ini:$0000)
0077++ 0000             ; used to initialize ATRBAS when SCREEN 0 is activated
0078++ 0000             TXTATR:         .equ     $F3B9
0079++ 0000             
0080++ 0000             ; F3BB-F3BC: BASE(4): sprite pattern table address for SCREEN 0, unused (ini:$0000)
0081++ 0000             ; used to initialize PATBAS when SCREEN 0 is activated
0082++ 0000             TXTPAT:         .equ     $F3BB
0083++ 0000             
0084++ 0000             ; F3BD-F3BE: BASE(5): nametable address for SCREEN 1 (ini:$1800)
0085++ 0000             ; used to initialize NAMBAS when SCREEN 1 is activated
0086++ 0000             T32NAM:         .equ     $F3BD
0087++ 0000             
0088++ 0000             ; F3BF-F3C0: BASE(6): color table address for SCREEN 1 (ini:$2000)
0089++ 0000             T32COL:         .equ     $F3BF
0090++ 0000             
0091++ 0000             ; F3C1-F3C2: BASE(7): pattern table address for SCREEN 1 (ini:$0000)
0092++ 0000             ; used to initialize CGPBAS when SCREEN 1 is activated
0093++ 0000             T32CGP:         .equ     $F3C1
0094++ 0000             
0095++ 0000             ; F3C3-F3C4: BASE(8): sprite attribute table address for SCREEN 1 (ini:$1B00)
0096++ 0000             ; used to initialize ATRBAS when SCREEN 1 is activated
0097++ 0000             T32ATR:         .equ     $F3C3
0098++ 0000             
0099++ 0000             ; F3C5-F3C6: BASE(9): sprite pattern table address for SCREEN 1 (ini:$0800)
0100++ 0000             ; used to initialize PATBAS when SCREEN 1 is activated
0101++ 0000             T32PAT:         .equ     $F3C5
0102++ 0000             
0103++ 0000             ; F3C7-F3C8: BASE(10): name table address for SCREEN 2 (ini:$1800)
0104++ 0000             ; used to initialize NAMBAS when SCREEN 2 is activated
0105++ 0000             GRPNAM:         .equ     $F3C7
0106++ 0000             
0107++ 0000             ; F3C9-F3CA: BASE(11): color table address for SCREEN 2 (ini:$2000)
0108++ 0000             GRPCOL:         .equ     $F3C9           ; Screen2 Color
0109++ 0000             
0110++ 0000             ; F3CB-F3CC: BASE(12): pattern table address for SCREEN 2 (ini:$0000)
0111++ 0000             ; used to initialize CGPBAS when SCREEN 2 is activated
0112++ 0000             GRPCGP:         .equ     $F3CB
0113++ 0000             
0114++ 0000             ; F3CD-F3CE: BASE(13): sprite attribute table address for SCREEN 2 (ini:$1B00)
0115++ 0000             ; used to initialize ATRBAS when SCREEN 2 is activated
0116++ 0000             GRPATR:         .equ     $F3CD
0117++ 0000             
0118++ 0000             ; F3CF-F3D0: BASE(14): sprite pattern table address for SCREEN 2 (ini:$3800)
0119++ 0000             ; used to initialize PATBAS when SCREEN 2 is activated
0120++ 0000             GRPPAT:         .equ     $F3CF
0121++ 0000             
0122++ 0000             ; F3D1-F3D2: BASE(15): name table address for SCREEN 3 (ini:$0800)
0123++ 0000             ; used to initialize NAMBAS when SCREEN 3 is activated
0124++ 0000             MLTNAM:         .equ     $F3D1
0125++ 0000             
0126++ 0000             ; F3D3-F3D4: BASE(16): color table address for SCREEN 3 (ini:$0000)
0127++ 0000             ; the color table is unused in SCREEN 3
0128++ 0000             MLTCOL:         .equ     $F3D3
0129++ 0000             
0130++ 0000             ; F3D5-F3D6: BASE(17): pattern table address for SCREEN 3 (ini:$0000)
0131++ 0000             ; used to initialize CGPBAS when SCREEN 3 is activated
0132++ 0000             MLTCGP:         .equ     $F3D5
0133++ 0000             
0134++ 0000             ; F3D7-F3D8: BASE(18): sprite attribute table address for SCREEN 3 (ini:$1B00)
0135++ 0000             ; used to initialize ATRBAS when SCREEN 3 is activated
0136++ 0000             MLTATR:         .equ     $F3D7
0137++ 0000             
0138++ 0000             ; F3D9-F3DA: BASE(19): sprite pattern table address for SCREEN 3 (ini:$3800)
0139++ 0000             ; used to initialize PATBAS when SCREEN 3 is activated
0140++ 0000             MLTPAT:         .equ     $F3D9
0141++ 0000             
0142++ 0000             ; F3db: keyclick when a key is pressed: 0: no, 1: yes (ini: 1)
0143++ 0000             ; SCREEN ,,n will write to this address
0144++ 0000             CLIKSW:         .equ     $F3db
0145++ 0000             
0146++ 0000             ; F3DC: line where the cursor is located
0147++ 0000             ; starts to count at 1 for the topmost line
0148++ 0000             CSRY:           .equ     $F3DC
0149++ 0000             
0150++ 0000             ; F3DD: column where the cursor is located
0151++ 0000             ; starts to count at 1 for the leftmost column
0152++ 0000             CSRX:           .equ     $F3DD
0153++ 0000             
0154++ 0000             ; F3DE: function key definition shown: 0: no, -1: yes
0155++ 0000             ; Note: MSX BIOS will mess up end-of-screen if this variable contains
0156++ 0000             ;       something other than $00 or $FF.
0157++ 0000             CNSDFG:         .equ     $F3DE
0158++ 0000             
0159++ 0000             ; F3DF-D3E6: storage for the last written value towar.ds VDP registers 0 till 7
0160++ 0000             ; this is needed because these registers are write only
0161++ 0000             RG0SAV:         .equ     $F3DF
0162++ 0000             RG1SAV:         .equ     $F3E0
0163++ 0000             RG2SAV:         .equ     $F3E1
0164++ 0000             RG3SAV:         .equ     $F3E2
0165++ 0000             RG4SAV:         .equ     $F3E3
0166++ 0000             RG5SAV:         .equ     $F3E4
0167++ 0000             RG6SAV:         .equ     $F3E5
0168++ 0000             RG7SAV:         .equ     $F3E6
0169++ 0000             ; F3E7: last read value of VDP register 8
0170++ 0000             STATFL:         .equ     $F3E7
0171++ 0000             
0172++ 0000             ; F3E8: information about the joystick and space bar
0173++ 0000             ; 7 6 5 4 3 2 1 0
0174++ 0000             ; | | | |       +-- Space bar, trig(0) (0 = pressed)
0175++ 0000             ; | | | +---------- Stick 1, Trigger 1 (0 = pressed)
0176++ 0000             ; | | +------------ Stick 1, Trigger 2 (0 = pressed)
0177++ 0000             ; | +-------------- Stick 2, Trigger 1 (0 = pressed)
0178++ 0000             ; +---------------- Stick 2, Trigger 2 (0 = pressed)
0179++ 0000             TRGFLG:         .equ     $F3E8
0180++ 0000             
0181++ 0000             ; F3E9: code for the standard foreground color (ini:15)
0182++ 0000             FORCLR:         .equ     $F3E9
0183++ 0000             
0184++ 0000             ; F3EA: code for the standard background color (ini:4)
0185++ 0000             BAKCLR:         .equ     $F3EA
0186++ 0000             
0187++ 0000             ; F3EB: code for the standard border color (ini:7)
0188++ 0000             BDRCLR:         .equ     $F3EB
0189++ 0000             
0190++ 0000             ; F3EC-F3EE: Jump instruction used by Basic LINE command.
0191++ 0000             ; The routines used are: RIGHTC, LEFTC, UPC and DOWNC
0192++ 0000             MAXUPD:         .equ     $F3EC
0193++ 0000             
0194++ 0000             ; F3EF-F3F1: Jump instruction used by Basic LINE command.
0195++ 0000             ; The routines used are: RIGHTC, LEFTC, UPC and DOWNC
0196++ 0000             MINUPD:         .equ     $F3EF
0197++ 0000             
0198++ 0000             ; F3F2: working color, as used for graphical operations
0199++ 0000             ; normally .equals to the foreground color (ini:15)
0200++ 0000             ATRBYT:         .equ     $F3F2
0201++ 0000             
0202++ 0000             ; F3F3-F3F4: starting value of the address of the queue-table
0203++ 0000             ; the queue-table contains 4 queue's: 3 for sound and one for RS232
0204++ 0000             ; (ini: QUETAB ($F959))
0205++ 0000             QUEUES:         .equ     $F3F3
0206++ 0000             
0207++ 0000             ; F3F5: CLOAD flag =0 when CLOAD =255 when CLOAD?
0208++ 0000             FRCNEW:         .equ     $F3F5
0209++ 0000             
0210++ 0000             ; F3F6: VDP-interupt counter that counts from 3 to 0, when it reaches zero, the
0211++ 0000             ; keyboard matrix is scanned, and the counters is reset at 3
0212++ 0000             SCNCNT:         .equ     $F3F6
0213++ 0000             
0214++ 0000             ; F3F7: key repeat counter. Runs from 13 to 0, and is changed when SCNCNT is changed
0215++ 0000             ; if the key remained the same. If it reaches 0, keyrepetition starts. If another key
0216++ 0000             ; is pressed the value is reset at 13.
0217++ 0000             REPCNT:         .equ     $F3F7
0218++ 0000             
0219++ 0000             ; F3F8-F3F9: first free space in the inputbuffer of the keyboard
0220++ 0000             ; everytime a key is added to the inputbuffer, this address is incremented,
0221++ 0000             ; when it .equals to GETPNT, the buffer is full
0222++ 0000             ; the buffer is located at KEYBUF
0223++ 0000             PUTPNT:         .equ     $F3F8           ; L[obt@ÖÌ|C^
0224++ 0000             
0225++ 0000             ; F3FA-F3FB: address in inputbuffer of first character that is not yet read
0226++ 0000             ; everytime a key is read from the buffer it is incremented
0227++ 0000             ; the buffer is located at KEYBUF
0228++ 0000             GETPNT:         .equ     $F3FA           ; L[obt@ÖÌ|C^
0229++ 0000             
0230++ 0000             ; F3FC-F400: memory area for tape system parameters for 1200 baud
0231++ 0000             ; F3FC: length of  low signal for 0     (ini:83)
0232++ 0000             ; F3FD: length of high signal for 0     (ini:92)
0233++ 0000             ; F3FE: length of  low signal for 1     (ini:38)
0234++ 0000             ; F3FF: length of high signal for 1     (ini:45)
0235++ 0000             ; F400: length of synchronization block (ini:15)
0236++ 0000             CS120:          .equ     $F3FC
0237++ 0000             
0238++ 0000             ; F401-F405: memory area for tape system parameters for 1200 baud
0239++ 0000             ; F401: length of  low signal for 0     (ini:37)
0240++ 0000             ; F402: length of high signal for 0     (ini:45)
0241++ 0000             ; F403: length of  low signal for 1     (ini:14)
0242++ 0000             ; F404: length of high signal for 1     (ini:22)
0243++ 0000             ; F405: length of synchronization block (ini:31)
0244++ 0000             CS240:          .equ     $F401
0245++ 0000             
0246++ 0000             ; F406-F407: lenghts of signal for 0 for the current speed of the tape system
0247++ 0000             ; either .equal to the content of F3FC-F3FD or the content of F401-F402
0248++ 0000             ; (ini: 83, 92)
0249++ 0000             LOW_:           .equ     $F406 ; real name: LOW, but doesn't compile?
0250++ 0000             
0251++ 0000             ; F408-F409: lenghts of signal for 1 for the current speed of the tape system
0252++ 0000             ; either .equal to the content of F3FE-F3FF or the content of F403-F404
0253++ 0000             ; (ini: 38, 45)
0254++ 0000             HIGH_:          .equ     $F408 ; real name: HIGH, but doesn't compile?
0255++ 0000             
0256++ 0000             ; F40A: lenghts of synchronization block for the current speed of the tape system
0257++ 0000             ; either .equal to the content of F400 or the content of F405 (ini: 15)
0258++ 0000             HEADER:         .equ     $F40A
0259++ 0000             
0260++ 0000             ; F40B-F40C: standard setting for the height/width aspect of the
0261++ 0000             ; BASIC statement CIRCLE; only the byte in F40B is actually used
0262++ 0000             ; If ASPECT2 is larger then 255, the value of F40B is the number of horizontal
0263++ 0000             ; dots per 256 verical dots of the radius (ini:$0100)
0264++ 0000             ; ! not verified :)
0265++ 0000             ASPCT1:         .equ     $F40B
0266++ 0000             
0267++ 0000             ; F40D-F40E: standard setting for the height/width aspect of the
0268++ 0000             ; BASIC statement CIRCLE; If ASPCT2 is smaller then 512, then ASPCT2 is the
0269++ 0000             ; number of vertical dots per 256 horizontal dots of the radius (ini:$0100)
0270++ 0000             ; ! not verified :)
0271++ 0000             ASPCT2:         .equ     $F40D
0272++ 0000             
0273++ 0000             ; F40F-F413: work area for the BASIC statement RESUME NEXT
0274++ 0000             ; contains a fake end of basic program
0275++ 0000             ; (ini: 58, 0, 0, 0, 0)
0276++ 0000             ENDPRG:         .equ     $F40F
0277++ 0000             
0278++ 0000             ; F414: errornumber of last error that happened while executing a BASIC program
0279++ 0000             ; (ini:0)
0280++ 0000             ERRFLG:         .equ     $F414
0281++ 0000             
0282++ 0000             ; F415: number of characters in the writebuffer of the printer that still
0283++ 0000             ; need printing
0284++ 0000             LPTPOS:         .equ     $F415
0285++ 0000             
0286++ 0000             ; F416: switch indicating if output should be screen or printer
0287++ 0000             ; (think LIST vs LLIST) (ini:0) values: 0: screen, 1: printer
0288++ 0000             PRTFLG:         .equ     $F416
0289++ 0000             
0290++ 0000             ; F417: switch indicating if hooked up printer is an MSX printer or not
0291++ 0000             ; values: 0: MSX-Printer, 1: no MSX-Printer
0292++ 0000             ; if the printer is no MSX-Printer, non-ASCII (>=128) characters are replaced
0293++ 0000             ; by spaces before sending them to the printer (ini: 0)
0294++ 0000             NTMSXP:         .equ     $F417
0295++ 0000             
0296++ 0000             ; F418: switch indicating of printing routines should use raw-mode or
0297++ 0000             ; should convert:
0298++ 0000             ; =0 to convert tabs and unknown characters to spaces and remove graphical headers
0299++ 0000             ; =1 to send data just like it gets it (ini: 0)
0300++ 0000             ; if RAWPRT is 1, the value if NTMSXP is ignored
0301++ 0000             RAWPRT:         .equ     $F418
0302++ 0000             
0303++ 0000             ; ---------------------------
0304++ 0000             ; basic interpreter work area
0305++ 0000             ; ---------------------------
0306++ 0000             
0307++ 0000             ; F419-F41A: work area for the BASIC command VAL: contains address of character that
0308++ 0000             ; has temporarely been replaced by O by VAL
0309++ 0000             VLZADR:         .equ     $F419
0310++ 0000             
0311++ 0000             ; F41B: work area for the BASIC command VAL: contains the character originally at
0312++ 0000             ; the location of VLZADR
0313++ 0000             VLZDAT:         .equ     $F41B
0314++ 0000             
0315++ 0000             ; F41C-F41D: line number of current BASIC line being executed, in direct modus this
0316++ 0000             ; contains $FFFF (ini:$FFFF)
0317++ 0000             CURLIN:         .equ     $F41C
0318++ 0000             
0319++ 0000             ; F41E: error detection prefix for KBUF, always contains ":"
0320++ 0000             ; originally undocumented :)
0321++ 0000             KBFMIN:         .equ     $F41E
0322++ 0000             
0323++ 0000             ; F41F-F55C: workarea for coding basic rules that have been typed in direct modus
0324++ 0000             ; this are contains the code for the line interpreted in direct modus
0325++ 0000             KBUF:           .equ     $F41F
0326++ 0000             
0327++ 0000             ; F55D: byte used as first byte of BUF for input statements, giving them always
0328++ 0000             ; an extra ',' (ini:44 == ',')
0329++ 0000             BUFMIN:         .equ     $F55D
0330++ 0000             
0331++ 0000             ; F55E-F65F: used in direct modus to store the ASCII codes of the line, or simulary
0332++ 0000             ; for INPUT or LINE INPUT BASIC statements
0333++ 0000             BUF:            .equ     $F55E
0334++ 0000             
0335++ 0000             ; F562-F570: used by bitblit routines to store the register data
0336++ 0000             SX:             .equ     $F562
0337++ 0000             SY:             .equ     $F564
0338++ 0000             DX:             .equ     $F566
0339++ 0000             DY:             .equ     $F568
0340++ 0000             NX:             .equ     $F56A
0341++ 0000             NY:             .equ     $F56C
0342++ 0000             CDUMMY:         .equ     $F56E
0343++ 0000             ARG_:           .equ     $F56F
0344++ 0000             L_OP:           .equ     $F570
0345++ 0000             
0346++ 0000             ; F660: last usable byte of BUF
0347++ 0000             ENDBUF:         .equ     $F660
0348++ 0000             
0349++ 0000             ; F661: number of column of last written character on the screen
0350++ 0000             TTYPOS:         .equ     $F661
0351++ 0000             
0352++ 0000             ; F662: switch indicating during variable lookup for arrays, if this has not already
0353++ 0000             ; been done for a DIM BASIC statement
0354++ 0000             DIMFLG:         .equ     $F662
0355++ 0000             
0356++ 0000             ; F663: workarea for evaluation of expressions; contains type of last evaluated
0357++ 0000             ; expression; the value of the expression is in DAC, possible values of VALTYP:
0358++ 0000             ; 2: integer
0359++ 0000             ; 3: string
0360++ 0000             ; 4: normal real
0361++ 0000             ; 8: double real
0362++ 0000             VALTYP:         .equ     $F663
0363++ 0000             
0364++ 0000             ; F664: workarea for coding of BASIC statements. switch indicating if keywor.ds have
0365++ 0000             ; to be encoded or not. E.g. in DATA fiel.ds they should not be encoded
0366++ 0000             ; 0: encoding on, 1: encoding off
0367++ 0000             DORES:          .equ     $F664
0368++ 0000             
0369++ 0000             ; F665: workarea for coding of BASIC statements. swithc indication of numbers have to be
0370++ 0000             ; encoded; values: $0: encode as const, $1: encode as line number, $FF: do not encode
0371++ 0000             DONUM:          .equ     $F665
0372++ 0000             
0373++ 0000             ; F666-F667: work area for evaluation of expressions: contains address of first character
0374++ 0000             ; after the code of the last evaluated expression
0375++ 0000             CONTXT:         .equ     $F666
0376++ 0000             
0377++ 0000             ; F668: work area for evaluation of expressions: contains information byte about the
0378++ 0000             ; encoding of the last evaluated constant number; value of this constant is in CONLO
0379++ 0000             ; values:
0380++ 0000             ; $0B: octal (2 bytes)
0381++ 0000             ; $0C: hexadecimal (2 bytes)
0382++ 0000             ; $0F: decimal 0<=value<256 (1 byte)
0383++ 0000             ; $11-$1B: short encoding for 0->10
0384++ 0000             ; $1C: decimal (2bytes, 2s-compliment)
0385++ 0000             ; $26: $42 binary as ASCII
0386++ 0000             ; $0E: line number
0387++ 0000             ; $0D: line pointer
0388++ 0000             ; $1D: normal real (1 byte exp, 3 bytes BCD)
0389++ 0000             ; $1F: double real (1 byte exp, 7 bytes BCD)
0390++ 0000             CONSAV:         .equ     $F668
0391++ 0000             
0392++ 0000             ; F669: work area for evaluation of expressions: contains type of last evaluated number
0393++ 0000             ; constant; the value is in CONLO, for values of CONTYP, see VALTYP
0394++ 0000             ; Strings are never contant in BASIC!
0395++ 0000             CONTYP:         .equ     $F669
0396++ 0000             
0397++ 0000             ; F66A-F671: work area for evaluation of expressions: contains the value of the last
0398++ 0000             ; evaluated number contant; value starts at F66A, and takes bytes as needed for the type
0399++ 0000             CONLO:          .equ     $F66A
0400++ 0000             
0401++ 0000             ; F672-F673: upper limit of memory area reserved for strings, contains the upper address
0402++ 0000             ; that is allowed to be used
0403++ 0000             MEMSIZ:         .equ     $F672
0404++ 0000             
0405++ 0000             ; F674-F675: top of stack; also first byte below string area
0406++ 0000             STKTOP:         .equ     $F674
0407++ 0000             
0408++ 0000             ; F676-F677: start address of current basic program, set at initialization, and
0409++ 0000             ; not changed by OS (ini:$8001)
0410++ 0000             TXTTAB:         .equ     $F676
0411++ 0000             
0412++ 0000             ; F678-F679: address of first unused string-descriptor in TEMPST
0413++ 0000             ; (ini:value of TEMPST)
0414++ 0000             TEMPPT:         .equ     $F678
0415++ 0000             
0416++ 0000             ; F67A-F697: work area for evaluation of string expressions; this area has space
0417++ 0000             ; for 10 string descriptors of 3 bytes; these can be used for temporarely results
0418++ 0000             ; of string arythmetics
0419++ 0000             TEMPST:         .equ     $F67A
0420++ 0000             
0421++ 0000             ; F698-F69A: work area for evaluation of string expressions; this contains the
0422++ 0000             ; string descriptor of the intermediate result
0423++ 0000             DSCTMP:         .equ     $F698
0424++ 0000             
0425++ 0000             ; F69B-F69C: first address within the string memory area that is still free
0426++ 0000             ; the string area is filled backwar.ds, soo the lower the value, the less space
0427++ 0000             ; remains (ini: value of MEMSIZ)
0428++ 0000             FRETOP:         .equ     $F69B
0429++ 0000             
0430++ 0000             ; F69D-F69E: temporarely storage for adminstration of the basic interpreter
0431++ 0000             TEMP3:          .equ     $F69D
0432++ 0000             
0433++ 0000             ; F69F-F6A0: temporarely storage for garbage collection
0434++ 0000             TEMP8:          .equ     $F69F
0435++ 0000             
0436++ 0000             ; F6A1-F6A2: address of first byte in BASIC-code after last FOR statement
0437++ 0000             ENDFOR:         .equ     $F6A1
0438++ 0000             
0439++ 0000             ; F6A3-F6A4: line number of last used line of DATA statements
0440++ 0000             DATLIN:         .equ     $F6A3
0441++ 0000             
0442++ 0000             ; F6A5: switch indicating if a variable is allowed to be an array variable.
0443++ 0000             ; This is e.g. not allowed for the loop variable of a FOR statement
0444++ 0000             ; 0 = allowed, 1 = not allowed
0445++ 0000             SUBFLG:         .equ     $F6A5
0446++ 0000             
0447++ 0000             ; F6A6: switch indicating if currently a READ or INPUT statement is being executed
0448++ 0000             FLKINP:         .equ     $F6A6
0449++ 0000             
0450++ 0000             ; F6A7-F6A8: temporarely storage for adminstration of the basic interpreter
0451++ 0000             TEMP:           .equ     $F6A7
0452++ 0000             
0453++ 0000             ; F6A9: switch indicating if there are still linenumber constants in the BASIC code
0454++ 0000             ; that are encoded as pointers?
0455++ 0000             PTRFLG:         .equ     $F6A9
0456++ 0000             
0457++ 0000             ; F6AA: switch indication if currently an AUTO statement is active
0458++ 0000             ; 0 = no auto, 1 = auto
0459++ 0000             AUTFLG:         .equ     $F6AA
0460++ 0000             
0461++ 0000             ; F6AB-F6AC: last generated AUTO line number
0462++ 0000             AUTLIN:         .equ     $F6AB
0463++ 0000             
0464++ 0000             ; F6AD-F6AE: last used AUTO increment
0465++ 0000             AUTINC:         .equ     $F6AD
0466++ 0000             
0467++ 0000             ; F6AF-F6B0: work area of the error system; contains address of first byte
0468++ 0000             ; of statement currently being executed
0469++ 0000             SAVTXT:         .equ     $F6AF
0470++ 0000             
0471++ 0000             ; F6B1-F6B2: work area of the error system; contains address of the stack
0472++ 0000             ; before executing of the current statement started
0473++ 0000             SAVSTK:         .equ     $F6B1
0474++ 0000             
0475++ 0000             ; F6B3-F6B4: line number of last failed line
0476++ 0000             ERRLIN:         .equ     $F6B3
0477++ 0000             
0478++ 0000             ; F6B5-F6B6: line number of last used (changed, listed, added) line
0479++ 0000             DOT:            .equ     $F6B5
0480++ 0000             
0481++ 0000             ; F6B7-F5B8: work area of the error system; contains the address of the first
0482++ 0000             ; byte of the statement that last failed; on failure it is stored with the
0483++ 0000             ; content of SAVTXT
0484++ 0000             ERRTXT:         .equ     $F6B7
0485++ 0000             
0486++ 0000             ; F6B9-F6BA: work area of the error system; contains the line number where
0487++ 0000             ; execution should go to on error (as in basic: ON ERROR GOTO x)
0488++ 0000             ONELIN:         .equ     $F6B9
0489++ 0000             
0490++ 0000             ; F6BB-F6BC: work area of the error system; indication if the interpreter is
0491++ 0000             ; currently executing an error catch routine
0492++ 0000             ; 0 = no, FF = yes
0493++ 0000             ONEFLG:         .equ     $F6BB
0494++ 0000             
0495++ 0000             ; F6BC-F6BD: temporarely storage for the interpreter
0496++ 0000             TEMP2:          .equ     $F6BC
0497++ 0000             
0498++ 0000             ; F6BE-F6BF: line number of last program break, reset at 0 at any program change
0499++ 0000             OLDLIN:         .equ     $F6BE
0500++ 0000             
0501++ 0000             ; F6C0-F6C1: address of first statement that is not executed due to a break
0502++ 0000             OLDTXT:         .equ     $F6C0
0503++ 0000             
0504++ 0000             ; F6C2-F6C3: begin address of storage of basic variables and function descriptors;
0505++ 0000             ; possibly adjusted when program changes in size
0506++ 0000             VARTAB:         .equ     $F6C2
0507++ 0000             
0508++ 0000             ; F6C4-F6C5: begin address of array variables; possibly adjusted when program
0509++ 0000             ; changes size or more variables are allocated
0510++ 0000             ARYTAB:         .equ     $F6C4
0511++ 0000             
0512++ 0000             ; F6C6-F6C7: address of first free byte not used for storage of code or variables
0513++ 0000             ; (ini: $8003)
0514++ 0000             STREND:         .equ     $F6C6
0515++ 0000             
0516++ 0000             ; F6C8-F6C9: address where data nee.ds to be searched at next READ statement
0517++ 0000             DATPTR:         .equ     $F6C8
0518++ 0000             
0519++ 0000             ; F6CA-F6E3: table with variable types, one for each letter in the alphabet
0520++ 0000             ; possible values:
0521++ 0000             ;       2 = integer     3 = string      4 = single      8 = double
0522++ 0000             DEFTBL:         .equ     $F6CA
0523++ 0000             
0524++ 0000             ; F6E4-F7B4: work area for execution of self defined functions
0525++ 0000             
0526++ 0000             ; F6E4-F6E5: contains address ; of previous parameter block on the stack;
0527++ 0000             ; needed for garbage collection
0528++ 0000             PRMSTK:         .equ     $F6E4
0529++ 0000             
0530++ 0000             ; F6E6-F6E7:  amount of valid bytes in PARM1
0531++ 0000             PRMLEN:         .equ     $F6E6
0532++ 0000             
0533++ 0000             ; F6E8-F74B: contains definitions of the variables in the parameter lists
0534++ 0000             ; of self defined functions
0535++ 0000             PARM1:          .equ     $F6E8
0536++ 0000             
0537++ 0000             ; F74C-F74D: previous value of PRMSTK
0538++ 0000             PRMDRV:         .equ     $F74C
0539++ 0000             
0540++ 0000             ; F74E-F74F: number of valid bytes in PARM2
0541++ 0000             PRMLN2:         .equ     $F74E
0542++ 0000             
0543++ 0000             ; F750-F7B3: area used for calculation of values that end up in PARM1
0544++ 0000             PARM2:          .equ     $F750
0545++ 0000             
0546++ 0000             ; F7B4: switch indicating of while searching a variable name PARM1 has
0547++ 0000             ; been looked at; 0 = no, 1 = yes
0548++ 0000             PRMFLG:         .equ     $F7B4
0549++ 0000             
0550++ 0000             ; F7B5-F7B6: address of first byte where it is no longer needed to search
0551++ 0000             ; for a variable name; it is .equal to ARYTAB when the normal variable area
0552++ 0000             ; is searched, and .equal to PARM1+PRMLEN when PARM1 is searched
0553++ 0000             ARYTA2:         .equ     $F7B5
0554++ 0000             
0555++ 0000             ; F7B7-F7B8: switch indicating iif PARM1 contains a valid parameter block
0556++ 0000             ; 0 = no, 1 = yes
0557++ 0000             NOFUNS:         .equ     $F7B7
0558++ 0000             
0559++ 0000             ; F7B8-F7B9: temporarely memory used while searching parameter blocks on
0560++ 0000             ; the stack
0561++ 0000             TEMP9:          .equ     $F7B8
0562++ 0000             
0563++ 0000             ; F7BA-F7BB: counter of the nesting-dept of the function being evaluated
0564++ 0000             FUNACT:         .equ     $F7BA
0565++ 0000             
0566++ 0000             ; F7BC-F7C3: work area when executing the SWAP statement; the first variable
0567++ 0000             ; is stored here
0568++ 0000             SWPTMP:         .equ     $F7BC
0569++ 0000             
0570++ 0000             ; F7C4: switch indicating if TRON is on; 0 = off, >0 = on
0571++ 0000             TRCFLG:         .equ     $F7C4
0572++ 0000             
0573++ 0000             ; F7C5-F7F4: workarea when executing numeric operators
0574++ 0000             FBUFFR:         .equ     $F7C5
0575++ 0000             DECTMP:         .equ     $F7F0
0576++ 0000             DECTM2:         .equ     $F7F2
0577++ 0000             DECCNT:         .equ     $F7F4
0578++ 0000             
0579++ 0000             ; F7F6-F805: workarea when executing numeric operators; intermediate
0580++ 0000             ; results are stored here; also used for parameter transfer when using
0581++ 0000             ; the USR functions; VALTYPE then contains the type, and the value is
0582++ 0000             ; stored like this:
0583++ 0000             ; typename  type  where
0584++ 0000             ; integer   2     F7F8-F7F9
0585++ 0000             ; string    3     F7F8-F7F9 (address descriptor)
0586++ 0000             ; single    4     F7F6-F7F9
0587++ 0000             ; double    8     F7F6-F7FD
0588++ 0000             DAC:            .equ     $F7F6
0589++ 0000             
0590++ 0000             ; F806-F856: workarea when executing numeric operators
0591++ 0000             HOLD8:          .equ     $F806
0592++ 0000             HOLD2:          .equ     $F836
0593++ 0000             HOLD:           .equ     $F83E
0594++ 0000             ARG:            .equ     $F847
0595++ 0000             
0596++ 0000             ; F857-F85E: last calculated random double
0597++ 0000             RNDX:           .equ     $F857
0598++ 0000             
0599++ 0000             ; --------------------
0600++ 0000             ; filesystem work area
0601++ 0000             ; --------------------
0602++ 0000             
0603++ 0000             ; F85F: # of filedescriptors reserved minus 1
0604++ 0000             ; this is also the maximum number of open files possible
0605++ 0000             MAXFIL:         .equ     $F85F
0606++ 0000             
0607++ 0000             ; F860-F861: start address of the file information table
0608++ 0000             FILTAB:         .equ     $F860
0609++ 0000             
0610++ 0000             ; F862-F863: start address of the first file-buffer
0611++ 0000             NULBUF:         .equ     $F862
0612++ 0000             
0613++ 0000             ; F864-F865: during file I/O the start address of the active file-buffer
0614++ 0000             PTRFIL:         .equ     $F864
0615++ 0000             
0616++ 0000             ; F866: flag indicating if the file that is being loaded have to be started
0617++ 0000             ; immediately; 0 = no, FF = yes
0618++ 0000             RUNFLG:         .equ     $F866
0619++ 0000             
0620++ 0000             ; note that RUNFLG and FILNAM overlap!
0621++ 0000             
0622++ 0000             ; F866-F870: filename of last file that has been active;
0623++ 0000             ; first 8 chars are name, last 3 are extension
0624++ 0000             FILNAM:         .equ     $F866
0625++ 0000             
0626++ 0000             ; F871-F87B: second filename if needed, e.g. the NAME command
0627++ 0000             FILNM2:         .equ     $F871
0628++ 0000             
0629++ 0000             ; F87C: switch indicating if currently a BASIC program is being loaded
0630++ 0000             ; 0 = no, 1 = yes
0631++ 0000             NLONLY:         .equ     $F87C
0632++ 0000             
0633++ 0000             ; F87D-F87E: workarea for BLOAD and BSAVE; when a part of normal memory
0634++ 0000             ; is written, it contains the end address of the written memory region
0635++ 0000             ; if video memory is written it contains $4BE5 + start address of the
0636++ 0000             ; written memory region ??
0637++ 0000             SAVEND:         .equ     $F87D
0638++ 0000             
0639++ 0000             ; F87F-F91E: storage area for the text of the function keys 10x16 bytes,
0640++ 0000             ; but strings need to be zero-terminated, soo maximum length of command is
0641++ 0000             ; 15 characters
0642++ 0000             FNKSTR:         .equ     $F87F
0643++ 0000             
0644++ 0000             ; ------------------------
0645++ 0000             ; screen routine work area
0646++ 0000             ; ------------------------
0647++ 0000             
0648++ 0000             ; F91F-F921: start address of the standard ASCII pattern table
0649++ 0000             ; at every change towar.ds a text mode it is copied in the pattern table
0650++ 0000             ; of the VDP
0651++ 0000             ;   F91F: slot indication (ini: 0)
0652++ 0000             ;   F920-F921: address (ini: 1BBF)
0653++ 0000             ; TODO: make CBIOS use this value instead of hardcoded value
0654++ 0000             CGPNT:          .equ     $F91F
0655++ 0000             
0656++ 0000             ; F922-F923: start address of the nametable in the VRAM
0657++ 0000             NAMBAS:         .equ     $F922
0658++ 0000             
0659++ 0000             ; F924-F925: start address of the pattern table in the VRAM
0660++ 0000             CGPBAS:         .equ     $F924
0661++ 0000             
0662++ 0000             ; F926-F927: start address of the sprite pattern table in the VRAM
0663++ 0000             PATBAS:         .equ     $F926
0664++ 0000             
0665++ 0000             ; F928-F929: start address of the sprite location table in the VRAM
0666++ 0000             ATRBAS:         .equ     $F928
0667++ 0000             
0668++ 0000             ; F92A-F92B: address in VRAM of the pattern of the current position
0669++ 0000             ; on screen
0670++ 0000             CLOC:           .equ     $F92A
0671++ 0000             
0672++ 0000             ; F92C: mask for CLOC selecting the right bits that correspond with
0673++ 0000             ; the current position
0674++ 0000             CMASK:          .equ     $F92C
0675++ 0000             
0676++ 0000             ; F92D-F930: work area for graphical calculations
0677++ 0000             MINDEL:         .equ     $F92D
0678++ 0000             MAXDEL:         .equ     $F92F
0679++ 0000             
0680++ 0000             ; ----------------------------------------------
0681++ 0000             ; F931-F941: work area for calculation of CIRCLE
0682++ 0000             ; ----------------------------------------------
0683++ 0000             
0684++ 0000             ; F931-F932: ratio of # of dots in the horizontal and vertical direction
0685++ 0000             ; if = $0100 then ASPCT1 and ASPCT2 are used
0686++ 0000             ; if < $0100 then it is the # of dots in one direction for each
0687++ 0000             ; $0100 # of dots in the other direction; the direction is indicated
0688++ 0000             ; by CSCLXY
0689++ 0000             ASPECT:         .equ     $F931
0690++ 0000             
0691++ 0000             ; F933:F934: ; distance, in # of dots from the center of the most
0692++ 0000             ; distant point of the circle
0693++ 0000             CENCNT:         .equ     $F933
0694++ 0000             
0695++ 0000             ; F935: switch indication if the start and/or end point need to be
0696++ 0000             ; connected to the center
0697++ 0000             ;  bit 7: connect end point; 1 = yes
0698++ 0000             ;  bit 0: connect start point; 1 = yes
0699++ 0000             CLINEF:         .equ     $F935
0700++ 0000             
0701++ 0000             ; F936-F937: used during calculation of CIRCLE
0702++ 0000             CNPNTS:         .equ     $F936
0703++ 0000             
0704++ 0000             ; F938: direction of drawing of circle:
0705++ 0000             ;  00 = from CSTCNT towar.ds CENCNT
0706++ 0000             ;  FF = from CENCNT towar.ds CSTCNT
0707++ 0000             CPLOTF:         .equ     $F938
0708++ 0000             
0709++ 0000             ; F939-F93A: used during calculation of CIRCLE
0710++ 0000             CPCNT:          .equ     $F939
0711++ 0000             
0712++ 0000             ; F93B-F93C: ; contains the total # of dots of the full circle,
0713++ 0000             ; even when only a part is drawn
0714++ 0000             CPCNT8:         .equ     $F93B
0715++ 0000             
0716++ 0000             ; F93D-F93E: used during calculation of CIRCLE
0717++ 0000             CRCSUM:         .equ     $F93D
0718++ 0000             
0719++ 0000             ; F93F-F940: ; distance in dots from the center towar.ds the closest
0720++ 0000             ; circle point
0721++ 0000             CSTCNT:         .equ     $F93F
0722++ 0000             
0723++ 0000             ; F941: switch indicating if the X or Y direction nee.ds to be streched:
0724++ 0000             ; 0 = X, 1 = Y
0725++ 0000             CSCLXY:         .equ     $F941
0726++ 0000             
0727++ 0000             ; F942-F943: store of CLOC, also used for PAINT
0728++ 0000             CSAVEA:         .equ     $F942
0729++ 0000             
0730++ 0000             ; F944: storage of CMASK; also used for PAINT
0731++ 0000             CSAVEM:         .equ     $F944
0732++ 0000             
0733++ 0000             ; F945-F946: horizontal distance towar.ds the center
0734++ 0000             CXOFF:          .equ     $F945
0735++ 0000             
0736++ 0000             ; F947-F948: vertical distance towar.ds the center
0737++ 0000             CYOFF:          .equ     $F947
0738++ 0000             
0739++ 0000             ; -------------------------------------------
0740++ 0000             ; work area for executing the PAINT statement
0741++ 0000             ; -------------------------------------------
0742++ 0000             
0743++ 0000             ; F949: leftmost position of protrusion towar.ds the left
0744++ 0000             LOHMSK:         .equ     $F949
0745++ 0000             
0746++ 0000             ; F94A: new workdirection for protrusion towar.ds the left
0747++ 0000             LOHDIR:         .equ     $F94A
0748++ 0000             
0749++ 0000             ;F94B-F94C: leftmost position of protrusion towar.ds the left
0750++ 0000             LOHADR:         .equ     $F94B
0751++ 0000             
0752++ 0000             ; F94D: size of protrusion towar.ds the left
0753++ 0000             LOHCNT:         .equ     $F94D
0754++ 0000             
0755++ 0000             ; F94F-F950: # of pixels that may be skipped
0756++ 0000             SKPCNT:         .equ     $F94F
0757++ 0000             
0758++ 0000             ; F951-F952: # of movements
0759++ 0000             MOVCNT:         .equ     $F951
0760++ 0000             
0761++ 0000             ; F953: current direction; $40 = \/, $C0 = /\, $00 = stop
0762++ 0000             PDIREC:         .equ     $F953
0763++ 0000             
0764++ 0000             ; F954: indicate if paint towar.ds the left worked
0765++ 0000             LFPROG:         .equ     $F954
0766++ 0000             
0767++ 0000             ; F955: indicate of a paint towar.ds the right worked
0768++ 0000             RTPROG:         .equ     $F955
0769++ 0000             
0770++ 0000             ; F956-F957: start address of a jumptable for subcomman.ds
0771++ 0000             ; contained in a string variable, used for both PLAY and DRAW
0772++ 0000             ; where this systemvar points to either the PLAY or the DRAW
0773++ 0000             ; table
0774++ 0000             MCLTAB:         .equ     $F956
0775++ 0000             
0776++ 0000             ; F958: switch indication if MCLTAB is for PLAY or DRAW
0777++ 0000             ; $0 = DRAW, $FF = PLAY
0778++ 0000             MCLFLG:         .equ     $F958
0779++ 0000             
0780++ 0000             ; ------------------------------------------
0781++ 0000             ; work area for sound and queueing and RS232
0782++ 0000             ; ------------------------------------------
0783++ 0000             
0784++ 0000             ; F959-F971: Variables for three music queues and one RS232 queue
0785++ 0000             ; F959: VOICAQ put position
0786++ 0000             ; F95A: VOICAQ get position
0787++ 0000             ; F95B: VOICAQ putback flag
0788++ 0000             ; F95C: VOICAQ size
0789++ 0000             ; F95D: VOICAQ address
0790++ 0000             ; F95F-F964: VOICBQ
0791++ 0000             ; F965-F96A: VOICCQ
0792++ 0000             ; F96B-F970: RS2IQ
0793++ 0000             QUETAB:         .equ     $F959
0794++ 0000             
0795++ 0000             ; Putback characters for queues. TODO: what purpose do these have exactly?
0796++ 0000             QUEBAK:         .equ     $F971
0797++ 0000             
0798++ 0000             ; Buffers for queues.
0799++ 0000             VOICAQ:         .equ     $F975           ; Voice A queue
0800++ 0000             VOICBQ:         .equ     $F9F5           ; Voice B queue
0801++ 0000             VOICCQ:         .equ     $FA75           ; Voice C queue
0802++ 0000             RS2IQ:          .equ     $FAF5           ; RS232   queue
0803++ 0000             
0804++ 0000             ; in MSX2 the content of RS2IQ is used differently:
0805++ 0000             DPPAGE:         .equ     $FAF5           ; Display page (SCR5+)
0806++ 0000             ACPAGE:         .equ     $FAF6           ; Active page (SCR5+)
0807++ 0000             
0808++ 0000             ; FAF7: AV control port value storage
0809++ 0000             AVCSAV:         .equ     $FAF7
0810++ 0000             
0811++ 0000             ; FAF8: extended BASIC ROM slot address
0812++ 0000             EXBRSA:         .equ     $FAF8           ; TuÊu
0813++ 0000             
0814++ 0000             ; FAF9: character count for ROMA-KANA
0815++ 0000             CHRCNT:         .equ     $FAF9
0816++ 0000             
0817++ 0000             ; FAFA-FAFB: character save for ROMA-KANA
0818++ 0000             ROMA:           .equ     $FAFA
0819++ 0000             
0820++ 0000             ; ROMA-KANA extension mode switch or VRAM size??
0821++ 0000             MODE:           .equ     $FAFC
0822++ 0000             ;Reserved       .equ     $FAFD
0823++ 0000             
0824++ 0000             ; FAFE-FAFF: x position for mouse or lightpen
0825++ 0000             XSAVE:          .equ     $FAFE
0826++ 0000             
0827++ 0000             ; FB00-FB01: y position for mouse or lightpen
0828++ 0000             YSAVE:          .equ     $FB00
0829++ 0000             LOGOPR:         .equ     $FB02
0830++ 0000             ; FB21-FB28: Table which contains info for up to 4 disk ROMs, 2 bytes each:
0831++ 0000             ; - first byte: number of drives connected to this interface
0832++ 0000             ; - second byte: slot ID of the disk ROM
0833++ 0000             DRVINF:         .equ     $FB21
0834++ 0000             ; end of MSX2 only usage of RS2IQ
0835++ 0000             
0836++ 0000             ; --------------------------------
0837++ 0000             ; work area for the PLAY statement
0838++ 0000             ; --------------------------------
0839++ 0000             
0840++ 0000             ; FB35: status about the parsing of a PLAY string
0841++ 0000             ;  bit 7: only one time parsed; 1 = yes
0842++ 0000             ;  bit 1-0: number of parsed strings (0-3)
0843++ 0000             PRSCNT:         .equ     $FB35
0844++ 0000             
0845++ 0000             ; FB36-FB37: storage of stack
0846++ 0000             SAVSP:          .equ     $FB36
0847++ 0000             
0848++ 0000             ; FB38: # of voice currently being parsed (0-2)
0849++ 0000             VOICEN:         .equ     $FB38
0850++ 0000             
0851++ 0000             ; FB39-FB3A: storage of volume of a muted voice
0852++ 0000             SAVVOL:         .equ     $FB39
0853++ 0000             
0854++ 0000             ; FB3B: size of string being parsed (also used by DRAW)
0855++ 0000             MCLLEN:         .equ     $FB3B
0856++ 0000             
0857++ 0000             ; FB3C-FB3D: address of string being parsed (also used by DRAW)
0858++ 0000             MCLPTR:         .equ     $FB3C
0859++ 0000             
0860++ 0000             ; FB3E: temporarely storage of active queue # (0-2)
0861++ 0000             QUEUEN:         .equ     $FB3E
0862++ 0000             
0863++ 0000             ; FB3F: flag indicating which queues are active
0864++ 0000             ; bit 2 = queue 2; 1 = active
0865++ 0000             ; bit 1 = queue 1; 1 = active
0866++ 0000             ; bit 0 = queue 0; 1 = active
0867++ 0000             MUSICF:         .equ     $FB3F
0868++ 0000             
0869++ 0000             ; FB40: count of the # of PLAY statements parsed, but not executed yet
0870++ 0000             PLYCNT:         .equ     $FB40
0871++ 0000             
0872++ 0000             ; FB41-FB65: Voice Control Block for voice A (queue 0)
0873++ 0000             VCBA:           .equ     $FB41
0874++ 0000             ; FB66-FB8A: Voice Control Block for voice B (queue 1)
0875++ 0000             VCBB:           .equ     $FB66
0876++ 0000             ; FB8B-FBAF: Voice Control Block for voice C (queue 2)
0877++ 0000             VCBC:           .equ     $FB8B
0878++ 0000             
0879++ 0000             ; each VCB has the following structure:
0880++ 0000             
0881++ 0000             ; name                  offset  length  purpose
0882++ 0000             METREX:         .equ     0 ;     2       interrupt counter
0883++ 0000             VCXLEN:         .equ     2 ;     1       MCLLEN for voice
0884++ 0000             VCXPTR:         .equ     3 ;     2       MCLPTR for voice
0885++ 0000             VCXSTP:         .equ     5 ;     2       stack pointer
0886++ 0000             QLENGX:         .equ     7 ;     1       # bytes in queue
0887++ 0000             NTICSX:         .equ     8 ;     2       new counter ?
0888++ 0000             TONPRX:         .equ     10;     2       pitch
0889++ 0000             AMPLTX:         .equ     12;     1       amplitude
0890++ 0000             ENVPRX:         .equ     13;     2       envelope speed
0891++ 0000             OCTAVX:         .equ     15;     1       octave
0892++ 0000             NOTELX:         .equ     16;     1       tone length
0893++ 0000             TEMPOX:         .equ     17;     1       tempo
0894++ 0000             VOLUMX:         .equ     18;     1       volume
0895++ 0000             ENVLPX:         .equ     19;     1       envelope shape
0896++ 0000             MCLSTX:         .equ     33;             space for stack storage
0897++ 0000             MCLSEX:         .equ     36;             start of stack
0898++ 0000             ; the stack mentioned above is used to store bytevalues
0899++ 0000             ; that are readied to be put on the voice queue
0900++ 0000             
0901++ 0000             ; -----------------------------------------------
0902++ 0000             ; settings for screen editor and interrupt system
0903++ 0000             ; -----------------------------------------------
0904++ 0000             
0905++ 0000             ; FBB0: switch indicating if software reset is enabled
0906++ 0000             ; 0 = n, 1 = yes; can be used to reset BASIC by pressing
0907++ 0000             ; SHIFT-CODE-GRAPH; does not erase the existing program
0908++ 0000             ; (ini: 0)
0909++ 0000             ENSTOP:         .equ     $FBB0
0910++ 0000             
0911++ 0000             ; FBB1: switch indicating if the current BASIC program is in a ROM
0912++ 0000             ; 0 = no; 1 = yes
0913++ 0000             BASROM:         .equ     $FBB1
0914++ 0000             
0915++ 0000             ; FBB2-FBC9: table containing for each line if it continues on the
0916++ 0000             ; next line; 0 = yes, >0 = no
0917++ 0000             LINTTB:         .equ     $FBB2
0918++ 0000             
0919++ 0000             ; FBCA-FBCB storage of location of cursor for INLIN and QINLIN
0920++ 0000             ;  FBCA: CSRY , FBCB: CSRX
0921++ 0000             FSTPOS:         .equ     $FBCA
0922++ 0000             
0923++ 0000             ; ASCII code of the character currently covered by the cursor
0924++ 0000             ; TODO: is the name CURSAV or CO.dsAV ?
0925++ 0000             CURSAV:         .equ     $FBCC
0926++ 0000             
0927++ 0000             ; FBCD: switch indicating which function keys are to be displayed
0928++ 0000             ; on the screen; 0 = F6-F10, 1 = F1-F5
0929++ 0000             FNKSWI:         .equ     $FBCD
0930++ 0000             
0931++ 0000             ; FBCE-FBD7: for each function key, a flag indicating if it has
0932++ 0000             ; interrupt facility enabled; 0 = disabled, 1 = enabled
0933++ 0000             FNKFLG:         .equ     $FBCE
0934++ 0000             
0935++ 0000             ; FBD8: counter of # of interrupts that still have a pending ON .. GOSUB
0936++ 0000             ONGSBF:         .equ     $FBD8
0937++ 0000             
0938++ 0000             ; FBD9: flag indicating if a keyclick has already been generated, to avoid
0939++ 0000             ; keyclicks for a key that generates two ASCII codes
0940++ 0000             ; $00 = no click, $0F = click
0941++ 0000             CLIKFL:         .equ     $FBD9
0942++ 0000             
0943++ 0000             ; FBDA-FBE4: storage of keyboard matrix, used for detection key repetition
0944++ 0000             OLDKEY:         .equ     $FBDA
0945++ 0000             
0946++ 0000             ; FBE5-FBEF: current state of the keyboard matrix
0947++ 0000             NEWKEY:         .equ     $FBE5
0948++ 0000             
0949++ 0000             ; keyboard buffer; each char entered via the keyboard en.ds up here
0950++ 0000             KEYBUF:         .equ     $FBF0
0951++ 0000             ; LIMPNT: something about "key buffer pointer"
0952++ 0000             LIMPNT:         .equ     $FC17           ; L[obt@ÖÌ|C^
0953++ 0000             
0954++ 0000             ; FC18-FC3F: work area for processing the last typed line
0955++ 0000             LINWRK:         .equ     $FC18           ; 40ªÌobt@
0956++ 0000             
0957++ 0000             ; FC40-FC47: storage for the patter of an ASCII character
0958++ 0000             ; used when writing an ASCII character in a graphical mode
0959++ 0000             PATWRK:         .equ     $FC40
0960++ 0000             
0961++ 0000             ; FC48-FC49: lowest address of the RAM memory; initialized at startup
0962++ 0000             ; and not changed normally
0963++ 0000             BOTTOM:         .equ     $FC48
0964++ 0000             
0965++ 0000             ; FC4A-FC4B: highest address of the RAM memory that is not reserved by
0966++ 0000             ; the OS; string area, filebuffers and stack are below this address
0967++ 0000             ; initialized at startup and not changed normally
0968++ 0000             HIMEM:          .equ     $FC4A
0969++ 0000             
0970++ 0000             ; FC4C-FC99: table for interrupt facilities of MSX BASIC
0971++ 0000             ; each 3 bytes are used like this:
0972++ 0000             ; byte 1 is a flag:
0973++ 0000             ;  bit 2: interrupt happened; 1 = yes
0974++ 0000             ;  bit 1: interrupt stop; 1 = yes
0975++ 0000             ;  bit 0: interrupt off; 1 = no
0976++ 0000             ; byte 2-3 is the adress of the line in BASIC where should be
0977++ 0000             ; jumped too
0978++ 0000             ; the offsets in the table are:
0979++ 0000             ;  offset  address interrupt
0980++ 0000             ;       0  FC4C    F1
0981++ 0000             ;       3  FC4F    F2
0982++ 0000             ;       6  FC52    F3
0983++ 0000             ;       9  FC55    F4
0984++ 0000             ;      12  FC58    F5
0985++ 0000             ;      15  FC5B    F6
0986++ 0000             ;      18  FC5E    F7
0987++ 0000             ;      21  FC61    F8
0988++ 0000             ;      24  FC64    F9
0989++ 0000             ;      27  FC67    F10
0990++ 0000             ;      30  FC6A    STOP
0991++ 0000             ;      33  FC6D    sprite collision
0992++ 0000             ;      36  FC70    SPACE (trigger 0)
0993++ 0000             ;      39  FC73    joystick 1 button 1 (trigger 1)
0994++ 0000             ;      39  FC76    joystick 2 button 1 (trigger 2)
0995++ 0000             ;      39  FC79    joystick 1 button 2 (trigger 3)
0996++ 0000             ;      39  FC7C    joystick 2 button 2 (trigger 4)
0997++ 0000             ;      39  FC7F    interval
0998++ 0000             TRPTBL:         .equ     $FC4C
0999++ 0000             
1000++ 0000             ; FC9A: usage unknown
1001++ 0000             RTYCNT:         .equ     $FC9A
1002++ 0000             
1003++ 0000             ; FC9B: STOP indication
1004++ 0000             ; 0 = nothing; 3 = CTRL+STOP, 4 = STOP
1005++ 0000             INTFLG:         .equ     $FC9B
1006++ 0000             
1007++ 0000             ; FC9C: last read Y-position of a touchpad
1008++ 0000             PADY:           .equ     $FC9C
1009++ 0000             
1010++ 0000             ; FC9D: last read X-position of a touchpad
1011++ 0000             PADX:           .equ     $FC9D
1012++ 0000             
1013++ 0000             ; FC9E-FC9F: software clock, updated at each VDP interrupt
1014++ 0000             JIFFY:          .equ     $FC9E           ; timer counter
1015++ 0000             
1016++ 0000             ; FCA0-FCA1: initial value of INTCNT, used when INTCNT
1017++ 0000             ; reaches 0; used for ON INTERVAL GOSUB
1018++ 0000             INTVAL:         .equ     $FCA0
1019++ 0000             
1020++ 0000             ; FCA2-FCA3: interrupt counter; lowered at each VDP interrupt;
1021++ 0000             ; reset with value of INTVAL when it reaches zero; if interval
1022++ 0000             ; interrupt is needed, it is generated
1023++ 0000             INTCNT:         .equ     $FCA2
1024++ 0000             
1025++ 0000             ; FCA4-FCA5: parameter used at tap input, given a value during
1026++ 0000             ; reading of a headerblock from tape
1027++ 0000             LOWLIM:         .equ     $FCA4
1028++ 0000             WINWID:         .equ     $FCA5
1029++ 0000             
1030++ 0000             ; FCA6: flag indicating if the previous character written
1031++ 0000             ; to the screen was an extension character for graphical signs
1032++ 0000             ; (ASCII 1); 0 = no, 1 = yes
1033++ 0000             GRPHED:         .equ     $FCA6
1034++ 0000             
1035++ 0000             ; FCA7 ESCCNT State of a state machine that handles the printing of escape
1036++ 0000             ; s.equences. A subset of the VT52 escape s.equences is supported.
1037++ 0000             ; values:
1038++ 0000             ; $00: not inside an escape s.equence
1039++ 0000             ; $01: seen <ESC>x
1040++ 0000             ; $02: seen <ESC>y
1041++ 0000             ; $03: seen <ESC>Y<row>
1042++ 0000             ; $04: seen <ESC>Y
1043++ 0000             ; $FF: seen <ESC>
1044++ 0000             ESCCNT:         .equ     $FCA7
1045++ 0000             
1046++ 0000             ; FCA8: switch indicating insert or overwrite mode
1047++ 0000             ; $00 = overwrite; $FF = insert
1048++ 0000             ; the value of INSFLG is changed each time the INS key is pressed
1049++ 0000             INSFLG:         .equ     $FCA8
1050++ 0000             
1051++ 0000             ; FCA9: show cursor; 0 = no, 1 = yes
1052++ 0000             ; can be changed with escape s.equences x5 and y5
1053++ 0000             CSRSW:          .equ     $FCA9
1054++ 0000             
1055++ 0000             ; FCAA: shape of cursor; 0 = block; 1 = insert
1056++ 0000             ; pressing the INS key changes the value of CSTYLE
1057++ 0000             ; can be changed with escape s.equences x4 and y4
1058++ 0000             CSTYLE:         .equ     $FCAA
1059++ 0000             
1060++ 0000             ; switch indicating if the CAPS-LOCK is on
1061++ 0000             ; $00 = off, $FF = on (unofficial: $80 = perma-on)
1062++ 0000             CAPST:          .equ     $FCAB
1063++ 0000             
1064++ 0000             ; FCAC: dead key control in non-japanese MSX models
1065++ 0000             ; ad.ds a mark on the next char pressed, if applicable
1066++ 0000             ;  0 = no dead key
1067++ 0000             ;  1 = dead key                => accent grave
1068++ 0000             ;  2 = SHIFT + dead key        => accent aigu
1069++ 0000             ;  3 = CODE + dead key         => accent circumflex
1070++ 0000             ;  4 = SHIFT + CODE + dead key => trema
1071++ 0000             ; in japanese models it controls the charset used
1072++ 0000             KANAST:         .equ     $FCAC
1073++ 0000             
1074++ 0000             ; FCAD: only used in japanese MSX models; it defines
1075++ 0000             ; the used typeset (ini: $40)
1076++ 0000             KANAMD:         .equ     $FCAD
1077++ 0000             
1078++ 0000             ; ----
1079++ 0000             ; misc
1080++ 0000             ; ----
1081++ 0000             
1082++ 0000             FLBMEM:         .equ     $FCAE
1083++ 0000             SCRMOD:         .equ     $FCAF
1084++ 0000             OLDSCR:         .equ     $FCB0
1085++ 0000             CASPRV:         .equ     $FCB1
1086++ 0000             BRDATR:         .equ     $FCB2
1087++ 0000             GXPOS:          .equ     $FCB3
1088++ 0000             GYPOS:          .equ     $FCB5
1089++ 0000             GRPACX:         .equ     $FCB7
1090++ 0000             GRPACY:         .equ     $FCB9
1091++ 0000             DRWFLG:         .equ     $FCBB
1092++ 0000             DRWANG:         .equ     $FCBD
1093++ 0000             RUNBNF:         .equ     $FCBE
1094++ 0000             SAVENT:         .equ     $FCBF
1095++ 0000             
1096++ 0000             ; ---------------------------
1097++ 0000             ; storage of slot information
1098++ 0000             ; ---------------------------
1099++ 0000             
1100++ 0000             ; FCC1-FCC4: Information for each primary slot. The most significant bit is
1101++ 0000             ; set if the primary slot is found to be expanded.
1102++ 0000             EXPTBL:         .equ     $FCC1
1103++ 0000             
1104++ 0000             ; FCC5-FCC8: Duplicate the contents of the four possible secondary slot
1105++ 0000             ; registers.
1106++ 0000             SLTTBL:         .equ     $FCC5
1107++ 0000             
1108++ 0000             ; FCC9-FD08: Information for any extension ROMs found during the power-up
1109++ 0000             ; ROM search.
1110++ 0000             ; FCC9-FCCC: primary slot 0, secondary slot 0
1111++ 0000             ; FCCD-FCD0: primary slot 0, secondary slot 1
1112++ 0000             ; FCD1-FCD4: primary slot 0, secondary slot 2
1113++ 0000             ; FCD5-FCD8: primary slot 0, secondary slot 3
1114++ 0000             ; FCD9-FCE8: primary slot 1
1115++ 0000             ; FCE9-FCF8: primary slot 2
1116++ 0000             ; FCF9-FD08: primary slot 3
1117++ 0000             ; The information is stored as below.
1118++ 0000             ; bit 7 (set): BASIC program
1119++ 0000             ; bit 6 (set): device handler
1120++ 0000             ; bit 5 (set): statement handler
1121++ 0000             SLTATR:         .equ     $FCC9
1122++ 0000             
1123++ 0000             SLTWRK:         .equ     $FD09
1124++ 0000             
1125++ 0000             ; ------------------------------
1126++ 0000             ; storage of ROM-page parameters
1127++ 0000             ; ------------------------------
1128++ 0000             
1129++ 0000             PROCNM:         .equ     $FD89
1130++ 0000             DEVICE:         .equ     $FD99
1131++ 0000             ; ------------
1132++ 0000             ; system hooks
1133++ 0000             ; ------------
1134++ 0000             
1135++ 0000             ; system hooks are defined in hooks.asm
1136++ 0000             
1137++ 0000             ; ------------------
1138++ 0000             ; storage of VDP8-23
1139++ 0000             ; ------------------
1140++ 0000             
1141++ 0000             ; FFE7-FFF6: storage of VDP 8-23
1142++ 0000             RG8SAV:         .equ     $FFE7
1143++ 0000             
1144++ 0000             ; ----------------------
1145++ 0000             ; extra slot information
1146++ 0000             ; ----------------------
1147++ 0000             
1148++ 0000             ; FFF7: slot address of main-rom
1149++ 0000             ;?????:         .equ     $FFF7
1150++ 0000             
1151++ 0000             ; ------------------
1152++ 0000             ; storage of VDP25-27
1153++ 0000             ; ------------------
1154++ 0000             
1155++ 0000             ; FFFA-FFFC: storage of VDP 25-27
1156++ 0000             RG25SAV:         .equ     $FFFA
1157++ 0000             
1158++ 0000             ; ---------------------------
1159++ 0000             ; subslot switching addresses
1160++ 0000             ; ---------------------------
1161++ 0000             
1162++ 0000             ; FFFF: subslot switching address
1163++ 0000             ; This is not actually a system variable, it is a har.dware register:
1164++ 0000             ;   SSL_REGS (see har.dware.asm).
1165++ 0000             
1166++ 0000             ; -------
1167++ 0000             ; the end
1168++ 0000             ; -------
1169++ 0000             
1170++ 0000             ; vim:ts=8:expandtab:filetype=z8a:syntax=z8a:
0051+  0000                             .include "hooks.asm"
0001++ 0000             ; $Id: hooks.asm 525 2008-12-22 22:16:42Z mthuurne $
0002++ 0000             ; C-BIOS hook declarations
0003++ 0000             ;
0004++ 0000             ; Copyright (c) 2002-2003 BouKiCHi.  All rights reserved.
0005++ 0000             ; Copyright (c) 2003 Reikan.  All rights reserved.
0006++ 0000             ; Copyright (c) 2004 Maarten ter Huurne.  All rights reserved.
0007++ 0000             ; Copyright (c) 2004 Manuel Bilderbeek.  All rights reserved.
0008++ 0000             ; Copyright (c) 2004-2006 Joost Yervante Damad.  All rights reserved.
0009++ 0000             ;
0010++ 0000             ; Redistribution and use in source and binary forms, with or without
0011++ 0000             ; modification, are permitted provided that the following conditions
0012++ 0000             ; are met:
0013++ 0000             ; 1. Redistributions of source code must retain the above copyright
0014++ 0000             ;    notice, this list of conditions and the following disclaimer.
0015++ 0000             ; 2. Redistributions in binary form must reproduce the above copyright
0016++ 0000             ;    notice, this list of conditions and the following disclaimer in the
0017++ 0000             ;    documentation and/or other materials provided with the distribution.
0018++ 0000             ;
0019++ 0000             ; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
0020++ 0000             ; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
0021++ 0000             ; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
0022++ 0000             ; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
0023++ 0000             ; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONS.equENTIAL DAMAGES (INCLUDING, BUT
0024++ 0000             ; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0025++ 0000             ; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0026++ 0000             ; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0027++ 0000             ; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
0028++ 0000             ; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0029++ 0000             ;
0030++ 0000             
0031++ 0000             ; called at start of interrupt subroutine, before it has been checked if
0032++ 0000             ; the interrupt was from VDP; used by e.g. RS232
0033++ 0000             H_KEYI:         .equ     $FD9A
0034++ 0000             
0035++ 0000             ; called at start of interrupt subroutine, when it is clear that
0036++ 0000             ; the interrupt is from the VDP
0037++ 0000             H_TIMI:         .equ     $FD9F
0038++ 0000             
0039++ 0000             ; called at start of CHPUT(00A2)
0040++ 0000             H_CHPU:         .equ     $FDA4
0041++ 0000             
0042++ 0000             ; called at start of the subroutine drawing the cursor
0043++ 0000             H_DSPC:         .equ     $FDA9
0044++ 0000             
0045++ 0000             ; called at start of the subroutine that removes the cursor
0046++ 0000             H_ERAC:         .equ     $FDAE
0047++ 0000             
0048++ 0000             ; called at start of DSPFNK(00CF)
0049++ 0000             H_DSPF:         .equ     $FDB3
0050++ 0000             
0051++ 0000             ; called at start of ERAFNK(00CC)
0052++ 0000             H_ERAF:         .equ     $FDB8
0053++ 0000             
0054++ 0000             ; called at start of TOTEXT(00D2)
0055++ 0000             H_TOTE:         .equ     $FDBD
0056++ 0000             
0057++ 0000             ; called at start of CHGET(009F)
0058++ 0000             H_CHGE:         .equ     $FDC2
0059++ 0000             
0060++ 0000             ; called at start of the subroutine that fills the pattern-table
0061++ 0000             ; can be used to override the default ASCII patterns
0062++ 0000             H_INIP:         .equ     $FDC7
0063++ 0000             
0064++ 0000             ; called at part of subroutine that decodes combined keystrokes
0065++ 0000             ; like with CTRL/CODE/GRAPH/SHIFT to an ASCII code; can be used
0066++ 0000             ; to override the working of the keyboard
0067++ 0000             H_KEYC:         .equ     $FDCC
0068++ 0000             
0069++ 0000             ; called at start of the subroutine that decodes single keystrokes;
0070++ 0000             ; can be used to override the working of the keyboard
0071++ 0000             H_KYEA:         .equ     $FDD1
0072++ 0000             
0073++ 0000             ; called at start of NMI interrupt subroutine
0074++ 0000             H_NMI:          .equ     $FDD6
0075++ 0000             
0076++ 0000             ; called at start of PINLIN(00AE)
0077++ 0000             H_PINL:         .equ     $FDDB
0078++ 0000             
0079++ 0000             ; called at start of QINLIN(00B4)
0080++ 0000             H_QINL:         .equ     $FDE0
0081++ 0000             
0082++ 0000             ; called at start of INLIN(00B1)
0083++ 0000             H_INLI:         .equ     $FDE5
0084++ 0000             
0085++ 0000             ; BASIC interpreter hook
0086++ 0000             H_ONGO:         .equ     $FDEA
0087++ 0000             
0088++ 0000             ; implementation hook for DSKO$
0089++ 0000             H_DSKO:         .equ     $FDEF
0090++ 0000             
0091++ 0000             ; implementation hook for SET
0092++ 0000             H_SETS:         .equ     $FDF4
0093++ 0000             
0094++ 0000             ; implementation hook for NAME
0095++ 0000             H_NAME:         .equ     $FDF9
0096++ 0000             
0097++ 0000             ; implementation hook for KILL
0098++ 0000             H_KILL:         .equ     $FDFE
0099++ 0000             
0100++ 0000             ; implementation hook for IPL
0101++ 0000             H_IPL:          .equ     $FE03
0102++ 0000             
0103++ 0000             ; implementation hook for COPY
0104++ 0000             H_COPY:         .equ     $FE08
0105++ 0000             
0106++ 0000             ; implementation hook for CMD
0107++ 0000             H_CMD:          .equ     $FE0D
0108++ 0000             
0109++ 0000             ; implementation hook for DSKF
0110++ 0000             H_DSKF:         .equ     $FE12
0111++ 0000             
0112++ 0000             ; implementation hook for DSKI$
0113++ 0000             H_DSKI:         .equ     $FE17
0114++ 0000             
0115++ 0000             ; implementation hook for ATTR$
0116++ 0000             H_ATTR:         .equ     $FE1C
0117++ 0000             
0118++ 0000             ; implementation hook for LSET
0119++ 0000             H_LSET:         .equ     $FE21
0120++ 0000             
0121++ 0000             ; implementation hook for RSET
0122++ 0000             H_RSET:         .equ     $FE26
0123++ 0000             
0124++ 0000             ; implementation hook for FIELD
0125++ 0000             H_FIEL:         .equ     $FE2B
0126++ 0000             
0127++ 0000             ; implementation hook for MKI$
0128++ 0000             H_MKIS:         .equ     $FE30
0129++ 0000             
0130++ 0000             ; implementation hook for MKS$
0131++ 0000             H_MKSS:         .equ     $FE35
0132++ 0000             
0133++ 0000             ; implementation hook for MKD$
0134++ 0000             H_MKDS:         .equ     $FE3A
0135++ 0000             
0136++ 0000             ; implementation hook for CVI
0137++ 0000             H_CVI:          .equ     $FE3F
0138++ 0000             
0139++ 0000             ; implementation hook for CVS
0140++ 0000             H_CVS:          .equ     $FE44
0141++ 0000             
0142++ 0000             ; implementation hook for CVD
0143++ 0000             H_CVD:          .equ     $FE49
0144++ 0000             
0145++ 0000             ; called when looking up the value of PTRFIL(F864) for DISKBASIC
0146++ 0000             H_GETP:         .equ     $FE4E
0147++ 0000             
0148++ 0000             ; called when PTRFIL(F864) is being given a new value
0149++ 0000             H_SETF:         .equ     $FE53
0150++ 0000             
0151++ 0000             ; called when an OPEN statement was issued without a FOR-part
0152++ 0000             ; part of DISKBASIC
0153++ 0000             H_NOFO:         .equ     $FE58
0154++ 0000             
0155++ 0000             ; called for an operation for file-buffer 0, in DISKBASIC
0156++ 0000             H_NULO:         .equ     $FE5D
0157++ 0000             
0158++ 0000             ; called from DISKBASIC for a call with file-buffer not 0
0159++ 0000             H_NTFL:         .equ     $FE62
0160++ 0000             
0161++ 0000             ; called when doing a MERGE command for disks
0162++ 0000             H_MERG:         .equ     $FE67
0163++ 0000             
0164++ 0000             ; called when doing a SAVE commands for disks
0165++ 0000             H_SAVE:         .equ     $FE6C
0166++ 0000             
0167++ 0000             ; called when doing a BSAVE command for disks
0168++ 0000             H_BINS:         .equ     $FE71
0169++ 0000             
0170++ 0000             ; called when doing a BLOAD command for disks
0171++ 0000             H_BINL:         .equ     $FE76
0172++ 0000             
0173++ 0000             ; implementation hook for FILES
0174++ 0000             H_FILE:         .equ     $FE7B
0175++ 0000             
0176++ 0000             ;  DISKBASIC hook
0177++ 0000             H_DGET:         .equ     $FE80
0178++ 0000             
0179++ 0000             ;  DISKBASIC hook
0180++ 0000             H_FILO:         .equ     $FE85
0181++ 0000             
0182++ 0000             ;  DISKBASIC hook
0183++ 0000             H_INDS:         .equ     $FE8A
0184++ 0000             
0185++ 0000             ; DISKBASIC entry for selecting the previous disk station for disk IO
0186++ 0000             H_RSLF:         .equ     $FE8F
0187++ 0000             
0188++ 0000             ; DISKBASIC entry for remembering the current disk station
0189++ 0000             H_SAVD:         .equ     $FE94
0190++ 0000             
0191++ 0000             ; implementation hook for LOC
0192++ 0000             H_LOC:          .equ     $FE99
0193++ 0000             
0194++ 0000             ; implementation hook for LOF
0195++ 0000             G_LOF:          .equ     $FE9E
0196++ 0000             
0197++ 0000             ; called when doing EOF for a disk in DISKBASIC
0198++ 0000             H_EOF:          .equ     $FEA3
0199++ 0000             
0200++ 0000             ; implementation hook for FPOS
0201++ 0000             H_FPOS:         .equ     $FEA8
0202++ 0000             
0203++ 0000             ; DISKBASIC hook
0204++ 0000             H_BAKU:         .equ     $FEAD
0205++ 0000             
0206++ 0000             ; called when BASIC interpreter is decoding the device part of a filename
0207++ 0000             H_PARD:         .equ     $FEB2
0208++ 0000             
0209++ 0000             ; called when BASIC interpreter finds a file without a device part
0210++ 0000             H_NODE:         .equ     $FEB7
0211++ 0000             
0212++ 0000             ; DISKBASIC hook
0213++ 0000             H_POSD:         .equ     $FEBC
0214++ 0000             
0215++ 0000             ; called when searching a device by name
0216++ 0000             H_DEVN:         .equ     $FEC1
0217++ 0000             
0218++ 0000             ; BASIC interpreter hook
0219++ 0000             H_GEND:         .equ     $FEC6
0220++ 0000             
0221++ 0000             ; Called when clearing variables during the preparation of a RUN statement.
0222++ 0000             ; Also used by the disk ROM to start boot s.equence.
0223++ 0000             H_RUNC:         .equ     $FECB
0224++ 0000             
0225++ 0000             ; called when doing CLEAR
0226++ 0000             H_CLEA:         .equ     $FED0
0227++ 0000             
0228++ 0000             ; BASIC interpreter hook
0229++ 0000             H_LOPD:         .equ     $FED5
0230++ 0000             
0231++ 0000             ; BASIC interpreter hook; called at stack error
0232++ 0000             H_STKE:         .equ     $FEDA
0233++ 0000             
0234++ 0000             ; called at the start of ISFLIO(014A)
0235++ 0000             H_ISFL:         .equ     $FEDF
0236++ 0000             
0237++ 0000             ; called at the start of OUTDO(0018)
0238++ 0000             H_OUTD:         .equ     $FEE4
0239++ 0000             
0240++ 0000             ; BASIC interpreter hook
0241++ 0000             H_CRDO:         .equ     $FEE9
0242++ 0000             
0243++ 0000             ; BASIC interpreter hook
0244++ 0000             H_DSKC:         .equ     $FEEE
0245++ 0000             
0246++ 0000             ; called at the end of a BASIC program
0247++ 0000             H_PRGE:         .equ     $FEF8
0248++ 0000             
0249++ 0000             ; BASIC interpreter hook
0250++ 0000             H_ERRP:         .equ     $FEFD
0251++ 0000             
0252++ 0000             ; BASIC interpreter hook
0253++ 0000             H_ERRF:         .equ     $FF02
0254++ 0000             
0255++ 0000             ; BASIC interpreter hook
0256++ 0000             H_READ:         .equ     $FF07
0257++ 0000             
0258++ 0000             ; BASIC interpreter hook
0259++ 0000             H_MAIN:         .equ     $FF0C
0260++ 0000             
0261++ 0000             ; called when executing a BASIC statement in direct mode
0262++ 0000             H_DIRD:         .equ     $FF11
0263++ 0000             
0264++ 0000             ; BASIC interpreter hook
0265++ 0000             H_FINI:         .equ     $FF16
0266++ 0000             
0267++ 0000             ; BASIC interpreter hook
0268++ 0000             H_FINE:         .equ     $FF1B
0269++ 0000             
0270++ 0000             ; called while encoding a just typed BASIC statement
0271++ 0000             H_CRUN:         .equ     $FF20
0272++ 0000             
0273++ 0000             ; called while encoding a just typed BASIC statement
0274++ 0000             H_CRUS:         .equ     $FF25
0275++ 0000             
0276++ 0000             ; called when a keyword has been found while encoding a just typed
0277++ 0000             ; BASIC statement
0278++ 0000             H_ISRE:         .equ     $FF2A
0279++ 0000             
0280++ 0000             ; called when a function has been found while encoding a just typed
0281++ 0000             ; BASIC statement
0282++ 0000             H_NTFN:         .equ     $FF2F
0283++ 0000             
0284++ 0000             ; called when a non-keyword has been found while encoding a just
0285++ 0000             ; typed BASIC statement
0286++ 0000             H_NOTR:         .equ     $FF34
0287++ 0000             
0288++ 0000             ; BASIC interpreter hook
0289++ 0000             H_SNGF:         .equ     $FF39
0290++ 0000             
0291++ 0000             ; BASIC interpreter hook
0292++ 0000             H_NEWS:         .equ     $FF3E
0293++ 0000             
0294++ 0000             ; BASIC interpreter hook
0295++ 0000             H_GONE:         .equ     $FF43
0296++ 0000             
0297++ 0000             ; called at start of CHRGTR(0010)
0298++ 0000             H_CHRG:         .equ     $FF48
0299++ 0000             
0300++ 0000             ; BASIC interpreter hook
0301++ 0000             H_RETU:         .equ     $FF4D
0302++ 0000             
0303++ 0000             ; BASIC interpreter hook
0304++ 0000             H_PRTF:         .equ     $FF52
0305++ 0000             
0306++ 0000             ; BASIC interpreter hook
0307++ 0000             H_COMP:         .equ     $FF57
0308++ 0000             
0309++ 0000             ; BASIC interpreter hook
0310++ 0000             H_FINP:         .equ     $FF5C
0311++ 0000             
0312++ 0000             ; BASIC interpreter hook
0313++ 0000             H_TRMN:         .equ     $FF61
0314++ 0000             
0315++ 0000             ; BASIC interpreter hook
0316++ 0000             H_FRME:         .equ     $FF66
0317++ 0000             
0318++ 0000             ; BASIC interpreter hook
0319++ 0000             H_NTPL:         .equ     $FF6B
0320++ 0000             
0321++ 0000             ; called when calculating the value of an expression in BASIC
0322++ 0000             H_EVAL:         .equ     $FF70
0323++ 0000             
0324++ 0000             ; BASIC interpreter hook
0325++ 0000             H_OKNO:         .equ     $FF75
0326++ 0000             
0327++ 0000             ; BASIC interpreter hook
0328++ 0000             H_FING:         .equ     $FF7A
0329++ 0000             
0330++ 0000             ; called when setting a value to a substring with MID$
0331++ 0000             H_ISMI:         .equ     $FF7F
0332++ 0000             
0333++ 0000             ; called when executing the WIDTH statement
0334++ 0000             H_WIDT:         .equ     $FF84
0335++ 0000             
0336++ 0000             ; called when executing the LIST statement
0337++ 0000             H_LIST:         .equ     $FF89
0338++ 0000             
0339++ 0000             ; BASIC interpreter hook
0340++ 0000             H_BUFL:         .equ     $FF8E
0341++ 0000             
0342++ 0000             ; BASIC interpreter hook
0343++ 0000             H_FRQI:         .equ     $FF93
0344++ 0000             
0345++ 0000             ; BASIC interpreter hook
0346++ 0000             H_SCNE:         .equ     $FF98
0347++ 0000             
0348++ 0000             ; BASIC interpreter hook
0349++ 0000             H_FRET:         .equ     $FF9D
0350++ 0000             
0351++ 0000             ; called when looking up a variable in BASIC
0352++ 0000             H_PTRG:         .equ     $FFA2
0353++ 0000             
0354++ 0000             ; called from within PHYDIO(0144), to allow its implementation
0355++ 0000             H_PHYD:         .equ     $FFA7
0356++ 0000             
0357++ 0000             ; called from within FORMAT(147), to allow its implementation
0358++ 0000             H_FORM:         .equ     $FFAC
0359++ 0000             
0360++ 0000             ; called form the error-handling routine of the BASIC interpreter
0361++ 0000             H_ERRO:         .equ     $FFB1
0362++ 0000             
0363++ 0000             ; called at start of LPTOUT(00A5)
0364++ 0000             H_LPTO:         .equ     $FFB6
0365++ 0000             
0366++ 0000             ; called at start of LPTSTT(00A8)
0367++ 0000             H_LPTS:         .equ     $FFBB
0368++ 0000             
0369++ 0000             ; called when executing SCREEN
0370++ 0000             H_SCRE:         .equ     $FFC0
0371++ 0000             
0372++ 0000             ; called when executing PLAY
0373++ 0000             H_PLAY:         .equ     $FFC5
0374++ 0000             
0375++ 0000             ; allows for installation of expansion devices that contain extra OS subroutines
0376++ 0000             H_BEXT:         .equ     $FFCA
0377++ 0000             
0378++ 0000             
0379++ 0000             ; vim:ts=8:expandtab:filetype=z8a:syntax=z8a:
0052+  0000             
0053+  0000             ;-----------------
0054+  0000             ; A memory address for debug
0055+  0000             ;-----------------
0056+  0000             
0057+  0000             COMPILE_FONT:   .equ     YES
0058+  0000             
0059+  0000             ;---------------------
0060+  0000             ; Jump table
0061+  0000             ;---------------------
0062+  0000             
0063+  0000             ; $0000 CHKRAM
0064+  0000                             .org     $0000
0065+  0000 F3                          di
0066+  0001 C3 12 0D                    jp      chkram
0067+  0004             
0068+  0004             ; Pointer to font
0069+  0004             ; $0004 CGTABL  Base address of the MSX character set in ROM
0070+  0004                             .ds      $0004 - $
0071+  0004 BF 1B                       .dw      B_Font
0072+  0006             
0073+  0006                             .ds      $0006 - $
0074+  0006             
0075+  0006             ; $0006 VDP.DR  Base port address for VDP data read
0076+  0006 98          vdp_dr:         .db      VDP_DATA        ; VDP read port
0077+  0007             ; $0007 VDP.WR  Base port address for VDP data write
0078+  0007 98          vdp_dw:         .db      VDP_DATA        ; VDP write port
0079+  0008             
0080+  0008             ; $0008 SYNCHR
0081+  0008                             .ds      $0008 - $
0082+  0008 C3 0C 0F                    jp      synchr
0083+  000B             
0084+  000B             ; $000C RDSLT   Read memory from an optional slot
0085+  000B                             .ds      $000C - $
0086+  000C C3 BF 23                    jp      rdslt
0087+  000F             
0088+  000F             ; $0010 CHRGTR
0089+  000F                             .ds      $0010 - $
0090+  0010 C3 1B 0F                    jp      chrgtr
0091+  0013             
0092+  0013             ; $0014 WRSLT   Write memory to an optional slot
0093+  0013                             .ds      $0014 - $
0094+  0014 C3 04 24                    jp      wrslt
0095+  0017             
0096+  0017             ; $0018 OUTDO
0097+  0017                             .ds      $0018 - $
0098+  0018 C3 37 0F                    jp      outdo
0099+  001B             
0100+  001B             ; $001C CALSLT   inter slot call routine
0101+  001B                             .ds      $001C - $
0102+  001C C3 05 24                    jp      calslt
0103+  001F             
0104+  001F             ; $0020 DCOMPR  Compare HL to DE
0105+  001F                             .ds      $0020 - $
0106+  0020 C3 3D 0F                    jp      dcompr
0107+  0023             
0108+  0023             ; $0024 ENASLT  Change slot
0109+  0023                             .ds      $0024 - $
0110+  0024 C3 06 24                    jp      enaslt
0111+  0027             
0112+  0027             ; $0028 GETYPR
0113+  0027                             .ds      $0028 - $
0114+  0028 C3 43 0F                    jp      getypr
0115+  002B             
0116+  002B             ; $002B I.dbYT1
0117+  002B                             .ds      $002B - $
0118+  002B             i.dbyt1:
0119+  002B             ; Basic ROM version
0120+  002B             ; 7 6 5 4 3 2 1 0
0121+  002B             ; | | | | +-+-+-+-- Character set
0122+  002B             ; | | | |           0 = Japanese, 1 = International (ASCII), 2=Korean
0123+  002B             ; | +-+-+---------- Date format
0124+  002B             ; |                 0 = Y-M-D, 1 = M-D-Y, 2 = D-M-Y
0125+  002B             ; +---------------- Default interrupt fr.equency
0126+  002B             ;                   0 = 60Hz, 1 = 50Hz
0127+  002B 11                          .db      LOCALE_CHSET + LOCALE_DATE + LOCALE_INT
0128+  002C             ; $002C I.dbYT2
0129+  002C             i.dbyt2:
0130+  002C             ; Basic ROM version
0131+  002C             ; 7 6 5 4 3 2 1 0
0132+  002C             ; | | | | +-+-+-+-- Keyboard type
0133+  002C             ; | | | |           0 = Japanese, 1 = International (QWERTY)
0134+  002C             ; | | | |           2 = French (AZERTY), 3 = UK, 4 = German (DIN)
0135+  002C             ; +-+-+-+---------- Basic version
0136+  002C             ;                   0 = Japanese, 1 = International
0137+  002C 02                          .db      LOCALE_KBD + LOCALE_BASIC
0138+  002D             
0139+  002D             ; $002D Version ID
0140+  002D             romid:
0141+  002D                             .ds      $002D - $
0142+  002D             ; version ID
0143+  002D             ; MSX version number
0144+  002D             ;  0 = MSX 1
0145+  002D             ;  1 = MSX 2
0146+  002D             ;  2 = MSX 2+
0147+  002D             ;  3 = MSX turbo R
0148+  002D 00                          .db      0
0149+  002E 00                          .db      0
0150+  002F             
0151+  002F             
0152+  002F             ; Reserved
0153+  002F 00                          .db      0
0154+  0030             
0155+  0030             ; $0030 CALLF    Call interslot routine(RST30h version)
0156+  0030                             .ds      $0030 - $
0157+  0030 C3 52 0F                    jp      callf
0158+  0033             
0159+  0033             ; $0038 KEYINT   Interrupt routines(RST38,VBlank,Timer...)
0160+  0033                             .ds      $0038 - $
0161+  0038 C3 2D 17                    jp      keyint
0162+  003B             
0163+  003B             ; $003B INITIO  Initialize I/O
0164+  003B                             .ds      $003B - $
0165+  003B C3 67 0F                    jp      initio
0166+  003E             
0167+  003E             ; $003E INIFNK
0168+  003E                             .ds      $003E - $
0169+  003E C3 71 0F                    jp      inifnk
0170+  0041             
0171+  0041             ; $0041 DISSCR  Disable screen display
0172+  0041                             .ds      $0041 - $
0173+  0041 C3 16 02                    jp      disscr
0174+  0044             
0175+  0044             ; $0044 ENASCR  Enable screen display
0176+  0044                             .ds      $0044 - $
0177+  0044 C3 22 02                    jp      enascr
0178+  0047             
0179+  0047             ;---------------
0180+  0047             ;VDP routines
0181+  0047             ;---------------
0182+  0047             
0183+  0047             ; $0047 WRTVDP
0184+  0047                             .ds      $0047 - $
0185+  0047 C3 2E 02                    jp      wrtvdp
0186+  004A             
0187+  004A             ; $004A RDVRM
0188+  004A                             .ds      $004A - $
0189+  004A C3 45 02                    jp      rdvrm
0190+  004D             
0191+  004D             ; $004D WRTVRM
0192+  004D                             .ds      $004D - $
0193+  004D C3 4B 02                    jp      wrtvrm
0194+  0050             
0195+  0050             ; $0050 SETRD
0196+  0050                             .ds      $0050 - $
0197+  0050 C3 53 02                    jp      setrd
0198+  0053             
0199+  0053             ; $0053 SETWRT  Set VRAM Write Address
0200+  0053                             .ds      $0053 - $
0201+  0053 C3 5E 02                    jp      setwrt
0202+  0056             
0203+  0056             ; $0056 FILVRM  Fill VRAM
0204+  0056                             .ds      $0056 - $
0205+  0056 C3 6B 02                    jp      filvrm
0206+  0059             
0207+  0059             ; $0059 LDIRMV  Copy VRAM to RAM
0208+  0059                             .ds      $0059 - $
0209+  0059 C3 80 02                    jp      ldirmv
0210+  005C             
0211+  005C             ; $005C LDIRVM  Copy RAM to VRAM
0212+  005C                             .ds      $005C - $
0213+  005C C3 97 02                    jp      ldirvm
0214+  005F             
0215+  005F             ; $005F CHGMOD Change VDP screen mode
0216+  005F                             .ds      $005F - $
0217+  005F C3 AF 02                    jp      chgmod
0218+  0062             
0219+  0062             ; $0062 CHGCLR
0220+  0062                             .ds      $0062 - $
0221+  0062 C3 D6 02                    jp      chgclr
0222+  0065             
0223+  0065             ; $0066 NMI     Non-maskable interrupt
0224+  0065                             .ds      $0066 - $
0225+  0066 C3 80 17                    jp      nmi
0226+  0069             
0227+  0069             ; $0069 CLRSPR  Clear sprites
0228+  0069                             .ds      $0069 - $
0229+  0069 C3 20 03                    jp      clrspr
0230+  006C             
0231+  006C             ; $006C INITXT  Initialize display to mode TEXT1    (SCREEN 0)
0232+  006C                             .ds      $006C - $
0233+  006C C3 7F 03                    jp      initxt
0234+  006F             
0235+  006F             ; $006F INIT32  Initialize display to mode GRAPHIC1 (SCREEN 1)
0236+  006F                             .ds      $006F - $
0237+  006F C3 BF 03                    jp      init32
0238+  0072             
0239+  0072             ; $0072 INITGRP Initialize display to mode GRAPHIC2 (SCREEN 2)
0240+  0072                             .ds      $0072 - $
0241+  0072 C3 02 04                    jp      inigrp
0242+  0075             
0243+  0075             ; $0075 INIMLT  Initialize display to mode MULTI    (SCREEN 3)
0244+  0075                             .ds      $0075 - $
0245+  0075 C3 40 04                    jp      inimlt
0246+  0078             
0247+  0078             ; $0078 SETTXT
0248+  0078                             .ds      $0078 - $
0249+  0078 C3 8C 04                    jp      settxt
0250+  007B             
0251+  007B             ; $007B SETT32
0252+  007B                             .ds      $007B - $
0253+  007B C3 B4 04                    jp      sett32
0254+  007E             
0255+  007E             ; $007E SETGRP
0256+  007E                             .ds      $007E - $
0257+  007E C3 E3 04                    jp      setgrp
0258+  0081             
0259+  0081             ; $0081 SETMLT
0260+  0081                             .ds      $0081 - $
0261+  0081 C3 16 05                    jp      setmlt
0262+  0084             
0263+  0084             ; $0084 CALPAT
0264+  0084                             .ds      $0084 - $
0265+  0084 C3 6C 05                    jp      calpat
0266+  0087             
0267+  0087             ; $0087 CALATR
0268+  0087                             .ds      $0087 - $
0269+  0087 C3 7F 05                    jp      calatr
0270+  008A             
0271+  008A             ; $008A GSPSIZ
0272+  008A                             .ds      $008A - $
0273+  008A C3 89 05                    jp      gspsiz
0274+  008D             
0275+  008D             ; $008D GRPPRT
0276+  008D                             .ds      $008D - $
0277+  008D C3 94 05                    jp      grpprt
0278+  0090             
0279+  0090             ; $0090 GICINI  initialize sound IC
0280+  0090                             .ds      $0090 - $
0281+  0090 C3 59 15                    jp      gicini
0282+  0093             ; $0093 WRTPSG
0283+  0093                             .ds      $0093 - $
0284+  0093 C3 71 15                    jp      wrtpsg
0285+  0096             ; $0096 RDPSG
0286+  0096                             .ds      $0096 - $
0287+  0096 C3 7B 15                    jp      rdpsg
0288+  0099             
0289+  0099             ; $0099 STRTMS
0290+  0099                             .ds      $0099 - $
0291+  0099 C3 80 0F                    jp      strtms
0292+  009C             
0293+  009C             ; $009C CHSNS  .. check key buffer
0294+  009C                             .ds      $009C - $
0295+  009C C3 8F 0F                    jp      chsns
0296+  009F             
0297+  009F             ; $009F CHGET .. Get data from keyboard buffer
0298+  009F                             .ds      $009F - $
0299+  009F C3 A2 0F                    jp      chget
0300+  00A2             
0301+  00A2             ; $00A2 CHPUT .. Output charactor to display
0302+  00A2                             .ds      $00A2 - $
0303+  00A2 C3 C7 0F                    jp      chput
0304+  00A5             
0305+  00A5             ; $00A5 LPTOUT
0306+  00A5                             .ds      $00A5 - $
0307+  00A5 C3 EC 12                    jp      lptout
0308+  00A8             
0309+  00A8             ; $00A8 LPTSTT
0310+  00A8                             .ds      $00A8 - $
0311+  00A8 C3 16 13                    jp      lptstt
0312+  00AB             
0313+  00AB             ; $00AB CNVCHR
0314+  00AB                             .ds      $00AB - $
0315+  00AB C3 24 13                    jp      cnvchr
0316+  00AE             
0317+  00AE             ; $00AE PINLIN
0318+  00AE                             .ds      $00AE - $
0319+  00AE C3 49 13                    jp      pinlin
0320+  00B1             
0321+  00B1             ; $00B1 INLIN
0322+  00B1                             .ds      $00B1 - $
0323+  00B1 C3 67 13                    jp      inlin
0324+  00B4             
0325+  00B4             ; $00B4 QINLIN
0326+  00B4                             .ds      $00B4 - $
0327+  00B4 C3 5E 13                    jp      qinlin
0328+  00B7             
0329+  00B7             ; $00B7 BREAKX
0330+  00B7                             .ds      $00B7 - $
0331+  00B7 C3 71 14                    jp      breakx
0332+  00BA             
0333+  00BA             ; $00BA ISCNTC
0334+  00BA                             .ds      $00BA - $
0335+  00BA C3 81 14                    jp      iscntc
0336+  00BD             
0337+  00BD             ; $00BD CKCNTC
0338+  00BD                             .ds      $00BD - $
0339+  00BD C3 90 14                    jp      ckcntc
0340+  00C0             
0341+  00C0             ; $00C0 BEEP
0342+  00C0                             .ds      $00C0 - $
0343+  00C0 C3 93 14                    jp      beep
0344+  00C3             
0345+  00C3             ; $00C3 CLS
0346+  00C3                             .ds      $00C3 - $
0347+  00C3 C3 AB 07                    jp      cls_z
0348+  00C6             
0349+  00C6             ; $00C6 POSIT
0350+  00C6                             .ds      $00C6 - $
0351+  00C6 C3 A0 14                    jp      posit
0352+  00C9             
0353+  00C9             ; $00C9 FNKSB
0354+  00C9                             .ds      $00C9 - $
0355+  00C9 C3 A4 14                    jp      fnksb
0356+  00CC             
0357+  00CC             ; $00CC ERAFNK
0358+  00CC                             .ds      $00CC - $
0359+  00CC C3 B2 14                    jp      erafnk
0360+  00CF             
0361+  00CF             ; $00CF DSPFNK
0362+  00CF                             .ds      $00CF - $
0363+  00CF C3 C1 14                    jp      dspfnk
0364+  00D2             
0365+  00D2             ; $00D2 TOTEXT
0366+  00D2                             .ds      $00D2 - $
0367+  00D2 C3 D0 14                    jp      totext
0368+  00D5             
0369+  00D5             ; $00D5 GTSTCK .. Get joystick infomation
0370+  00D5                             .ds      $00D5 - $
0371+  00D5 C3 A2 15                    jp      gtstck
0372+  00D8             
0373+  00D8             ; $00D8 GTTRIG .. Get trigger infomation
0374+  00D8                             .ds      $00D8 - $
0375+  00D8 C3 57 16                    jp      gttrig
0376+  00DB             
0377+  00DB             ; $00db GTPAD
0378+  00DB                             .ds      $00db - $
0379+  00DB C3 A2 16                    jp      gtpad
0380+  00DE             
0381+  00DE             ; $00DE GTPDL
0382+  00DE                             .ds      $00DE - $
0383+  00DE C3 B1 16                    jp      gtpdl
0384+  00E1             
0385+  00E1             ; $00E1 TAPION
0386+  00E1                             .ds      $00E1 - $
0387+  00E1 C3 E3 14                    jp      tapion
0388+  00E4             
0389+  00E4             ; $00E4 TAPIN
0390+  00E4                             .ds      $00E4 - $
0391+  00E4 C3 F3 14                    jp      tapin
0392+  00E7             
0393+  00E7             ; $00E7 TAPIOF
0394+  00E7                             .ds      $00E7 - $
0395+  00E7 C3 02 15                    jp      tapiof
0396+  00EA             
0397+  00EA             ; $00EA TAPOON
0398+  00EA                             .ds      $00EA - $
0399+  00EA C3 11 15                    jp      tapoon
0400+  00ED             
0401+  00ED             ; $00ED TAPOUT
0402+  00ED                             .ds      $00ED - $
0403+  00ED C3 21 15                    jp      tapout
0404+  00F0             
0405+  00F0             ; $00F0 TAPOOF
0406+  00F0                             .ds      $00F0 - $
0407+  00F0 C3 31 15                    jp      tapoof
0408+  00F3             
0409+  00F3             ; $00F3 STMOTR
0410+  00F3                             .ds      $00F3 - $
0411+  00F3 C3 40 15                    jp      stmotr
0412+  00F6             
0413+  00F6             ; $00F6 LFTQ
0414+  00F6                             .ds      $00F6 - $
0415+  00F6 C3 BF 16                    jp      lftq
0416+  00F9             
0417+  00F9             ; $00F9 PUTQ
0418+  00F9                             .ds      $00F9 - $
0419+  00F9 C3 CE 16                    jp      putq
0420+  00FC             
0421+  00FC             ; $00FC RIGHTC
0422+  00FC                             .ds      $00FC - $
0423+  00FC C3 3A 08                    jp      rightc
0424+  00FF             
0425+  00FF             ; $00FF LEFTC
0426+  00FF                             .ds      $00FF - $
0427+  00FF C3 49 08                    jp      leftc
0428+  0102             
0429+  0102             ; $0102 UPC
0430+  0102                             .ds      $0102 - $
0431+  0102 C3 57 08                    jp      upc
0432+  0105             
0433+  0105             ; $0105 TUPC
0434+  0105                             .ds      $0105 - $
0435+  0105 C3 63 08                    jp      tupc
0436+  0108             
0437+  0108             ; $0108 DOWNC
0438+  0108                             .ds      $0108 - $
0439+  0108 C3 70 08                    jp      downc
0440+  010B             
0441+  010B             ; $010B TDOWNC
0442+  010B                             .ds      $010B - $
0443+  010B C3 7E 08                    jp      tdownc
0444+  010E             
0445+  010E             ; $010E SCALXY
0446+  010E                             .ds      $010E - $
0447+  010E C3 8D 08                    jp      scalxy
0448+  0111             
0449+  0111             ; $0111 MAPXY
0450+  0111                             .ds      $0111 - $
0451+  0111 C3 9D 08                    jp      mapxy
0452+  0114             
0453+  0114             ; $0114 FETCHC
0454+  0114                             .ds      $0114 - $
0455+  0114 C3 D8 08                    jp      fetchc
0456+  0117             
0457+  0117             ; $0117 STOREC
0458+  0117                             .ds      $0117 - $
0459+  0117 C3 E6 08                    jp      storec
0460+  011A             
0461+  011A             ; $011A SETATR
0462+  011A                             .ds      $011A - $
0463+  011A C3 F5 08                    jp      setatr
0464+  011D             
0465+  011D             ; $011D READC
0466+  011D                             .ds      $011D - $
0467+  011D C3 04 09                    jp      readc
0468+  0120             
0469+  0120             ; $0120 SETC
0470+  0120                             .ds      $0120 - $
0471+  0120 C3 12 09                    jp      setc
0472+  0123             
0473+  0123             ; $0123 NSETCX
0474+  0123                             .ds      $0123 - $
0475+  0123 C3 1F 09                    jp      nsetcx
0476+  0126             
0477+  0126             ; $0126 GTASPC
0478+  0126                             .ds      $0126 - $
0479+  0126 C3 2E 09                    jp      gtaspc
0480+  0129             
0481+  0129             ; $0129 PNTINI
0482+  0129                             .ds      $0129 - $
0483+  0129 C3 3D 09                    jp      pntini
0484+  012C             
0485+  012C             ; $012C SCANR
0486+  012C                             .ds      $012C - $
0487+  012C C3 4C 09                    jp      scanr
0488+  012F             
0489+  012F             ; $012F SCANL
0490+  012F                             .ds      $012F - $
0491+  012F C3 5A 09                    jp      scanl
0492+  0132             
0493+  0132             ; $0132 CHGCAP
0494+  0132                             .ds      $0132 - $
0495+  0132 C3 FC 16                    jp      chgcap
0496+  0135             
0497+  0135             ; $0135 CHGSND
0498+  0135                             .ds      $0135 - $
0499+  0135 C3 80 15                    jp      chgsnd
0500+  0138             
0501+  0138             ; $0138 RSLREG  Read infomation of primary slot
0502+  0138                             .ds      $0138 - $
0503+  0138 C3 89 15                    jp      rslreg
0504+  013B             
0505+  013B             ; $013B WSLREG  Write infomation to primary slot
0506+  013B                             .ds      $013B - $
0507+  013B C3 8C 15                    jp      wslreg
0508+  013E             
0509+  013E             ; $013E RDVDP   Read VDP status
0510+  013E                             .ds      $013E - $
0511+  013E C3 8F 15                    jp      rdvdp
0512+  0141             
0513+  0141             ; $0141 SNSMAT  Get key matrix
0514+  0141                             .ds      $0141 - $
0515+  0141 C3 92 15                    jp      snsmat
0516+  0144             
0517+  0144             ; $0144 PHYDIO
0518+  0144                             .ds      $0144 - $
0519+  0144 C3 95 15                    jp      phydio
0520+  0147             
0521+  0147             ; $0147 FORMAT
0522+  0147                             .ds      $0147 - $
0523+  0147 C3 99 15                    jp      format
0524+  014A             
0525+  014A             ; $014A ISFLIO
0526+  014A                             .ds      $014A - $
0527+  014A C3 9D 15                    jp      isflio
0528+  014D             
0529+  014D             ; $014D OUTDLP
0530+  014D                             .ds      $014D - $
0531+  014D C3 FD 16                    jp      outdlp
0532+  0150             
0533+  0150             ; $0150 GETVCP
0534+  0150                             .ds      $0150 - $
0535+  0150 C3 0C 17                    jp      getvcp
0536+  0153             
0537+  0153             ; $0153 GETVC2
0538+  0153                             .ds      $0153 - $
0539+  0153 C3 10 17                    jp      getvc2
0540+  0156             
0541+  0156             ; $0156 KILBUF  Clear keyboard buffer
0542+  0156                             .ds      $0156 - $
0543+  0156 C3 26 17                    jp      kilbuf
0544+  0159             
0545+  0159             ; $0159 CALBAS  Call BASIC interpreter
0546+  0159                             .ds      $0159 - $
0547+  0159 C3 CF 17                    jp      calbas
0548+  015C             
0549+  015C             
0550+  015C             ; fake EXTROM call, fixes Nemesis 3 reset bug
0551+  015C                             .ds      $015f - $
0552+  015F C9                          ret
0553+  0160             
0554+  0160                             .ds      $0200 - $
0555+  0200             
0556+  0200                             .include "util.asm"
0001++ 0200             ; $Id: util.asm 525 2008-12-22 22:16:42Z mthuurne $
0002++ 0200             ; C-BIOS utility routines
0003++ 0200             ;
0004++ 0200             ; Copyright (c) 2004 Maarten ter Huurne.  All rights reserved.
0005++ 0200             ;
0006++ 0200             ; Redistribution and use in source and binary forms, with or without
0007++ 0200             ; modification, are permitted provided that the following conditions
0008++ 0200             ; are met:
0009++ 0200             ; 1. Redistributions of source code must retain the above copyright
0010++ 0200             ;    notice, this list of conditions and the following disclaimer.
0011++ 0200             ; 2. Redistributions in binary form must reproduce the above copyright
0012++ 0200             ;    notice, this list of conditions and the following disclaimer in the
0013++ 0200             ;    documentation and/or other materials provided with the distribution.
0014++ 0200             ;
0015++ 0200             ; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
0016++ 0200             ; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
0017++ 0200             ; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
0018++ 0200             ; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
0019++ 0200             ; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
0020++ 0200             ; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0021++ 0200             ; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0022++ 0200             ; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0023++ 0200             ; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
0024++ 0200             ; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0025++ 0200             ;
0026++ 0200             
0027++ 0200             ;----------------------------------
0028++ 0200             ; Generic routine that implements a jump table.
0029++ 0200             ; Input:   HL = address of jump table
0030++ 0200             ;          A  = index in table
0031++ 0200             ; Changes: F, HL, BC (these are changed *before* jumping)
0032++ 0200             jump_table:
0033++ 0200 4F                          ld      c,a
0034++ 0201 06 00                       ld      b,0
0035++ 0203 09                          add     hl,bc
0036++ 0204 09                          add     hl,bc
0037++ 0205 C3 11 02                    jp      table_jump
0038++ 0208             
0039++ 0208             ;----------------------------------
0040++ 0208             ; Generic routine that implements a search & jump table
0041++ 0208             ; Entries in the table consist of (character, jump address) pairs.
0042++ 0208             ; If the entry is not found, the routine will just RETurn.
0043++ 0208             ;
0044++ 0208             ; Input:   HL = address of search table
0045++ 0208             ;          A  = item to search for
0046++ 0208             ;          B  = number of entries in the table
0047++ 0208             ; Changes: F, BC, HL
0048++ 0208             search_table:
0049++ 0208 BE                          cp      (hl)
0050++ 0209 23                          inc     hl
0051++ 020A 28 05                       jr      z,table_jump
0052++ 020C 23                          inc     hl
0053++ 020D 23                          inc     hl
0054++ 020E 10 F8                       djnz    search_table
0055++ 0210 C9                          ret
0056++ 0211             table_jump:
0057++ 0211 4E                          ld      c,(hl)
0058++ 0212 23                          inc     hl
0059++ 0213 66                          ld      h,(hl)
0060++ 0214 69                          ld      l,c
0061++ 0215 E9                          jp      (hl)
0062++ 0216             
0063++ 0216             ; vim:ts=8:expandtab:filetype=z8a:syntax=z8a:
0557+  0216                             .include "video.asm"
0001++ 0216             ; $Id: video.asm 563 2009-12-20 20:26:40Z bifimsx $
0002++ 0216             ; C-BIOS video routines
0003++ 0216             ;
0004++ 0216             ; Copyright (c) 2002-2005 BouKiCHi.  All rights reserved.
0005++ 0216             ; Copyright (c) 2003 Reikan.  All rights reserved.
0006++ 0216             ; Copyright (c) 2004-2006 Maarten ter Huurne.  All rights reserved.
0007++ 0216             ; Copyright (c) 2004-2005 Albert Beevendorp.  All rights reserved.
0008++ 0216             ; Copyright (c) 2004 Manuel Bilderbeek.  All rights reserved.
0009++ 0216             ; Copyright (c) 2004 Joost Yervante Damad.  All rights reserved.
0010++ 0216             ; Copyright (c) 2004-2005 Jussi Pitkänen.  All rights reserved.
0011++ 0216             ;
0012++ 0216             ; Redistribution and use in source and binary forms, with or without
0013++ 0216             ; modification, are permitted provided that the following conditions
0014++ 0216             ; are met:
0015++ 0216             ; 1. Redistributions of source code must retain the above copyright
0016++ 0216             ;    notice, this list of conditions and the following disclaimer.
0017++ 0216             ; 2. Redistributions in binary form must reproduce the above copyright
0018++ 0216             ;    notice, this list of conditions and the following disclaimer in the
0019++ 0216             ;    documentation and/or other materials provided with the distribution.
0020++ 0216             ;
0021++ 0216             ; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
0022++ 0216             ; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
0023++ 0216             ; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
0024++ 0216             ; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
0025++ 0216             ; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
0026++ 0216             ; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0027++ 0216             ; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0028++ 0216             ; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0029++ 0216             ; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
0030++ 0216             ; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0031++ 0216             ;
0032++ 0216             
0033++ 0216             ;--------------------------------
0034++ 0216             ; $0041 DISSCR
0035++ 0216             ; Function : inhibits the screen display
0036++ 0216             ; Registers: AF, BC
0037++ 0216             disscr:
0038++ 0216 3A E0 F3                    ld      a,(RG1SAV)
0039++ 0219 E6 BF                       and     $BF
0040++ 021B 47                          ld      b,a
0041++ 021C 0E 01                       ld      c,1
0042++ 021E CD 2E 02                    call    wrtvdp
0043++ 0221 C9                          ret
0044++ 0222             
0045++ 0222             ;--------------------------------
0046++ 0222             ; $0044 ENASCR
0047++ 0222             ; Function : displays the screen
0048++ 0222             ; Registers: AF, BC
0049++ 0222             enascr:
0050++ 0222 3A E0 F3                    ld      a,(RG1SAV)
0051++ 0225 F6 40                       or      $40
0052++ 0227 47                          ld      b,a
0053++ 0228 0E 01                       ld      c,1
0054++ 022A CD 2E 02                    call    wrtvdp
0055++ 022D C9                          ret
0056++ 022E             
0057++ 022E             ;--------------------------------
0058++ 022E             ; 0047$ WRTVDP
0059++ 022E             ; Function : write data in the VDP-register
0060++ 022E             ; Input    : B  - data to write
0061++ 022E             ;            C  - number of the register
0062++ 022E             ; Output   : RG0SAV(F3DF)-RG7SAV(F3E6)
0063++ 022E             ; Registers: AF, BC
0064++ 022E             wrtvdp:
0065++ 022E F3                          di
0066++ 022F CB B9                       res     7,c             ; fixes High Way Star
0067++ 0231 78                          ld      a,b
0068++ 0232 D3 99                       out     (VDP_ADDR),a
0069++ 0234 79                          ld      a,c
0070++ 0235 F6 80                       or      $80
0071++ 0237 D3 99                       out     (VDP_ADDR),a
0072++ 0239 FB                          ei
0073++ 023A             
0074++ 023A E5                          push    hl
0075++ 023B 21 DF F3                    ld      hl,RG0SAV
0076++ 023E             wrtvdp_sav:
0077++ 023E 78                          ld      a,b
0078++ 023F 06 00                       ld      b,0
0079++ 0241 09                          add     hl,bc
0080++ 0242 77                          ld      (hl),a
0081++ 0243             wrtvdp_nosav:
0082++ 0243 E1                          pop     hl
0083++ 0244 C9                          ret
0084++ 0245             
0085++ 0245             ;--------------------------------
0086++ 0245             ; $004A RDVRM
0087++ 0245             ; Function : Reads the content of VRAM
0088++ 0245             ; Input    : HL - address read
0089++ 0245             ; Output   : A  - value which was read
0090++ 0245             ; Registers: AF
0091++ 0245             rdvrm:
0092++ 0245 CD 53 02                    call    setrd
0093++ 0248 DB 98                       in      a,(VDP_DATA)
0094++ 024A C9                          ret
0095++ 024B             
0096++ 024B             
0097++ 024B             ;--------------------------------
0098++ 024B             ; $004D WRTVRM
0099++ 024B             ; Function : Writes data in VRAM
0100++ 024B             ; Input    : HL - address write
0101++ 024B             ;            A  - value write
0102++ 024B             ; Registers: AF
0103++ 024B             wrtvrm:
0104++ 024B F5                          push    af
0105++ 024C CD 5E 02                    call    setwrt
0106++ 024F F1                          pop     af
0107++ 0250 D3 98                       out     (VDP_DATA),a
0108++ 0252 C9                          ret
0109++ 0253             
0110++ 0253             ;--------------------------------
0111++ 0253             ; $0050 SETRD
0112++ 0253             ; Function : Enable VDP to read
0113++ 0253             ; Input    : HL - for VRAM-address
0114++ 0253             ; Registers: AF
0115++ 0253             setrd:
0116++ 0253 F3                          di
0117++ 0254             
0118++ 0254 7D                          ld      a,l
0119++ 0255 D3 99                       out     (VDP_ADDR),a
0120++ 0257 7C                          ld      a,h
0121++ 0258 E6 3F                       and     $3F
0122++ 025A D3 99                       out     (VDP_ADDR),a
0123++ 025C FB                          ei
0124++ 025D C9                          ret
0125++ 025E             
0126++ 025E             ;--------------------------------
0127++ 025E             ; $0053 SETWRT
0128++ 025E             ; Function : Enable VDP to write
0129++ 025E             ; Input    : HL - Address
0130++ 025E             ; Registers: AF
0131++ 025E             setwrt:
0132++ 025E F3                          di
0133++ 025F             
0134++ 025F 7D                          ld      a,l
0135++ 0260 D3 99                       out     (VDP_ADDR),a
0136++ 0262 7C                          ld      a,h
0137++ 0263 E6 3F                       and     $3F
0138++ 0265 F6 40                       or      $40
0139++ 0267 D3 99                       out     (VDP_ADDR),a
0140++ 0269 FB                          ei
0141++ 026A C9                          ret
0142++ 026B             
0143++ 026B             ;--------------------------------
0144++ 026B             ; $0056 FILVRM
0145++ 026B             ; Function : fill VRAM with value
0146++ 026B             ; Input    : A  - data byte
0147++ 026B             ;            BC - length of the area to be written
0148++ 026B             ;            HL - start address:
0149++ 026B             ;                 * SCREEN 0..4 -> 14-bit address
0150++ 026B             ;                 * SCREEN 5+ -> 17-bit address (uses ACPAGE)
0151++ 026B             ;                 Using 14-bit address for SCREEN4 doesn't really make sense,
0152++ 026B             ;                 but that's what we have to follow to be compatible.
0153++ 026B             ; Registers: AF, BC
0154++ 026B             filvrm:
0155++ 026B F5                          push    af
0156++ 026C CD 5E 02                    call    setwrt
0157++ 026F 0B                          dec     bc
0158++ 0270 0C                          inc     c
0159++ 0271 78                          ld      a,b
0160++ 0272 41                          ld      b,c
0161++ 0273 4F                          ld      c,a
0162++ 0274 0C                          inc     c
0163++ 0275 F1                          pop     af
0164++ 0276                             ; Note: Interrupts should be enabled here.
0165++ 0276                             ;       Penguin Adventure can hang on boot if the interrupt
0166++ 0276                             ;       comes just after our RET, which is certain if the
0167++ 0276                             ;       memory block written is large enough.
0168++ 0276             filvrm_lp:
0169++ 0276 D3 98                       out     (VDP_DATA),a
0170++ 0278 00                          NOP				;
0171++ 0279 00                          NOP				;
0172++ 027A 10 FA                       djnz    filvrm_lp
0173++ 027C 0D                          dec     c
0174++ 027D 20 F7                       jr      nz,filvrm_lp
0175++ 027F C9                          ret
0176++ 0280             
0177++ 0280             ;--------------------------------
0178++ 0280             ; $0059 LDIRMV
0179++ 0280             ; Function : Block transfer from VRAM to memory
0180++ 0280             ; Input    : BC - blocklength
0181++ 0280             ;            DE - Start address of memory
0182++ 0280             ;            HL - Start address of VRAM
0183++ 0280             ; Registers: AF BC DE
0184++ 0280             ; Note     : the function doesn't destroy HL
0185++ 0280             ; Note     : the routine doesn't change IM
0186++ 0280             ldirmv:
0187++ 0280 CD 53 02                    call    setrd
0188++ 0283 E5                          push    hl
0189++ 0284                             
0190++ 0284             ldirmv_lp:
0191++ 0284 DB 98       		IN 	A,(VDP_DATA)
0192++ 0286 00          		NOP
0193++ 0287 00          		NOP
0194++ 0288 12          		LD	(DE),A
0195++ 0289 13          		INC	DE
0196++ 028A 0B          		DEC	BC
0197++ 028B 78          		LD	A,B
0198++ 028C FE 00       		CP	0
0199++ 028E 20 F4                       jr      nz,ldirmv_lp
0200++ 0290 79          		LD	A,C
0201++ 0291 FE 00       		CP	0
0202++ 0293 20 EF                       jr      nz,ldirmv_lp                
0203++ 0295 E1                          pop     hl
0204++ 0296 C9                          ret
0205++ 0297             
0206++ 0297             ;--------------------------------
0207++ 0297             ; $005C LDIRVM
0208++ 0297             ; Function : Block transfer from memory to VRAM
0209++ 0297             ; Input    : BC - blocklength
0210++ 0297             ;            DE - Start address of VRAM
0211++ 0297             ;            HL - Start address of memory
0212++ 0297             ; Note     : the routine doesn't change IM
0213++ 0297             ; Registers: All
0214++ 0297             ldirvm:
0215++ 0297 EB                          ex      de,hl
0216++ 0298 CD 5E 02                    call    setwrt
0217++ 029B EB                          ex      de,hl
0218++ 029C             ldirvm_lp:
0219++ 029C 7E          		LD	A,(HL)
0220++ 029D D3 98       		OUT 	(VDP_DATA),A
0221++ 029F 00          		NOP
0222++ 02A0 00          		NOP
0223++ 02A1 23          		INC	HL
0224++ 02A2 0B          		DEC	BC
0225++ 02A3 78          		LD	A,B
0226++ 02A4 FE 00       		CP	0
0227++ 02A6 20 F4                       jr      nz,ldirvm_lp
0228++ 02A8 79          		LD	A,C
0229++ 02A9 FE 00       		CP	0
0230++ 02AB 20 EF                       jr      nz,ldirvm_lp                
0231++ 02AD                             ; Note: Without this, Quinpl shows glitches.
0232++ 02AD                             ; TODO: Investigate why.
0233++ 02AD EB                          ex      de,hl
0234++ 02AE C9                          ret
0235++ 02AF             
0236++ 02AF             ;----------------------------------
0237++ 02AF             ; $005F CHGMOD  Changes screen mode
0238++ 02AF             ; Function : Switches to given screenmode
0239++ 02AF             ; Input    : A  - screen mode
0240++ 02AF             ; Registers: All
0241++ 02AF             chgmod:
0242++ 02AF FE 04                       cp      4
0243++ 02B1 D0                          ret     nc
0244++ 02B2                             ; Redirect to initialisation routine.
0245++ 02B2 21 B8 02                    ld      hl,chgmod_tbl
0246++ 02B5 C3 00 02                    jp      jump_table
0247++ 02B8             chgmod_tbl:
0248++ 02B8 7F 03                       .dw      initxt          ; SCREEN0
0249++ 02BA BF 03                       .dw      init32          ; SCREEN1
0250++ 02BC 02 04                       .dw      inigrp          ; SCREEN2
0251++ 02BE 40 04                       .dw      inimlt          ; SCREEN3
0252++ 02C0             ; TODO: Now that we rewrite most regs at the end of CHGMOD,
0253++ 02C0             ;       the ini* routines can just update RG?SAV instead of calling wrtvdp.
0254++ 02C0             chgmod_finish:
0255++ 02C0                             ; Generic state resets.
0256++ 02C0                             ; Write new values from system RAM to the VDP.
0257++ 02C0 F3                          di
0258++ 02C1                             ; Write R#0 - R#7.
0259++ 02C1 21 DF F3                    ld      hl,RG0SAV
0260++ 02C4 01 99 08                    ld      bc,8 * $100 + VDP_ADDR
0261++ 02C7 16 80                       ld      d,$80
0262++ 02C9             chgmod_finish_lp:
0263++ 02C9 ED A3                       outi
0264++ 02CB 78                          ld      a,b
0265++ 02CC ED 51                       out     (c),d
0266++ 02CE 14                          inc     d
0267++ 02CF B7                          or      a
0268++ 02D0 20 F7                       jr      nz,chgmod_finish_lp
0269++ 02D2             
0270++ 02D2 FB                          ei
0271++ 02D3 C3 22 02                    jp      enascr
0272++ 02D6             
0273++ 02D6             ;--------------------------------
0274++ 02D6             ; $0062 CHGCLR
0275++ 02D6             ; Function : Changes the screencolors
0276++ 02D6             ; Input    : Foregroundcolor in FORCLR
0277++ 02D6             ;            Backgroundcolor in BAKCLR
0278++ 02D6             ;            Bordercolor in BDRCLR
0279++ 02D6             ; Registers: All
0280++ 02D6             chgclr:
0281++ 02D6 3A AF FC                    ld      a,(SCRMOD)
0282++ 02D9 FE 08                       cp      8
0283++ 02DB 28 3A                       jr      z,chgclr_sc8
0284++ 02DD 3D                          dec     a
0285++ 02DE F5                          push    af
0286++ 02DF 3A E9 F3                    ld      a,(FORCLR)
0287++ 02E2 07                          rlca
0288++ 02E3 07                          rlca
0289++ 02E4 07                          rlca
0290++ 02E5 07                          rlca
0291++ 02E6 E6 F0                       and     $F0
0292++ 02E8 6F                          ld      l,a
0293++ 02E9 3A EB F3                    ld      a,(BDRCLR)
0294++ 02EC B5                          or      l
0295++ 02ED             
0296++ 02ED 47                          ld      b,a
0297++ 02EE 0E 07                       ld      c,7
0298++ 02F0 CD 2E 02                    call    wrtvdp
0299++ 02F3 F1                          pop     af
0300++ 02F4 C0                          ret     nz
0301++ 02F5             
0302++ 02F5                             ; SCREEN1
0303++ 02F5 3A E9 F3                    ld      a,(FORCLR)
0304++ 02F8 07                          rlca
0305++ 02F9 07                          rlca
0306++ 02FA 07                          rlca
0307++ 02FB 07                          rlca
0308++ 02FC E6 F0                       and     $F0
0309++ 02FE 21 EA F3                    ld      hl,BAKCLR
0310++ 0301 B6                          or      (hl)
0311++ 0302 2A BF F3                    ld      hl,(T32COL)
0312++ 0305 01 20 00                    ld      bc,$0020
0313++ 0308 F5                          push    af
0314++ 0309 CD 5E 02                    call    setwrt
0315++ 030C             cclr_lp:
0316++ 030C F1                          pop     af
0317++ 030D D3 98                       out     (VDP_DATA),a
0318++ 030F F5                          push    af
0319++ 0310 0B                          dec     bc
0320++ 0311 78                          ld      a,b
0321++ 0312 B1                          or      c
0322++ 0313 20 F7                       jr      nz,cclr_lp
0323++ 0315 F1                          pop     af
0324++ 0316 C9                          ret
0325++ 0317             
0326++ 0317             chgclr_sc8:
0327++ 0317                             ; SCREEN8
0328++ 0317 3A EB F3                    ld      a,(BDRCLR)
0329++ 031A 47                          ld      b,a
0330++ 031B 0E 07                       ld      c,7
0331++ 031D C3 2E 02                    jp      wrtvdp
0332++ 0320             
0333++ 0320             ;--------------------------------
0334++ 0320             ; $0069 CLRSPR
0335++ 0320             ; Function : Initialises all sprites
0336++ 0320             ; Input    : SCRMOD
0337++ 0320             ; Registers: All
0338++ 0320             clrspr:
0339++ 0320             ; Check screen mode.
0340++ 0320 3A AF FC                    ld      a,(SCRMOD)
0341++ 0323 B7                          or      a
0342++ 0324 C8                          ret     z               ; no sprites in SCREEN0
0343++ 0325             
0344++ 0325             ; Clear sprite attribute table.
0345++ 0325 CD 4A 03                    call    clrspr_attr
0346++ 0328             
0347++ 0328             ; Clear sprite colour table.
0348++ 0328 3A AF FC                    ld      a,(SCRMOD)
0349++ 032B FE 04                       cp      4               ; sprite mode 1?
0350++ 032D 38 10                       jr      c,clrspr_col_skip
0351++ 032F 2A 28 F9                    ld      hl,(ATRBAS)
0352++ 0332 25                          dec     h
0353++ 0333 25                          dec     h               ; HL = (ATRBAS) - $200
0354++ 0334 01 00 02                    ld      bc,32 * 16
0355++ 0337 3A E9 F3                    ld      a,(FORCLR)
0356++ 033A E6 0F                       and     $0F
0357++ 033C CD CD 06                    call    bigfil
0358++ 033F             clrspr_col_skip:
0359++ 033F             
0360++ 033F             ; Clear sprite pattern generator table.
0361++ 033F 2A 26 F9                    ld      hl,(PATBAS)
0362++ 0342 01 00 08                    ld      bc,256 * 8
0363++ 0345 AF                          xor     a
0364++ 0346 CD 6B 02                    call    filvrm
0365++ 0349 C9                          ret
0366++ 034A             
0367++ 034A             ;--------------------------------
0368++ 034A             ; Clear sprite attribute table.
0369++ 034A             clrspr_attr:
0370++ 034A 3A AF FC                    ld      a,(SCRMOD)
0371++ 034D FE 04                       cp      4
0372++ 034F 38 04                       jr      c,clrspr_attr_spritemode1
0373++ 0351             
0374++ 0351             ; Note: This label is called directly by external routines.
0375++ 0351             clrspr_attr_spritemode2:
0376++ 0351 1E D9                       ld      e,217           ; Y coordinate
0377++ 0353 18 02                       jr      clrspr_attr_spritemode_start
0378++ 0355             
0379++ 0355             ; Note: This label is called directly by external routines.
0380++ 0355             clrspr_attr_spritemode1:
0381++ 0355 1E D1                       ld      e,209           ; Y coordinate
0382++ 0357             
0383++ 0357             clrspr_attr_spritemode_start:
0384++ 0357 2A 28 F9                    ld      hl,(ATRBAS)
0385++ 035A CD 5E 02                    call    setwrt
0386++ 035D 3A E9 F3                    ld      a,(FORCLR)
0387++ 0360 57                          ld      d,a
0388++ 0361 01 00 20                    ld      bc,$2000        ; B = 32 = counter, C = pattern index
0389++ 0364 F3                          di
0390++ 0365             clrspr_attr_lp:
0391++ 0365 7B                          ld      a,e
0392++ 0366 D3 98                       out     (VDP_DATA),a    ; Y coordinate
0393++ 0368 3E 00                       ld      a,0
0394++ 036A D3 98                       out     (VDP_DATA),a    ; X coordinate
0395++ 036C 79                          ld      a,c
0396++ 036D D3 98                       out     (VDP_DATA),a    ; pattern number
0397++ 036F 0C                          inc     c
0398++ 0370 CD 89 05                    call    gspsiz
0399++ 0373 30 03                       jr      nc,clrspr_attr_8
0400++ 0375 0C                          inc     c
0401++ 0376 0C                          inc     c
0402++ 0377 0C                          inc     c
0403++ 0378             clrspr_attr_8:
0404++ 0378 7A                          ld      a,d
0405++ 0379 D3 98                       out     (VDP_DATA),a    ; color
0406++ 037B 10 E8                       djnz    clrspr_attr_lp
0407++ 037D FB                          ei
0408++ 037E C9                          ret
0409++ 037F             
0410++ 037F             ;--------------------------------
0411++ 037F             ; $006C INITXT
0412++ 037F             ; Function : Switch to SCREEN 0
0413++ 037F             ; Input    : TXTNAM, TXTCGP
0414++ 037F             ; Output   : NAMBAS, CGPBAS, LINLEN, SCRMOD, OLDSCR
0415++ 037F             ; Registers: All
0416++ 037F             initxt:
0417++ 037F                             ; Disable video output.
0418++ 037F CD 16 02                    call    disscr
0419++ 0382             
0420++ 0382                             ; New screen mode.
0421++ 0382 3E 00                       ld      a,$00
0422++ 0384 32 AF FC                    ld      (SCRMOD),a
0423++ 0387 32 B0 FC                    ld      (OLDSCR),a
0424++ 038A             
0425++ 038A             
0426++ 038A                             ; Line length.
0427++ 038A 3A AE F3                    ld      a,(LINL40)
0428++ 038D 32 B0 F3                    ld      (LINLEN),a
0429++ 0390             
0430++ 0390                             ; Cursor position: top-left.
0431++ 0390 3E 01                       ld      a,1
0432++ 0392 32 DC F3                    ld      (CSRY),a
0433++ 0395 32 DD F3                    ld      (CSRX),a
0434++ 0398             
0435++ 0398                             ; Table base addresses.
0436++ 0398 2A B3 F3                    ld      hl,(TXTNAM)     ; name table
0437++ 039B 22 22 F9                    ld      (NAMBAS),hl
0438++ 039E 2A B7 F3                    ld      hl,(TXTCGP)     ; pattern table
0439++ 03A1 22 24 F9                    ld      (CGPBAS),hl
0440++ 03A4 2A B9 F3                    ld      hl,(TXTATR)     ; sprite attribute table (unused)
0441++ 03A7 22 28 F9                    ld      (ATRBAS),hl
0442++ 03AA 2A BB F3                    ld      hl,(TXTPAT)     ; sprite pattern table (unused)
0443++ 03AD 22 26 F9                    ld      (PATBAS),hl
0444++ 03B0             
0445++ 03B0                             ; Update VDP regs and VRAM.
0446++ 03B0 CD D6 02                    call    chgclr
0447++ 03B3 CD 8C 04                    call    settxt
0448++ 03B6                     .IF COMPILE_FONT != NO
0449++ 03B6 CD 9E 07                    call    init_font
0450++ 03B9                     .ENDIF
0451++ 03B9 CD C3 07                    call    cls_screen0
0452++ 03BC C3 C0 02                    jp      chgmod_finish
0453++ 03BF             
0454++ 03BF             ;--------------------------------
0455++ 03BF             ; $006F INIT32
0456++ 03BF             ; Function : Switches to SCREEN 1 (text screen with 32*24 characters)
0457++ 03BF             ; Input    : T32NAM, T32CGP, T32COL, T32ATR, T32PAT
0458++ 03BF             ; Output   : NAMBAS, CGPBAS, LINLEN, SCRMOD, OLDSCR
0459++ 03BF             ; Registers: All
0460++ 03BF             init32:
0461++ 03BF                             ; Disable video output.
0462++ 03BF CD 16 02                    call    disscr
0463++ 03C2             
0464++ 03C2 3E 01                       ld      a,$01           ; SCREEN1
0465++ 03C4 32 AF FC                    ld      (SCRMOD),a
0466++ 03C7 32 B0 FC                    ld      (OLDSCR),a
0467++ 03CA             
0468++ 03CA 3E 01                       ld      a,1
0469++ 03CC 32 DC F3                    ld      (CSRY),a
0470++ 03CF 32 DD F3                    ld      (CSRX),a
0471++ 03D2             
0472++ 03D2 CD D6 02                    call    chgclr
0473++ 03D5             
0474++ 03D5 2A BD F3                    ld      hl,(T32NAM)
0475++ 03D8 22 22 F9                    ld      (NAMBAS),hl
0476++ 03DB 2A C1 F3                    ld      hl,(T32CGP)
0477++ 03DE 22 24 F9                    ld      (CGPBAS),hl
0478++ 03E1 2A C5 F3                    ld      hl,(T32PAT)
0479++ 03E4 22 26 F9                    ld      (PATBAS),hl
0480++ 03E7 2A C3 F3                    ld      hl,(T32ATR)
0481++ 03EA 22 28 F9                    ld      (ATRBAS),hl
0482++ 03ED             
0483++ 03ED                     .IF COMPILE_FONT != NO
0484++ 03ED CD 9E 07                    call    init_font
0485++ 03F0                     .ENDIF
0486++ 03F0             
0487++ 03F0 3A AF F3                    ld      a,(LINL32)
0488++ 03F3 32 B0 F3                    ld      (LINLEN),a
0489++ 03F6             
0490++ 03F6 CD B4 04                    call    sett32
0491++ 03F9 CD 55 03                    call    clrspr_attr_spritemode1
0492++ 03FC CD D2 07                    call    cls_screen1
0493++ 03FF C3 C0 02                    jp      chgmod_finish
0494++ 0402             
0495++ 0402             ;--------------------------------
0496++ 0402             ; $0072 INIGRP
0497++ 0402             ; Function : Switches to SCREEN 2 (high resolution screen with 256*192 pixels)
0498++ 0402             ; Input    : GRPNAM, GRPCGP, GRPCOL, GRPATR, GRPPAT
0499++ 0402             ; Output   : NAMBAS-ATRBAS, SCRMOD
0500++ 0402             ; Registers: All
0501++ 0402             inigrp:
0502++ 0402                             ; Disable video output.
0503++ 0402 CD 16 02                    call    disscr
0504++ 0405             
0505++ 0405 3E 02                       ld      a,$02
0506++ 0407 32 AF FC                    ld      (SCRMOD),a
0507++ 040A             
0508++ 040A CD D6 02                    call    chgclr
0509++ 040D             
0510++ 040D 2A C7 F3                    ld      hl,(GRPNAM)
0511++ 0410 22 22 F9                    ld      (NAMBAS),hl
0512++ 0413 CD 5E 02                    call    setwrt
0513++ 0416 06 03                       ld      b,3
0514++ 0418 AF                          xor     a
0515++ 0419 F3                          di
0516++ 041A             inigrp_lp:
0517++ 041A D3 98                       out     (VDP_DATA),a
0518++ 041C 3C                          inc     a
0519++ 041D 20 FB                       jr      nz,inigrp_lp
0520++ 041F 10 F9                       djnz    inigrp_lp
0521++ 0421 FB                          ei
0522++ 0422             
0523++ 0422 2A CB F3                    ld      hl,(GRPCGP)
0524++ 0425 22 24 F9                    ld      (CGPBAS),hl
0525++ 0428             
0526++ 0428 2A CD F3                    ld      hl,(GRPATR)
0527++ 042B 22 28 F9                    ld      (ATRBAS),hl
0528++ 042E             
0529++ 042E 2A CF F3                    ld      hl,(GRPPAT)
0530++ 0431 22 26 F9                    ld      (PATBAS),hl
0531++ 0434             
0532++ 0434 CD E3 04                    call    setgrp
0533++ 0437 CD 55 03                    call    clrspr_attr_spritemode1
0534++ 043A CD EE 07                    call    cls_screen2
0535++ 043D C3 C0 02                    jp      chgmod_finish
0536++ 0440             
0537++ 0440             ;------------------------------
0538++ 0440             ; $0075 INIMLT
0539++ 0440             ; Function : Switches to SCREEN 3 (multi-color screen 64*48 pixels)
0540++ 0440             ; Input    : MLTNAM, MLTCGP, MLTCOL, MLTATR, MLTPAT
0541++ 0440             ; Output   : NAMBAS-ATRBAS, SCRMOD
0542++ 0440             ; Registers: All
0543++ 0440             inimlt:
0544++ 0440                             ; Disable video output.
0545++ 0440 CD 16 02                    call    disscr
0546++ 0443             
0547++ 0443 3E 03                       ld      a,$03
0548++ 0445 32 AF FC                    ld      (SCRMOD),a
0549++ 0448             
0550++ 0448 CD D6 02                    call    chgclr
0551++ 044B             
0552++ 044B 2A D1 F3                    ld      hl,(MLTNAM)
0553++ 044E 22 22 F9                    ld      (NAMBAS),hl
0554++ 0451 CD 5E 02                    call    setwrt
0555++ 0454 AF                          xor     a
0556++ 0455 0E 06                       ld      c,6
0557++ 0457 F3                          di
0558++ 0458             inimlt_loop1:
0559++ 0458 F5                          push    af
0560++ 0459 1E 04                       ld      e,4
0561++ 045B             inimlt_loop2:
0562++ 045B F5                          push    af
0563++ 045C 06 20                       ld      b,32
0564++ 045E             inimlt_loop3:
0565++ 045E D3 98                       out     (VDP_DATA),a
0566++ 0460 3C                          inc     a
0567++ 0461 10 FB                       djnz    inimlt_loop3
0568++ 0463 F1                          pop     af
0569++ 0464 1D                          dec     e
0570++ 0465 20 F4                       jr      nz,inimlt_loop2
0571++ 0467 F1                          pop     af
0572++ 0468 C6 20                       add     a,32
0573++ 046A 0D                          dec     c
0574++ 046B 20 EB                       jr      nz,inimlt_loop1
0575++ 046D FB                          ei
0576++ 046E             
0577++ 046E 2A D5 F3                    ld      hl,(MLTCGP)
0578++ 0471 22 24 F9                    ld      (CGPBAS),hl
0579++ 0474 2A D7 F3                    ld      hl,(MLTATR)
0580++ 0477 22 28 F9                    ld      (ATRBAS),hl
0581++ 047A 2A D9 F3                    ld      hl,(MLTPAT)
0582++ 047D 22 26 F9                    ld      (PATBAS),hl
0583++ 0480             
0584++ 0480 CD 16 05                    call    setmlt
0585++ 0483 CD 55 03                    call    clrspr_attr_spritemode1
0586++ 0486 CD 04 08                    call    cls_screen3
0587++ 0489 C3 C0 02                    jp      chgmod_finish
0588++ 048C             
0589++ 048C             
0590++ 048C             ;------------------------------
0591++ 048C             ; $0078 SETTXT
0592++ 048C             ; Function : Switches to VDP in SCREEN 0 mode
0593++ 048C             ; Input    : TXTNAM, TXTCGP
0594++ 048C             ; Registers: All
0595++ 048C             settxt:
0596++ 048C             
0597++ 048C 3A DF F3                    ld      a,(RG0SAV)
0598++ 048F E6 F1                       and     $F1             ; MASK 11110001
0599++ 0491 47                          ld      b,a
0600++ 0492 0E 00                       ld      c,0
0601++ 0494 CD 2E 02                    call    wrtvdp          ; write VDP R#0
0602++ 0497             
0603++ 0497 3A E0 F3                    ld      a,(RG1SAV)
0604++ 049A E6 E7                       and     $E7             ; MASK 11100111
0605++ 049C F6 10                       or      $10
0606++ 049E 47                          ld      b,a
0607++ 049F 0C                          inc     c
0608++ 04A0 CD 2E 02                    call    wrtvdp          ; write VDP R#1
0609++ 04A3             
0610++ 04A3                             ; Set the VDP base address registers. This works because
0611++ 04A3                             ; TXTNAM, TXTCOL and TXTCGP are in same order as the VDP
0612++ 04A3                             ; base address registers.
0613++ 04A3 11 B3 F3                    ld      de,TXTNAM
0614++ 04A6 0E 02                       ld      c,2
0615++ 04A8             
0616++ 04A8 AF                          xor     a
0617++ 04A9 CD 47 05                    call    set_base_address
0618++ 04AC 13                          inc     de              ; Skip TXTCOL.
0619++ 04AD 13                          inc     de
0620++ 04AE 0C                          inc     c
0621++ 04AF AF                          xor     a
0622++ 04B0 CD 47 05                    call    set_base_address
0623++ 04B3             
0624++ 04B3 C9                          ret
0625++ 04B4             
0626++ 04B4             
0627++ 04B4             ;------------------------------
0628++ 04B4             ; $007B SETT32
0629++ 04B4             ; Function : Switches VDP to SCREEN 1 mode
0630++ 04B4             ; Input    : T32NAM, T32COL, T32CGP, T32ATR, T32PAT
0631++ 04B4             ; Registers: All
0632++ 04B4             sett32:
0633++ 04B4 3A DF F3                    ld      a,(RG0SAV)
0634++ 04B7 E6 F1                       and     $F1             ; MASK 11110001
0635++ 04B9 47                          ld      b,a
0636++ 04BA 0E 00                       ld      c,0
0637++ 04BC CD 2E 02                    call    wrtvdp          ; write VDP R#0
0638++ 04BF             
0639++ 04BF 3A E0 F3                    ld      a,(RG1SAV)
0640++ 04C2 E6 E7                       and     $E7             ; MASK 11100111
0641++ 04C4 47                          ld      b,a
0642++ 04C5 0C                          inc     c
0643++ 04C6 CD 2E 02                    call    wrtvdp          ; write VDP R#1
0644++ 04C9             
0645++ 04C9                             ; Set the base address registers. This works because T32NAM,
0646++ 04C9                             ; T32COL, T32CGP, T32ATR and T32PAT are in same order as the
0647++ 04C9                             ; VDP base address registers.
0648++ 04C9 11 BD F3                    ld      de,T32NAM
0649++ 04CC 0E 02                       ld      c,2
0650++ 04CE             
0651++ 04CE AF                          xor     a
0652++ 04CF CD 47 05                    call    set_base_address
0653++ 04D2 AF                          xor     a
0654++ 04D3 CD 47 05                    call    set_base_address
0655++ 04D6 AF                          xor     a
0656++ 04D7 CD 47 05                    call    set_base_address
0657++ 04DA AF                          xor     a
0658++ 04DB CD 47 05                    call    set_base_address
0659++ 04DE AF                          xor     a
0660++ 04DF CD 47 05                    call    set_base_address
0661++ 04E2             
0662++ 04E2 C9                          ret
0663++ 04E3             
0664++ 04E3             ;------------------------------
0665++ 04E3             ; $007E SETGRP
0666++ 04E3             ; Function : Switches VDP to SCREEN 2 mode
0667++ 04E3             ; Input:     GRPNAM, GRPCOL, GRPCGP, GRPATR, GRPPAT
0668++ 04E3             ; Registers: All
0669++ 04E3             setgrp:
0670++ 04E3 3A DF F3                    ld      a,(RG0SAV)
0671++ 04E6 E6 F1                       and     $F1             ; MASK 11110001
0672++ 04E8 F6 02                       or      $02             ; M3 = 1
0673++ 04EA 47                          ld      b,a
0674++ 04EB 0E 00                       ld      c,0
0675++ 04ED CD 2E 02                    call    wrtvdp          ; write VDP R#0
0676++ 04F0             
0677++ 04F0 3A E0 F3                    ld      a,(RG1SAV)
0678++ 04F3 E6 E7                       and     $E7             ; MASK 11100111
0679++ 04F5 47                          ld      b,a
0680++ 04F6 0C                          inc     c
0681++ 04F7 CD 2E 02                    call    wrtvdp          ; write VDP R#1
0682++ 04FA             
0683++ 04FA                             ; Set the base address registers. This works because GRPNAM,
0684++ 04FA                             ; GRPCOL, GRPCGP, GRPATR and GRPPAT are in same order as the
0685++ 04FA                             ; VDP base address registers.
0686++ 04FA 11 C7 F3                    ld      de,GRPNAM
0687++ 04FD 0E 02                       ld      c,2
0688++ 04FF             
0689++ 04FF AF                          xor     a
0690++ 0500 CD 47 05                    call    set_base_address
0691++ 0503 3E 7F                       ld      a,$7F
0692++ 0505 CD 47 05                    call    set_base_address
0693++ 0508 3E 03                       ld      a,$03
0694++ 050A CD 47 05                    call    set_base_address
0695++ 050D AF                          xor     a
0696++ 050E CD 47 05                    call    set_base_address
0697++ 0511 AF                          xor     a
0698++ 0512 CD 47 05                    call    set_base_address
0699++ 0515             
0700++ 0515 C9                          ret
0701++ 0516             
0702++ 0516             ;------------------------------
0703++ 0516             ; $0081 SETMLT
0704++ 0516             ; Function : Switches VDP to SCREEN 3 mode
0705++ 0516             ; Input    : MLTNAM, MLTCGP, MLTCOL, MLTATR, MLTPAT
0706++ 0516             ; Registers: All
0707++ 0516             setmlt:
0708++ 0516 3A DF F3                    ld      a,(RG0SAV)
0709++ 0519 E6 F1                       and     $F1
0710++ 051B 47                          ld      b,a
0711++ 051C 0E 00                       ld      c,0
0712++ 051E CD 2E 02                    call    wrtvdp
0713++ 0521             
0714++ 0521 3A E0 F3                    ld      a,(RG1SAV)
0715++ 0524 E6 E7                       and     $E7
0716++ 0526 F6 08                       or      $08             ; M2 = 1
0717++ 0528 47                          ld      b,a
0718++ 0529 0C                          inc     c
0719++ 052A CD 2E 02                    call    wrtvdp
0720++ 052D             
0721++ 052D                             ; Set the base address registers. This works because MLTNAM,
0722++ 052D                             ; MLTCOL, MLTCGP, MLTATR and MLTPAT are in same order as the
0723++ 052D                             ; VDP base address registers.
0724++ 052D 11 D1 F3                    ld      de,MLTNAM
0725++ 0530 0E 02                       ld      c,2
0726++ 0532             
0727++ 0532 AF                          xor     a
0728++ 0533 CD 47 05                    call    set_base_address
0729++ 0536 AF                          xor     a
0730++ 0537 CD 47 05                    call    set_base_address; TODO: Should we ignore MLTCOL?
0731++ 053A AF                          xor     a
0732++ 053B CD 47 05                    call    set_base_address
0733++ 053E AF                          xor     a
0734++ 053F CD 47 05                    call    set_base_address
0735++ 0542 AF                          xor     a
0736++ 0543 CD 47 05                    call    set_base_address
0737++ 0546             
0738++ 0546 C9                          ret
0739++ 0547             
0740++ 0547             ;------------------------------
0741++ 0547             ; Get an address from a base address table, convert it into a register value,
0742++ 0547             ; and set the corresponding VDP base address register.
0743++ 0547             ; Input:     DE = pointer to a base address table
0744++ 0547             ;             C = VDP base address register
0745++ 0547             ;             A = OR-mask over the converted address
0746++ 0547             ; Output:    DE = DE + 2
0747++ 0547             ;             C =  C + 1
0748++ 0547             ; Changes:   AF, B, HL
0749++ 0547             set_base_address:
0750++ 0547 D5                          push    de
0751++ 0548 F5                          push    af
0752++ 0549             
0753++ 0549                             ; Get the shift value.
0754++ 0549 21 65 05                    ld      hl,set_base_address_table
0755++ 054C 06 00                       ld      b,0
0756++ 054E 09                          add     hl,bc
0757++ 054F 46                          ld      b,(hl)
0758++ 0550             
0759++ 0550                             ; Get the address from (HL) to HL.
0760++ 0550 EB                          ex      de,hl
0761++ 0551 7E                          ld      a,(hl)
0762++ 0552 23                          inc     hl
0763++ 0553 66                          ld      h,(hl)
0764++ 0554 6F                          ld      l,a
0765++ 0555             
0766++ 0555                             ; Shift it to left in register A. After this A contains the
0767++ 0555                             ; converted address.
0768++ 0555             set_base_address_loop:
0769++ 0555 29                          add     hl,hl
0770++ 0556 8F                          adc     a,a
0771++ 0557 10 FC                       djnz    set_base_address_loop
0772++ 0559 47                          ld      b,a
0773++ 055A             
0774++ 055A                             ; Set the base address register.
0775++ 055A F1                          pop     af
0776++ 055B B0                          or      b
0777++ 055C 47                          ld      b,a
0778++ 055D CD 2E 02                    call    wrtvdp
0779++ 0560             
0780++ 0560                             ; Increase pointer and register number.
0781++ 0560 D1                          pop     de
0782++ 0561 13                          inc     de
0783++ 0562 13                          inc     de
0784++ 0563 0C                          inc     c
0785++ 0564             
0786++ 0564 C9                          ret
0787++ 0565             
0788++ 0565             set_base_address_table:
0789++ 0565 00 00 06 0A                 .db      $00,$00,$06,$0A,$05,$09,$05
0789++ 0569 05 09 05 
0790++ 056C             
0791++ 056C             ;------------------------------
0792++ 056C             ; $0084 CALPAT
0793++ 056C             ; Returns the address of a sprite pattern in the sprite pattern table.
0794++ 056C             ; Input:     A  = pattern number
0795++ 056C             ; Output:    HL = address
0796++ 056C             ; Changes:   AF, DE, HL
0797++ 056C             calpat:
0798++ 056C 26 00                       ld      h,0
0799++ 056E 6F                          ld      l,a
0800++ 056F 29                          add     hl,hl
0801++ 0570 29                          add     hl,hl
0802++ 0571 29                          add     hl,hl
0803++ 0572 CD 89 05                    call    gspsiz
0804++ 0575 30 02                       jr      nc,calpat_8
0805++ 0577 29                          add     hl,hl
0806++ 0578 29                          add     hl,hl
0807++ 0579 ED 5B 26 F9 calpat_8:       ld      de,(PATBAS)
0808++ 057D 19                          add     hl,de
0809++ 057E C9                          ret
0810++ 057F             
0811++ 057F             ;------------------------------
0812++ 057F             ; $0087 CALATR
0813++ 057F             ; Returns the address of a sprite in the sprite attribute table.
0814++ 057F             ; Input:     A  = sprite number
0815++ 057F             ; Output:    HL = address
0816++ 057F             ; Changes:   AF, DE, HL
0817++ 057F             calatr:
0818++ 057F 87                          add     a,a
0819++ 0580 87                          add     a,a
0820++ 0581 2A 28 F9                    ld      hl,(ATRBAS)
0821++ 0584 16 00                       ld      d,0
0822++ 0586 5F                          ld      e,a
0823++ 0587 19                          add     hl,de
0824++ 0588 C9                          ret
0825++ 0589             
0826++ 0589             ;------------------------------
0827++ 0589             ; $008A GSPSIZ
0828++ 0589             ; Returns the current sprite-size in bytes.
0829++ 0589             ; Output:    A  = sprite-size in bytes
0830++ 0589             ;            CF = set when size is 16x16, otherwise reset
0831++ 0589             ; Changes:   AF
0832++ 0589             gspsiz:
0833++ 0589 3A E0 F3                    ld      a,(RG1SAV)
0834++ 058C 0F                          rrca
0835++ 058D 0F                          rrca
0836++ 058E 3E 08                       ld      a,8
0837++ 0590 D0                          ret     nc
0838++ 0591 3E 20                       ld      a,32
0839++ 0593 C9                          ret
0840++ 0594             
0841++ 0594             ;------------------------------
0842++ 0594             ; $008D GRPPRT
0843++ 0594             ; Function:  Places a character on graphic screen
0844++ 0594             ; Input:     A  - Character
0845++ 0594             ;            GRPACX , GRPACY : X, Y coordinate
0846++ 0594             ;            FORCLR
0847++ 0594             ; Input (SCREEN 5 and above) :
0848++ 0594             ;            LOGOPR for logical operator
0849++ 0594             ; NOTE : the function doesn't support without SCREEN 2
0850++ 0594             ;        and also slower yet.
0851++ 0594             ; Register : AF ???
0852++ 0594             grpprt:
0853++ 0594 F5                          push    af
0854++ 0595             
0855++ 0595                             ; Printable character or control character?
0856++ 0595 FE 20                       cp      $20
0857++ 0597 38 0D                       jr      c,grpprt_control
0858++ 0599             
0859++ 0599                             ; Different implementation depending on screen mode.
0860++ 0599 3A AF FC                    ld      a,(SCRMOD)
0861++ 059C FE 02                       cp      2
0862++ 059E 28 22                       jr      z,grpprt_sc2
0863++ 05A0 FE 05                       cp      5
0864++ 05A2 30 1C                       jr      nc,grpprt_sc5 ; SCRMOD >= 5
0865++ 05A4             grpprt_end:
0866++ 05A4 F1                          pop     af
0867++ 05A5 C9                          ret
0868++ 05A6             
0869++ 05A6             grpprt_control:
0870++ 05A6                             ; Ignore everything except carriage return ($0D).
0871++ 05A6 FE 0D                       cp      $0D
0872++ 05A8 20 FA                       jr      nz,grpprt_end
0873++ 05AA             
0874++ 05AA F1                          pop     af
0875++ 05AB                             ; Handle carriage return.
0876++ 05AB E5                          push    hl
0877++ 05AC C5                          push    bc
0878++ 05AD 2A B9 FC                    ld      hl,(GRPACY)
0879++ 05B0 01 08 00                    ld      bc,$0008
0880++ 05B3 09                          add     hl,bc
0881++ 05B4 22 B9 FC                    ld      (GRPACY),hl
0882++ 05B7 21 00 00                    ld      hl,$0000
0883++ 05BA 22 B7 FC                    ld      (GRPACX),hl
0884++ 05BD C1                          pop     bc
0885++ 05BE E1                          pop     hl
0886++ 05BF C9                          ret
0887++ 05C0             
0888++ 05C0             grpprt_sc5:
0889++ 05C0 F1                          pop     af
0890++ 05C1             
0891++ 05C1                     ; TODO: should these routines be merged?
0892++ 05C1             
0893++ 05C1 C9                          ret
0894++ 05C2             
0895++ 05C2             grpprt_sc2:
0896++ 05C2 F1                          pop     af
0897++ 05C3 E5                          push    hl
0898++ 05C4 D5                          push    de
0899++ 05C5 C5                          push    bc
0900++ 05C6 F5                          push    af
0901++ 05C7             
0902++ 05C7 CD 18 08                    call    getpat
0903++ 05CA             
0904++ 05CA ED 5B B9 FC                 ld      de,(GRPACY)
0905++ 05CE ED 4B B7 FC                 ld      bc,(GRPACX)
0906++ 05D2 CD 9D 08                    call    mapxy
0907++ 05D5             
0908++ 05D5 3A E9 F3                    ld      a,(FORCLR)
0909++ 05D8 32 F2 F3                    ld      (ATRBYT),a
0910++ 05DB             
0911++ 05DB 2A 2A F9                    ld      hl,(CLOC)
0912++ 05DE ED 4B CB F3                 ld      bc,(GRPCGP)
0913++ 05E2 09                          add     hl,bc
0914++ 05E3             
0915++ 05E3             
0916++ 05E3 11 40 FC                    ld      de,PATWRK
0917++ 05E6 3A B9 FC                    ld      a,(GRPACY)
0918++ 05E9 E6 07                       and     $07
0919++ 05EB             
0920++ 05EB 06 00                       ld      b,$00
0921++ 05ED 4F                          ld      c,a
0922++ 05EE 09                          add     hl,bc
0923++ 05EF CD 0F 06                    call    grpprt_chr_x
0924++ 05F2             
0925++ 05F2 01 F0 00                    ld      bc,$00F0
0926++ 05F5 09                          add     hl,bc
0927++ 05F6 3A B9 FC                    ld      a,(GRPACY)
0928++ 05F9 2F                          cpl
0929++ 05FA E6 07                       and     $07
0930++ 05FC 4F                          ld      c,a
0931++ 05FD             
0932++ 05FD CD 0F 06                    call    grpprt_chr_x
0933++ 0600             
0934++ 0600 2A B7 FC                    ld      hl,(GRPACX)
0935++ 0603 01 08 00                    ld      bc,$0008
0936++ 0606 09                          add     hl,bc
0937++ 0607 22 B7 FC                    ld      (GRPACX),hl
0938++ 060A             
0939++ 060A F1                          pop     af
0940++ 060B C1                          pop     bc
0941++ 060C D1                          pop     de
0942++ 060D E1                          pop     hl
0943++ 060E             
0944++ 060E C9                          ret
0945++ 060F             
0946++ 060F             grpprt_chr_x:
0947++ 060F 3A B7 FC                    ld      a,(GRPACX)
0948++ 0612 E6 07                       and     $07
0949++ 0614 F5                          push    af
0950++ 0615 C5                          push    bc
0951++ 0616 D5                          push    de
0952++ 0617 E5                          push    hl
0953++ 0618 CD 98 06                    call    grpprt_chr ; half left
0954++ 061B 3A B7 FC                    ld      a,(GRPACX)
0955++ 061E E6 07                       and     $07
0956++ 0620 28 1A                       jr      z,grpprt_skip_hr
0957++ 0622 3A 2C F9                    ld      a,(CMASK)
0958++ 0625 2F                          cpl
0959++ 0626 32 2C F9                    ld      (CMASK),a
0960++ 0629 E1                          pop     hl
0961++ 062A 01 08 00                    ld      bc,$0008
0962++ 062D 09                          add     hl,bc
0963++ 062E D1                          pop     de
0964++ 062F C1                          pop     bc
0965++ 0630 F1                          pop     af
0966++ 0631             
0967++ 0631 CD 98 06                    call    grpprt_chr ; half right
0968++ 0634 3A 2C F9                    ld      a,(CMASK)
0969++ 0637 2F                          cpl
0970++ 0638 32 2C F9                    ld      (CMASK),a
0971++ 063B C9                          ret
0972++ 063C             grpprt_skip_hr:
0973++ 063C C1                          pop     bc ; HL = the result of last grpprt_chr
0974++ 063D 01 08 00                    ld      bc,$0008
0975++ 0640 09                          add     hl,bc
0976++ 0641 C1                          pop     bc ; DE = the result of last grpprt_chr
0977++ 0642 C1                          pop     bc
0978++ 0643 F1                          pop     af
0979++ 0644 C9                          ret
0980++ 0645             
0981++ 0645             
0982++ 0645             
0983++ 0645             ; A = Pattern , B = Pattern in VRAM
0984++ 0645             grpprt_attr:
0985++ 0645 F5                          push    af
0986++ 0646 E5                          push    hl
0987++ 0647 C5                          push    bc
0988++ 0648 D5                          push    de
0989++ 0649             
0990++ 0649 57                          ld      d,a   ; D = Pattern of charactor
0991++ 064A 58                          ld      e,b   ; E = Pattern in VRAM
0992++ 064B             
0993++ 064B ED 4B C9 F3                 ld      bc,(GRPCOL)
0994++ 064F 09                          add     hl,bc
0995++ 0650 4F                          ld      c,a
0996++ 0651 3A F2 F3                    ld      a,(ATRBYT)
0997++ 0654 E6 0F                       and     $0f
0998++ 0656 47                          ld      b,a
0999++ 0657 CD 45 02                    call    rdvrm
1000++ 065A             
1001++ 065A F5                          push    af    ; A = an attribute in VRAM
1002++ 065B E6 0F                       and     $0f
1003++ 065D B8                          cp      b
1004++ 065E 28 11                       jr      z,grpprt_attr_black
1005++ 0660 F1                          pop     af
1006++ 0661 F5                          push    af
1007++ 0662 0F                          rrca
1008++ 0663 0F                          rrca
1009++ 0664 0F                          rrca
1010++ 0665 0F                          rrca
1011++ 0666 E6 0F                       and     $0f
1012++ 0668 B8                          cp      b
1013++ 0669 20 0D                       jr      nz,grpprt_attr_nomatch
1014++ 066B F1                          pop     af
1015++ 066C             grpprt_attr_end:
1016++ 066C D1                          pop     de
1017++ 066D C1                          pop     bc
1018++ 066E E1                          pop     hl
1019++ 066F F1                          pop     af
1020++ 0670 C9                          ret
1021++ 0671             grpprt_attr_black:
1022++ 0671 F1                          pop     af
1023++ 0672             grpprt_attr_blk_end:
1024++ 0672 D1                          pop     de
1025++ 0673 C1                          pop     bc
1026++ 0674 E1                          pop     hl
1027++ 0675 F1                          pop     af
1028++ 0676 2F                          cpl
1029++ 0677 C9                          ret
1030++ 0678             grpprt_attr_nomatch:
1031++ 0678 7A                          ld      a,d
1032++ 0679 B3                          or      e
1033++ 067A FE FF                       cp      $ff
1034++ 067C 28 11                       jr      z,grpprt_attr_make_black
1035++ 067E F1                          pop     af
1036++ 067F CB 00                       rlc     b
1037++ 0681 CB 00                       rlc     b
1038++ 0683 CB 00                       rlc     b
1039++ 0685 CB 00                       rlc     b
1040++ 0687 E6 0F                       and     $0f
1041++ 0689 B0                          or      b
1042++ 068A CD 4B 02                    call    wrtvrm
1043++ 068D 18 DD                       jr      grpprt_attr_end
1044++ 068F             grpprt_attr_make_black:
1045++ 068F F1                          pop     af
1046++ 0690 E6 F0                       and     $f0
1047++ 0692 B0                          or      b
1048++ 0693 CD 4B 02                    call    wrtvrm
1049++ 0696 18 DA                       jr      grpprt_attr_blk_end
1050++ 0698             
1051++ 0698             
1052++ 0698             ; A = X MOD 8,C = Y MOD 8, HL = CLOC
1053++ 0698             grpprt_chr:
1054++ 0698 41                          ld      b,c
1055++ 0699 3C                          inc     a
1056++ 069A 4F                          ld      c,a
1057++ 069B             
1058++ 069B 3E 07                       ld      a,$07
1059++ 069D A8                          xor     b
1060++ 069E 3C                          inc     a
1061++ 069F 47                          ld      b,a
1062++ 06A0             
1063++ 06A0             grpprt_lp:
1064++ 06A0 C5                          push    bc
1065++ 06A1 CD 45 02                    call    rdvrm
1066++ 06A4 47                          ld      b,a
1067++ 06A5 1A                          ld      a,(de)
1068++ 06A6 CD 45 06                    call    grpprt_attr
1069++ 06A9             grpprt_sft_lp:
1070++ 06A9 0D                          dec     c
1071++ 06AA 28 03                       jr      z,grpprt_sft_ed
1072++ 06AC 0F                          rrca
1073++ 06AD 18 FA                       jr      grpprt_sft_lp
1074++ 06AF             grpprt_sft_ed:
1075++ 06AF 4F                          ld      c,a
1076++ 06B0 3A 2C F9                    ld      a,(CMASK)
1077++ 06B3 A1                          and     c
1078++ 06B4 4F                          ld      c,a       ; charactor with mask
1079++ 06B5             
1080++ 06B5 78                          ld      a,b       ; B = pattern in VRAM
1081++ 06B6 B1                          or      c
1082++ 06B7             
1083++ 06B7 CD 4B 02                    call    wrtvrm
1084++ 06BA 23                          inc     hl
1085++ 06BB 13                          inc     de
1086++ 06BC C1                          pop     bc
1087++ 06BD 10 E1                       djnz    grpprt_lp
1088++ 06BF C9                          ret
1089++ 06C0             
1090++ 06C0             
1091++ 06C0 47 52 50 50 grpprt_text:    .db      "GRPPRT",0
1091++ 06C4 52 54 00 
1092++ 06C7             
1093++ 06C7             ;--------------------------------
1094++ 06C7             ; 0165h CHKNEW
1095++ 06C7             ; Is the current screen mode a bitmap mode?
1096++ 06C7             ; Output:  Carry flag set if current screen mode is SCREEN 5 or higher.
1097++ 06C7             ; Changes: AF
1098++ 06C7             chknew:
1099++ 06C7 3A AF FC                    ld      a,(SCRMOD)
1100++ 06CA FE 05                       cp      5
1101++ 06CC C9                          ret
1102++ 06CD             
1103++ 06CD             ;--------------------------------
1104++ 06CD             ; 016Bh BIGFIL
1105++ 06CD             ; Fills VRAM with a fixed value.
1106++ 06CD             ; Like FILVRM, but supports 128K of VRAM.
1107++ 06CD             ; Input:   HL = VRAM start address
1108++ 06CD             ;    (ACPAGE) = active VRAM page
1109++ 06CD             ;          BC = number of bytes to fill
1110++ 06CD             ;          A  = value to fill VRAM with
1111++ 06CD             ; Changes: AF, BC
1112++ 06CD             bigfil:
1113++ 06CD F5                          push    af
1114++ 06CE CD EC 06                    call    nsetwr
1115++ 06D1 0B                          dec     bc
1116++ 06D2 0C                          inc     c
1117++ 06D3 78                          ld      a,b
1118++ 06D4 41                          ld      b,c
1119++ 06D5 4F                          ld      c,a
1120++ 06D6 0C                          inc     c
1121++ 06D7 F1                          pop     af
1122++ 06D8 F3                          di
1123++ 06D9             bigfil_lp:
1124++ 06D9 D3 98                       out     (VDP_DATA),a
1125++ 06DB 10 FC                       djnz    bigfil_lp
1126++ 06DD 0D                          dec     c
1127++ 06DE 20 F9                       jr      nz,bigfil_lp
1128++ 06E0 FB                          ei
1129++ 06E1 C9                          ret
1130++ 06E2             
1131++ 06E2             ;--------------------------------
1132++ 06E2             ; 016Eh NSETRD
1133++ 06E2             ; Set VRAM address and read mode.
1134++ 06E2             ; Like SETRD, but supports 128K of VRAM.
1135++ 06E2             ; Input:   HL = VRAM address
1136++ 06E2             ;    (ACPAGE) = active VRAM page
1137++ 06E2             ; Changes: AF
1138++ 06E2             ; Note: If an odd-numbered 32K page is active and HL >= $8000,
1139++ 06E2             ;       16-bit wrap around occurs.
1140++ 06E2             nsetrd:
1141++ 06E2 CD F8 06                    call    nset_addr
1142++ 06E5 7C                          ld      a,h
1143++ 06E6 E6 3F                       and     $3F
1144++ 06E8 D3 99                       out     (VDP_ADDR),a    ; A13..A8
1145++ 06EA FB                          ei
1146++ 06EB C9                          ret
1147++ 06EC             
1148++ 06EC             ;--------------------------------
1149++ 06EC             ; 0171h NSETWR
1150++ 06EC             ; Set VRAM address and write mode.
1151++ 06EC             ; Like SETWRT, but supports 128K of VRAM.
1152++ 06EC             ; Input:   HL = VRAM address
1153++ 06EC             ;    (ACPAGE) = active VRAM page
1154++ 06EC             ; Changes: AF
1155++ 06EC             ; Note: If an odd-numbered 32K page is active and HL >= $8000,
1156++ 06EC             ;       16-bit wrap around occurs.
1157++ 06EC             nsetwr:
1158++ 06EC CD F8 06                    call    nset_addr
1159++ 06EF 7C                          ld      a,h
1160++ 06F0 E6 3F                       and     $3F
1161++ 06F2 F6 40                       or      $40
1162++ 06F4 D3 99                       out     (VDP_ADDR),a    ; A13..A8
1163++ 06F6 FB                          ei
1164++ 06F7 C9                          ret
1165++ 06F8             
1166++ 06F8             nset_addr:
1167++ 06F8 3A F6 FA                    ld      a,(ACPAGE)
1168++ 06FB B7                          or      a
1169++ 06FC 28 10                       jr      z,nset_32k
1170++ 06FE             
1171++ 06FE 3A AF FC                    ld      a,(SCRMOD)
1172++ 0701 FE 05                       cp      5
1173++ 0703 DA 5E 02                    jp      c,setwrt
1174++ 0706 FE 07                       cp      7
1175++ 0708 3A F6 FA                    ld      a,(ACPAGE)
1176++ 070B 38 01                       jr      c,nset_32k      ; SCREEN5/6 -> 32K pages
1177++ 070D 87                          add     a,a             ; SCREEN7/8 -> 64K pages
1178++ 070E E5          nset_32k:       push    hl
1179++ 070F E6 03                       and     $03             ; A  =  0   0   0   0   0   0   P1  P0
1180++ 0711 0F                          rrca
1181++ 0712 6F                          ld      l,a             ; L  =  P0  0   0   0   0   0   0   P1
1182++ 0713 E6 80                       and     $80             ; A  =  P0  0   0   0   0   0   0   0
1183++ 0715 AC                          xor     h               ; A  = A15 A14 A13 A12 A11 A10  A9  A8
1184++ 0716 17                          rla                     ; CF = A15
1185++ 0717 CB 15                       rl      l               ; L  =  0   0   0   0   0   0   P1 A15
1186++ 0719 17                          rla                     ; CF = A14
1187++ 071A 7D                          ld      a,l
1188++ 071B 17                          rla                     ; A  =  0   0   0   0   0   P1 A15 A14
1189++ 071C F3                          di
1190++ 071D D3 99                       out     (VDP_ADDR),a    ; A16..A14
1191++ 071F 3E 8E                       ld      a,$8E
1192++ 0721 D3 99                       out     (VDP_ADDR),a    ; R#14
1193++ 0723 E1                          pop     hl
1194++ 0724 7D                          ld      a,l
1195++ 0725 D3 99                       out     (VDP_ADDR),a    ; A7..A0
1196++ 0727 C9                          ret
1197++ 0728             
1198++ 0728             
1199++ 0728             
1200++ 0728             ;--------------------------------
1201++ 0728             ; 0174h NRDVRM
1202++ 0728             ; Read a byte from VRAM.
1203++ 0728             ; Leaves the VRAM in read mode at the byte after the one read.
1204++ 0728             ; Like RDVRM, but supports 128K of VRAM.
1205++ 0728             ; Input:   HL = VRAM address
1206++ 0728             ;    (ACPAGE) = active VRAM page
1207++ 0728             ; Output:   A = the byte read
1208++ 0728             nrdvrm:
1209++ 0728 CD E2 06                    call    nsetrd
1210++ 072B DB 98                       in      a,(VDP_DATA)
1211++ 072D C9                          ret
1212++ 072E             
1213++ 072E             ;--------------------------------
1214++ 072E             ; 0177h NWRVRM
1215++ 072E             ; Write a byte to VRAM.
1216++ 072E             ; Leaves the VRAM in write mode at the byte after the one written.
1217++ 072E             ; Like WRTVRM, but supports 128K of VRAM.
1218++ 072E             ; Input:   HL = VRAM address
1219++ 072E             ;    (ACPAGE) = active VRAM page
1220++ 072E             ;           A = the byte to write
1221++ 072E             nwrvrm:
1222++ 072E F5                          push    af
1223++ 072F CD EC 06                    call    nsetwr
1224++ 0732 F1                          pop     af
1225++ 0733 D3 98                       out     (VDP_DATA),a
1226++ 0735 C9                          ret
1227++ 0736             
1228++ 0736             
1229++ 0736             ; VDP routines which only exist in sub rom, but are useful for C-BIOS internal
1230++ 0736             ; use as well:
1231++ 0736             
1232++ 0736             ;-------------------------------------
1233++ 0736             ; $0131(sub) VDPSTA
1234++ 0736             ; Read VDP status register.
1235++ 0736             ; Input:   A = number of status register
1236++ 0736             ; Output:  A = value read
1237++ 0736             ; Changes: F
1238++ 0736             vdpsta:
1239++ 0736 F3                          di
1240++ 0737                             ; Select desired status register.
1241++ 0737 D3 99                       out     (VDP_ADDR),a
1242++ 0739 3E 8F                       ld      a,$80 + 15
1243++ 073B D3 99                       out     (VDP_ADDR),a
1244++ 073D                             ; Read status register.
1245++ 073D DB 99                       in      a,(VDP_STAT)
1246++ 073F F5                          push    af
1247++ 0740                             ; Restore status register 0.
1248++ 0740 AF                          xor     a
1249++ 0741 D3 99                       out     (VDP_ADDR),a
1250++ 0743 3E 8F                       ld      a,$80 + 15
1251++ 0745 D3 99                       out     (VDP_ADDR),a
1252++ 0747 FB                          ei
1253++ 0748 F1                          pop     af
1254++ 0749 C9                          ret
1255++ 074A             
1256++ 074A             
1257++ 074A             ;--------------------
1258++ 074A             ;Initializes VDP routine
1259++ 074A             ;--------------------
1260++ 074A             
1261++ 074A             init_vdp:
1262++ 074A DB 99                       in      a,(VDP_STAT)    ; reset latch
1263++ 074C             
1264++ 074C 01 00 00                    ld      bc,$0000        ; R#0
1265++ 074F CD 2E 02                    call    wrtvdp
1266++ 0752 01 01 E0                    ld      bc,$E001        ; R#1
1267++ 0755 CD 2E 02                    call    wrtvdp
1268++ 0758 01 02 00                    ld      bc,$0002        ; R#2
1269++ 075B CD 2E 02                    call    wrtvdp
1270++ 075E 01 03 80                    ld      bc,$8003        ; R#3
1271++ 0761 CD 2E 02                    call    wrtvdp
1272++ 0764 01 04 01                    ld      bc,$0104        ; R#4
1273++ 0767 CD 2E 02                    call    wrtvdp
1274++ 076A             
1275++ 076A 3E 01                       ld      a,1
1276++ 076C 32 DC F3                    ld      (CSRY),a
1277++ 076F 32 DD F3                    ld      (CSRX),a
1278++ 0772 CD D2 07                    call    cls_screen1
1279++ 0775             
1280++ 0775 3E 00                       ld      a ,$00
1281++ 0777 21 00 08                    ld      hl,$0800
1282++ 077A 01 00 08                    ld      bc,$0800
1283++ 077D CD 6B 02                    call    filvrm
1284++ 0780             
1285++ 0780                             ; for screen 1 color table
1286++ 0780 3E F5                       ld      a ,$F5
1287++ 0782 21 00 20                    ld      hl,$2000
1288++ 0785 01 20 00                    ld      bc,$0020
1289++ 0788 CD 6B 02                    call    filvrm
1290++ 078B             
1291++ 078B             
1292++ 078B             ; PatGenTbl
1293++ 078B             ;        76543210 76543210
1294++ 078B             ;        00000100 00000000
1295++ 078B             ;             04h      00h
1296++ 078B             
1297++ 078B 01 07 F5                    ld      bc,$F507        ; R#7
1298++ 078E CD 2E 02                    call    wrtvdp
1299++ 0791             
1300++ 0791                     .IF COMPILE_FONT != NO
1301++ 0791 21 BF 1B                    ld      hl,B_Font
1302++ 0794 11 00 08                    ld      de,$0800
1303++ 0797 01 00 08                    ld      bc,$0800
1304++ 079A CD 97 02                    call    ldirvm
1305++ 079D                     .ENDIF
1306++ 079D C9                          ret
1307++ 079E             
1308++ 079E             
1309++ 079E             
1310++ 079E                     .IF COMPILE_FONT != NO
1311++ 079E             ;------------------------------
1312++ 079E             ; Initialise font.
1313++ 079E             ; Uploads font to VRAM address specified by CGPBAS.
1314++ 079E             init_font:
1315++ 079E 21 BF 1B                    ld      hl,B_Font
1316++ 07A1 ED 5B 24 F9                 ld      de,(CGPBAS)
1317++ 07A5 01 00 08                    ld      bc,$0800
1318++ 07A8 C3 97 02                    jp      ldirvm
1319++ 07AB                     .ENDIF
1320++ 07AB             
1321++ 07AB             
1322++ 07AB             ;--------------------------------
1323++ 07AB             ; $00C3 CLS
1324++ 07AB             ; Clears the screen.
1325++ 07AB             ; Input:   BAKCLR,
1326++ 07AB             ;          Z-Flag has to be low if the main ROM version of CLS is called;
1327++ 07AB             ;          in the sub ROM version of CVS the Z-Flag is ignored.
1328++ 07AB             ; Changes: AF, BC, DE
1329++ 07AB             ;TODO: add optional borders to text based screens
1330++ 07AB             ;      -> Should that happen in CLS?
1331++ 07AB             cls_z:
1332++ 07AB C0                          ret     nz
1333++ 07AC             cls:
1334++ 07AC 3A AF FC                    ld      a,(SCRMOD)
1335++ 07AF FE 04                       cp      4
1336++ 07B1 D0                          ret     nc                      ; Out of range?
1337++ 07B2 E5                          push    hl
1338++ 07B3 21 BB 07                    ld      hl,cls_table
1339++ 07B6 CD 00 02                    call    jump_table
1340++ 07B9 E1                          pop     hl
1341++ 07BA C9                          ret
1342++ 07BB             cls_table:
1343++ 07BB C3 07                       .dw      cls_screen0
1344++ 07BD D2 07                       .dw      cls_screen1
1345++ 07BF EE 07                       .dw      cls_screen2
1346++ 07C1 04 08                       .dw      cls_screen3
1347++ 07C3             
1348++ 07C3             cls_screen0:
1349++ 07C3 3A B0 F3                    ld      a,(LINLEN)
1350++ 07C6 FE 28                       cp      40
1351++ 07C8 01 C0 03                    ld      bc,40*24
1352++ 07CB 38 08                       jr      c,cls_text
1353++ 07CD 01 80 07                    ld      bc,80*24
1354++ 07D0 18 03                       jr      cls_text
1355++ 07D2             
1356++ 07D2             cls_screen1:
1357++ 07D2 01 00 03                    ld      bc,32*24
1358++ 07D5             
1359++ 07D5             cls_text:
1360++ 07D5 2A 22 F9                    ld      hl,(NAMBAS)
1361++ 07D8 3E 20                       ld      a,$20
1362++ 07DA CD 6B 02                    call    filvrm
1363++ 07DD             
1364++ 07DD 3E 01                       ld      a,1
1365++ 07DF 21 B2 FB                    ld      hl,LINTTB
1366++ 07E2 77                          ld      (hl),a
1367++ 07E3 11 B3 FB                    ld      de,LINTTB+1
1368++ 07E6 01 17 00                    ld      bc,23
1369++ 07E9 ED B0                       ldir
1370++ 07EB C3 58 10                    jp      chput_ctrl_home
1371++ 07EE             
1372++ 07EE             cls_screen2:
1373++ 07EE AF                          xor     a
1374++ 07EF 01 00 18                    ld      bc,$1800
1375++ 07F2 2A 24 F9                    ld      hl,(CGPBAS)
1376++ 07F5 6F                          ld      l,a
1377++ 07F6 C5                          push    bc
1378++ 07F7 CD 6B 02                    call    filvrm
1379++ 07FA C1                          pop     bc
1380++ 07FB             
1381++ 07FB 3A EA F3                    ld      a,(BAKCLR)
1382++ 07FE 2A C9 F3                    ld      hl,(GRPCOL)
1383++ 0801 C3 6B 02                    jp      filvrm
1384++ 0804             
1385++ 0804             cls_screen3:
1386++ 0804 3A EA F3                    ld      a,(BAKCLR)
1387++ 0807 E6 0F                       and     $0F
1388++ 0809 47                          ld      b,a
1389++ 080A 07                          rlca
1390++ 080B 07                          rlca
1391++ 080C 07                          rlca
1392++ 080D 07                          rlca
1393++ 080E B0                          or      b
1394++ 080F 01 00 08                    ld      bc,$800
1395++ 0812 2A 24 F9                    ld      hl,(CGPBAS)
1396++ 0815 C3 6B 02                    jp      filvrm
1397++ 0818             
1398++ 0818             
1399++ 0818             ; $0105 GETPAT
1400++ 0818             ; Function : Returns current pattern of a character
1401++ 0818             ; Input    : A  - ASCII code of character
1402++ 0818             ; Output   : Pattern in PATWRK starting from address #FC40
1403++ 0818             ; Registers: All
1404++ 0818             ; Remark   : Same as routine in MSX1-BIOS, but there it doesn't exist as
1405++ 0818             ;            a BIOS-call
1406++ 0818             getpat:
1407++ 0818 ED 4B 20 F9                 ld      bc,(CGPNT+1)
1408++ 081C 6F                          ld      l,a
1409++ 081D 26 00                       ld      h,0
1410++ 081F 29                          add     hl,hl
1411++ 0820 29                          add     hl,hl
1412++ 0821 29                          add     hl,hl
1413++ 0822 09                          add     hl,bc
1414++ 0823 06 08                       ld      b,8
1415++ 0825 11 40 FC                    ld      de,PATWRK
1416++ 0828 C5          getpat_loop:    push    bc
1417++ 0829 D5                          push    de
1418++ 082A E5                          push    hl
1419++ 082B 3A 1F F9                    ld      a,(CGPNT)
1420++ 082E CD BF 23                    call    rdslt
1421++ 0831 E1                          pop     hl
1422++ 0832 D1                          pop     de
1423++ 0833 C1                          pop     bc
1424++ 0834 12                          ld      (de),a
1425++ 0835 13                          inc     de
1426++ 0836 23                          inc     hl
1427++ 0837 10 EF                       djnz    getpat_loop
1428++ 0839 C9                          ret
1429++ 083A             
1430++ 083A             ;--------------------------------
1431++ 083A             ; $00FC RIGHTC
1432++ 083A             ; Function : Shifts screenpixel to the right
1433++ 083A             ; Registers: AF
1434++ 083A             ; NOTE     : This implementation is still a stub!
1435++ 083A             rightc:
1436++ 083A E5                          push    hl
1437++ 083B F5                          push    af
1438++ 083C 21 42 08                    ld      hl,rightc_text
1439++ 083F             ;                call    print_debug
1440++ 083F F1                          pop     af
1441++ 0840 E1                          pop     hl
1442++ 0841 C9                          ret
1443++ 0842 52 49 47 48 rightc_text:    .db      "RIGHTC",0
1443++ 0846 54 43 00 
1444++ 0849             
1445++ 0849             ;--------------------------------
1446++ 0849             ; $00FF LEFTC
1447++ 0849             ; Function : Shifts screenpixel to the left
1448++ 0849             ; Registers: AF
1449++ 0849             ; NOTE     : This implementation is still a stub!
1450++ 0849             leftc:
1451++ 0849 E5                          push    hl
1452++ 084A F5                          push    af
1453++ 084B 21 51 08                    ld      hl,leftc_text
1454++ 084E             ;                call    print_debug
1455++ 084E F1                          pop     af
1456++ 084F E1                          pop     hl
1457++ 0850 C9                          ret
1458++ 0851 4C 45 46 54 leftc_text:     .db      "LEFTC",0
1458++ 0855 43 00 
1459++ 0857             
1460++ 0857             ;--------------------------------
1461++ 0857             ; $0102 UPC
1462++ 0857             ; Function : Shifts screenpixel up
1463++ 0857             ; Registers: AF
1464++ 0857             ; NOTE     : This implementation is still a stub!
1465++ 0857             upc:
1466++ 0857 E5                          push    hl
1467++ 0858 F5                          push    af
1468++ 0859 21 5F 08                    ld      hl,upc_text
1469++ 085C             ;                call    print_debug
1470++ 085C F1                          pop     af
1471++ 085D E1                          pop     hl
1472++ 085E C9                          ret
1473++ 085F 55 50 43 00 upc_text:       .db      "UPC",0
1474++ 0863             
1475++ 0863             ;--------------------------------
1476++ 0863             ; $0105 TUPC
1477++ 0863             ; Function : Tests whether UPC is possible, if possible, execute UPC
1478++ 0863             ; Output   : C-flag set if operation would end outside the screen
1479++ 0863             ; Registers: AF
1480++ 0863             ; NOTE     : This implementation is still a stub!
1481++ 0863             tupc:
1482++ 0863 E5                          push    hl
1483++ 0864 F5                          push    af
1484++ 0865 21 6B 08                    ld      hl,tupc_text
1485++ 0868             ;                call    print_debug
1486++ 0868 F1                          pop     af
1487++ 0869 E1                          pop     hl
1488++ 086A C9                          ret
1489++ 086B 54 55 50 43 tupc_text:      .db      "TUPC",0
1489++ 086F 00 
1490++ 0870             
1491++ 0870             ;--------------------------------
1492++ 0870             ; $0108 DOWNC
1493++ 0870             ; Function : Shifts screenpixel down
1494++ 0870             ; Registers: AF
1495++ 0870             ; NOTE     : This implementation is still a stub!
1496++ 0870             downc:
1497++ 0870 E5                          push    hl
1498++ 0871 F5                          push    af
1499++ 0872 21 78 08                    ld      hl,downc_text
1500++ 0875             ;                call    print_debug
1501++ 0875 F1                          pop     af
1502++ 0876 E1                          pop     hl
1503++ 0877 C9                          ret
1504++ 0878 44 4F 57 4E downc_text:     .db      "DOWNC",0
1504++ 087C 43 00 
1505++ 087E             
1506++ 087E             ;--------------------------------
1507++ 087E             ; $010B TDOWNC
1508++ 087E             ; Function : Tests whether DOWNC is possible, if possible, execute DOWNC
1509++ 087E             ; Output   : C-flag set if operation would end outside the screen
1510++ 087E             ; Registers: AF
1511++ 087E             ; NOTE     : This implementation is still a stub!
1512++ 087E             tdownc:
1513++ 087E E5                          push    hl
1514++ 087F F5                          push    af
1515++ 0880 21 86 08                    ld      hl,tdownc_text
1516++ 0883             ;                call    print_debug
1517++ 0883 F1                          pop     af
1518++ 0884 E1                          pop     hl
1519++ 0885 C9                          ret
1520++ 0886 54 44 4F 57 tdownc_text:    .db      "TDOWNC",0
1520++ 088A 4E 43 00 
1521++ 088D             
1522++ 088D             ;--------------------------------
1523++ 088D             ; $010E SCALXY
1524++ 088D             ; Function : Scales X and Y coordinates
1525++ 088D             ; NOTE     : This implementation is still a stub!
1526++ 088D             scalxy:
1527++ 088D ED 4B B7 FC                 ld      bc,(GRPACX)
1528++ 0891 ED 5B B9 FC                 ld      de,(GRPACY)
1529++ 0895 C9                          ret
1530++ 0896 53 43 41 4C scalxy_text:    .db      "SCALXY",0
1530++ 089A 58 59 00 
1531++ 089D             
1532++ 089D             ;--------------------------------
1533++ 089D             ; $0111 MAPXYC
1534++ 089D             ; Function : Places cursor at current cursor address
1535++ 089D             ; Input    : BC = X coordinate,DE=Y coordinate
1536++ 089D             ; Register : AF,D,HL
1537++ 089D             ; NOTE     : This is a test version
1538++ 089D             mapxy:
1539++ 089D C5                          push    bc
1540++ 089E ED 43 B7 FC                 ld      (GRPACX),bc
1541++ 08A2 ED 53 B9 FC                 ld      (GRPACY),de
1542++ 08A6 2A B9 FC                    ld      hl,(GRPACY)
1543++ 08A9 29                          add     hl,hl
1544++ 08AA 29                          add     hl,hl
1545++ 08AB 29                          add     hl,hl
1546++ 08AC 29                          add     hl,hl
1547++ 08AD 29                          add     hl,hl
1548++ 08AE 2E 00                       ld      l,$00
1549++ 08B0 06 00                       ld      b,$00
1550++ 08B2             
1551++ 08B2 3E FF                       ld      a,$ff
1552++ 08B4 32 2C F9                    ld      (CMASK),a
1553++ 08B7 79                          ld      a,c
1554++ 08B8 E6 07                       and     $07
1555++ 08BA 28 0A                       jr      z,mapxy_mask_ed
1556++ 08BC 47                          ld      b,a
1557++ 08BD 3E FF                       ld      a,$ff
1558++ 08BF             mapxy_mask_lp:
1559++ 08BF A7                          and     a
1560++ 08C0 1F                          rra
1561++ 08C1 10 FC                       djnz    mapxy_mask_lp
1562++ 08C3 32 2C F9                    ld      (CMASK),a
1563++ 08C6             mapxy_mask_ed:
1564++ 08C6 79                          ld      a,c
1565++ 08C7 E6 F8                       and     $F8
1566++ 08C9 4F                          ld      c,a
1567++ 08CA 06 00                       ld      b,$00
1568++ 08CC 09                          add     hl,bc
1569++ 08CD             
1570++ 08CD 22 2A F9                    ld      (CLOC),hl
1571++ 08D0 C1                          pop     bc
1572++ 08D1 C9                          ret
1573++ 08D2 4D 41 50 58 mapxy_text:    .db      "MAPXY",0
1573++ 08D6 59 00 
1574++ 08D8             
1575++ 08D8             ;--------------------------------
1576++ 08D8             ; $0114 FETCHC
1577++ 08D8             ; Function : Gets current cursor addresses mask pattern
1578++ 08D8             ; Output   : HL - Cursor address
1579++ 08D8             ;            A  - Mask pattern
1580++ 08D8             fetchc:
1581++ 08D8 3A 2C F9                    ld      a,(CMASK)
1582++ 08DB 2A 2A F9                    ld      hl,(CLOC)
1583++ 08DE C9                          ret
1584++ 08DF 46 45 54 43 fetchc_text:    .db      "FETCHC",0
1584++ 08E3 48 43 00 
1585++ 08E6             
1586++ 08E6             ;--------------------------------
1587++ 08E6             ; $0117 STOREC
1588++ 08E6             ; Function : Record current cursor addresses mask pattern
1589++ 08E6             ; Input    : HL - Cursor address
1590++ 08E6             ;            A  - Mask pattern
1591++ 08E6             ; NOTE     : This implementation is still a stub!
1592++ 08E6             storec:
1593++ 08E6 E5                          push    hl
1594++ 08E7 F5                          push    af
1595++ 08E8 21 EE 08                    ld      hl,storec_text
1596++ 08EB             ;                call    print_debug
1597++ 08EB F1                          pop     af
1598++ 08EC E1                          pop     hl
1599++ 08ED C9                          ret
1600++ 08EE 53 54 4F 52 storec_text:    .db      "STOREC",0
1600++ 08F2 45 43 00 
1601++ 08F5             
1602++ 08F5             ;--------------------------------
1603++ 08F5             ; $011A SETATR
1604++ 08F5             ; Function : Set attribute byte
1605++ 08F5             ; NOTE     : This implementation is still a stub!
1606++ 08F5             setatr:
1607++ 08F5 E5                          push    hl
1608++ 08F6 F5                          push    af
1609++ 08F7 21 FD 08                    ld      hl,setatr_text
1610++ 08FA             ;                call    print_debug
1611++ 08FA F1                          pop     af
1612++ 08FB E1                          pop     hl
1613++ 08FC C9                          ret
1614++ 08FD 53 45 54 41 setatr_text:    .db      "SETATR",0
1614++ 0901 54 52 00 
1615++ 0904             
1616++ 0904             ;--------------------------------
1617++ 0904             ; $011D READC
1618++ 0904             ; Function : Reads attribute byte of current screenpixel
1619++ 0904             ; NOTE     : This implementation is still a stub!
1620++ 0904             readc:
1621++ 0904 E5                          push    hl
1622++ 0905 F5                          push    af
1623++ 0906 21 0C 09                    ld      hl,readc_text
1624++ 0909             ;                call    print_debug
1625++ 0909 F1                          pop     af
1626++ 090A E1                          pop     hl
1627++ 090B C9                          ret
1628++ 090C 52 45 41 44 readc_text:     .db      "READC",0
1628++ 0910 43 00 
1629++ 0912             
1630++ 0912             ;--------------------------------
1631++ 0912             ; $0120 SETC
1632++ 0912             ; Function : Returns currenct screenpixel of specificed attribute byte
1633++ 0912             ; NOTE     : This implementation is still a stub!
1634++ 0912             setc:
1635++ 0912 E5                          push    hl
1636++ 0913 F5                          push    af
1637++ 0914 21 1A 09                    ld      hl,setc_text
1638++ 0917             ;                call    print_debug
1639++ 0917 F1                          pop     af
1640++ 0918 E1                          pop     hl
1641++ 0919 C9                          ret
1642++ 091A 53 45 54 43 setc_text:      .db      "SETC",0
1642++ 091E 00 
1643++ 091F             
1644++ 091F             ;--------------------------------
1645++ 091F             ; $0123 NSETCX
1646++ 091F             ; Function : Set horizontal screenpixels
1647++ 091F             ; NOTE     : This implementation is still a stub!
1648++ 091F             nsetcx:
1649++ 091F E5                          push    hl
1650++ 0920 F5                          push    af
1651++ 0921 21 27 09                    ld      hl,nsetcx_text
1652++ 0924             ;                call    print_debug
1653++ 0924 F1                          pop     af
1654++ 0925 E1                          pop     hl
1655++ 0926 C9                          ret
1656++ 0927 4E 53 45 54 nsetcx_text:    .db      "NSETCX",0
1656++ 092B 43 58 00 
1657++ 092E             
1658++ 092E             ;--------------------------------
1659++ 092E             ; $0126 GTASPC
1660++ 092E             ; Function : Gets screen relations
1661++ 092E             ; Output   : DE, HL
1662++ 092E             ; Registers: DE, HL
1663++ 092E             ; NOTE     : This implementation is still a stub!
1664++ 092E             gtaspc:
1665++ 092E E5                          push    hl
1666++ 092F F5                          push    af
1667++ 0930 21 36 09                    ld      hl,gtaspc_text
1668++ 0933             ;                call    print_debug
1669++ 0933 F1                          pop     af
1670++ 0934 E1                          pop     hl
1671++ 0935 C9                          ret
1672++ 0936 47 54 41 53 gtaspc_text:    .db      "GTASPC",0
1672++ 093A 50 43 00 
1673++ 093D             
1674++ 093D             ;--------------------------------
1675++ 093D             ; $0129 PNTINI
1676++ 093D             ; Function : Initalises the PAINT instruction
1677++ 093D             ; NOTE     : This implementation is still a stub!
1678++ 093D             pntini:
1679++ 093D E5                          push    hl
1680++ 093E F5                          push    af
1681++ 093F 21 45 09                    ld      hl,pntini_text
1682++ 0942             ;                call    print_debug
1683++ 0942 F1                          pop     af
1684++ 0943 E1                          pop     hl
1685++ 0944 C9                          ret
1686++ 0945 50 4E 54 49 pntini_text:    .db      "PNTINI",0
1686++ 0949 4E 49 00 
1687++ 094C             
1688++ 094C             ;--------------------------------
1689++ 094C             ; $012C SCANR
1690++ 094C             ; Function : Scans screenpixels to the right
1691++ 094C             ; NOTE     : This implementation is still a stub!
1692++ 094C             scanr:
1693++ 094C E5                          push    hl
1694++ 094D F5                          push    af
1695++ 094E 21 54 09                    ld      hl,scanr_text
1696++ 0951             ;                call    print_debug
1697++ 0951 F1                          pop     af
1698++ 0952 E1                          pop     hl
1699++ 0953 C9                          ret
1700++ 0954 53 43 41 4E scanr_text:     .db      "SCANR",0
1700++ 0958 52 00 
1701++ 095A             
1702++ 095A             ;--------------------------------
1703++ 095A             ; $012F SCANL
1704++ 095A             ; Function : Scans screenpixels to the left
1705++ 095A             ; NOTE     : This implementation is still a stub!
1706++ 095A             scanl:
1707++ 095A E5                          push    hl
1708++ 095B F5                          push    af
1709++ 095C 21 62 09                    ld      hl,scanl_text
1710++ 095F             ;                call    print_debug
1711++ 095F F1                          pop     af
1712++ 0960 E1                          pop     hl
1713++ 0961 C9                          ret
1714++ 0962 53 43 41 4E scanl_text:     .db      "SCANL",0
1714++ 0966 4C 00 
1715++ 0968             
1716++ 0968             ; vim:ts=8:expandtab:filetype=z8a:syntax=z8a:
0558+  0968             
0559+  0968             ;
0560+  0968             ;	AROUND 800 BYTES FREE HERE
0561+  0968             ;
0562+  0968             ;                
0563+  0968                             
0564+  0968             ; The game "Hacker" jumps directly to this location($0D02).
0565+  0968             ; Star force calls $0D0E.
0566+  0968             
0567+  0968                             .ds      $0D01 - $
0568+  0D01             ; for all wrong jumper,put RET instruction there
0569+  0D01 C9                          ret
0570+  0D02 DD E1                       pop     ix  ; $0D02
0571+  0D04 FD E1                       pop     iy
0572+  0D06 F1                          pop     af
0573+  0D07 C1                          pop     bc
0574+  0D08 D1                          pop     de
0575+  0D09 E1                          pop     hl
0576+  0D0A D9                          exx
0577+  0D0B 08                          ex      af,af'
0578+  0D0C F1                          pop     af
0579+  0D0D C1                          pop     bc
0580+  0D0E D1                          pop     de
0581+  0D0F E1                          pop     hl
0582+  0D10 FB                          ei
0583+  0D11 C9                          ret
0584+  0D12             
0585+  0D12             ; $0000 CHKRAM
0586+  0D12             ; Function : Tests RAM and sets RAM slot for the system
0587+  0D12             ; Registers: All
0588+  0D12             ; Remark   : After this, a jump must be made to INIT, for further initialisation.
0589+  0D12             chkram:
0590+  0D12 3E FD       		LD A,$FD
0591+  0D14 D3 9C       		OUT (VDP_ACR),A		; INITIALIZE ACR REGISTER FOR N8VEM HARDWARE
0592+  0D16                       
0593+  0D16             ;----------------------
0594+  0D16             ; User interface
0595+  0D16             ;----------------------
0596+  0D16             
0597+  0D16 21 00 F3                    ld      hl,$F300
0598+  0D19 F9                          ld      sp,hl           ; set $F300 to stack pointer
0599+  0D1A             
0600+  0D1A CD 8A 0D                    call    init_ram
0601+  0D1D             
0602+  0D1D CD 4A 07                    call    init_vdp
0603+  0D20             
0604+  0D20 FB                          ei
0605+  0D21             
0606+  0D21 CD 67 0F                    call    initio
0607+  0D24             
0608+  0D24 3E 0F                       ld      a,15
0609+  0D26 32 E9 F3                    ld      (FORCLR),a
0610+  0D29 3E 05                       ld      a,5
0611+  0D2B 32 EA F3                    ld      (BAKCLR),a
0612+  0D2E 32 EB F3                    ld      (BDRCLR),a
0613+  0D31 3E 1D                       ld      a,29
0614+  0D33 32 AF F3                    ld      (LINL32),a
0615+  0D36 CD BF 03                    call    init32
0616+  0D39             
0617+  0D39 21 07 24                    ld      hl,str_proginfo
0618+  0D3C CD AD 0E                    call    prn_text
0619+  0D3F             
0620+  0D3F CD 5D 0D                    call    search_roms
0621+  0D42 CD DA FE                    call    H_STKE
0622+  0D45             
0623+  0D45                             ; Set up hooks and system vars so NMS8250 disk ROM will try
0624+  0D45                             ; to load and execute the boot sector.
0625+  0D45 3E 01                       ld      a,1
0626+  0D47 32 99 FD                    ld      (DEVICE),a
0627+  0D4A AF                          xor     a
0628+  0D4B                             ; TODO: Find out or invent name for $FB29.
0629+  0D4B 32 29 FB                    ld      ($FB29),a
0630+  0D4E             
0631+  0D4E                             ; This is the hook the disk ROM uses for booting.
0632+  0D4E CD CB FE                    call    H_RUNC
0633+  0D51             
0634+  0D51 CD 6C 00                    CALL	$006C
0635+  0D54 CD 78 00                    CALL	$0078
0636+  0D57 CD C3 00                    CALL	$00C3
0637+  0D5A             
0638+  0D5A C3 BB 29                    JP	STARTBASIC
0639+  0D5D                             
0640+  0D5D             ;                ld      hl,str_nocart
0641+  0D5D             ;                call    prn_text
0642+  0D5D             
0643+  0D5D              ;               jp      hang_up_mode
0644+  0D5D             
0645+  0D5D             
0646+  0D5D             
0647+  0D5D             ;----------------------
0648+  0D5D             ; Search for any extension ROMs and initialize them.
0649+  0D5D             search_roms:
0650+  0D5D ED 5B 00 80                 LD      DE,($8000)
0651+  0D61 21 41 42                    ld      hl,$4241        ; "AB"
0652+  0D64 CD 3D 0F                    call    dcompr          ; ZF is set if the ROM is present.
0653+  0D67 CA 78 0D                    jp      z,search_roms_8k
0654+  0D6A ED 5B 00 40                 LD      DE,($4000)
0655+  0D6E 21 41 42                    ld      hl,$4241        ; "AB"
0656+  0D71 CD 3D 0F                    call    dcompr          ; ZF is set if the ROM is present.
0657+  0D74 CA 81 0D                    jp      z,search_roms_4k
0658+  0D77 C9                          ret
0659+  0D78             search_roms_8k:
0660+  0D78 3A 02 80                   LD      A,($8002)
0661+  0D7B 6F                         LD      L,A             
0662+  0D7C 3A 03 80                   LD      A,($8003)
0663+  0D7F 67                         LD      H,A
0664+  0D80 E9                         JP      (HL)            
0665+  0D81             search_roms_4k:
0666+  0D81 3A 02 40                   LD      A,($4002)
0667+  0D84 6F                         LD      L,A             
0668+  0D85 3A 03 40                   LD      A,($4003)
0669+  0D88 67                         LD      H,A
0670+  0D89 E9                         JP      (HL)            
0671+  0D8A             
0672+  0D8A             ;
0673+  0D8A             ;		LD	HL,$0000
0674+  0D8A             ;		LD	A,%00000101
0675+  0D8A             ;		CALL	rdslt		
0676+  0D8A             ;		LD	E,A
0677+  0D8A             ;		LD	HL,$0001
0678+  0D8A             ;		LD	A,%00000101
0679+  0D8A             ;		CALL	rdslt
0680+  0D8A             ;		LD	D,A
0681+  0D8A             ;		CALL	search_roms_check
0682+  0D8A             ;		JP	Z,search_roms_FOUND_P1
0683+  0D8A             ;		LD	HL,$0000
0684+  0D8A             ;		LD	A,%00000110
0685+  0D8A             ;		CALL	rdslt		
0686+  0D8A             ;		LD	E,A
0687+  0D8A             ;		LD	HL,$0001
0688+  0D8A             ;		LD	A,%00000110
0689+  0D8A             ;		CALL	rdslt
0690+  0D8A             ;		LD	D,A
0691+  0D8A             ;		CALL	search_roms_check
0692+  0D8A             ;		JP	Z,search_roms_FOUND_P2
0693+  0D8A             ;		RET
0694+  0D8A             ;s;earch_roms_check:
0695+  0D8A             ;		LD	($8500),DE
0696+  0D8A             ;                ld      hl,$4241        ; "AB"
0697+  0D8A             ; ;               call    dcompr          ; ZF is set if the ROM is present.
0698+  0D8A             ;                ret
0699+  0D8A             ;search_roms_FOUND_P1:;
0700+  0D8A             ;		LD	HL,$0000
0701+  0D8A             ;		LD	BC,$8000
0702+  0D8A             ;		LD	DE,$4000
0703+  0D8A             ;search_roms_FOUND_P1_LOOP:	
0704+  0D8A             ;		LD	A,%00000101
0705+  0D8A             ;		CALL	rdslt
0706+  0D8A             ;		LD	(DE),A
0707+  0D8A             ;		INC	HL
0708+  0D8A             ;		INC	DE
0709+  0D8A             ;		DEC	BC
0710+  0D8A             ;		LD	A,B
0711+  0D8A             ;		CP	$00
0712+  0D8A             ;		JP	NZ,search_roms_FOUND_P1_LOOP
0713+  0D8A             ;		ADD	A,C
0714+  0D8A             ;		CP	$00
0715+  0D8A             ;		JP	NZ,search_roms_FOUND_P1_LOOP
0716+  0D8A             ;		LD	A,($4002)
0717+  0D8A             ;		LD	L,A		
0718+  0D8A             ;		LD	A,($4003)
0719+  0D8A             ;		LD	H,A
0720+  0D8A             ;		JP	(HL)		
0721+  0D8A             
0722+  0D8A             ;search_roms_FOUND_P2:
0723+  0D8A             ;		LD	HL,$0000
0724+  0D8A             ;		LD	BC,$4000
0725+  0D8A             ;		LD	DE,$8000
0726+  0D8A             ;search_roms_FOUND_P2_LOOP:	
0727+  0D8A             ;		LD	A,%00000110
0728+  0D8A             ;		CALL	rdslt
0729+  0D8A             ;		LD	(DE),A
0730+  0D8A             ;		INC	HL
0731+  0D8A             ;		INC	DE
0732+  0D8A             ;		DEC	BC
0733+  0D8A             ;		LD	A,B
0734+  0D8A             ;		CP	$00
0735+  0D8A             ;		JP	NZ,search_roms_FOUND_P2_LOOP
0736+  0D8A             ;		ADD	A,C
0737+  0D8A             ;		CP	$00
0738+  0D8A             ;		JP	NZ,search_roms_FOUND_P2_LOOP
0739+  0D8A             ;		LD	A,($8002)
0740+  0D8A             ;		LD	L,A		
0741+  0D8A             ;		LD	A,($8003)
0742+  0D8A             ;		LD	H,A
0743+  0D8A             ;		JP	(HL)		
0744+  0D8A             
0745+  0D8A             ;------------------------
0746+  0D8A             ; Initialize RAM
0747+  0D8A             
0748+  0D8A             init_ram:
0749+  0D8A             
0750+  0D8A             ; Initialize workarea
0751+  0D8A 3E 00                       ld      a,$00
0752+  0D8C 21 80 F3                    ld      hl,$F380
0753+  0D8F 77                          ld      (hl),a
0754+  0D90 11 81 F3                    ld      de,$F381
0755+  0D93 01 7D 0C                    ld      bc,$0C7D
0756+  0D96 ED B0                       ldir
0757+  0D98             
0758+  0D98             ; Initialize Disk work
0759+  0D98 3E C9                       ld      a,$C9
0760+  0D9A 21 00 F3                    ld      hl,$F300
0761+  0D9D 77                          ld      (hl),a
0762+  0D9E 11 01 F3                    ld      de,$F301
0763+  0DA1 01 7F 00                    ld      bc,$007F
0764+  0DA4 ED B0                       ldir
0765+  0DA6             
0766+  0DA6             ; initialize hook area with $C9 (assembler code for ret)
0767+  0DA6 3E C9                       ld      a,$C9           ; ret code
0768+  0DA8 21 9A FD                    ld      hl,H_KEYI
0769+  0DAB 77                          ld      (hl),a
0770+  0DAC 11 9B FD                    ld      de,H_KEYI+1
0771+  0DAF 01 4D 02                    ld      bc,$024D        ; shouldn't this be $0235 ?
0772+  0DB2 ED B0                       ldir
0773+  0DB4             
0774+  0DB4             ; Initialize key matrix
0775+  0DB4 3E FF                       ld      a,$FF
0776+  0DB6 21 DA FB                    ld      hl,OLDKEY
0777+  0DB9 77                          ld      (hl),a
0778+  0DBA 11 DB FB                    ld      de,OLDKEY+1
0779+  0DBD 01 15 00                    ld      bc,21
0780+  0DC0 ED B0                       ldir
0781+  0DC2             
0782+  0DC2             ; Initialize Key buffer
0783+  0DC2 3E 00                       ld      a,$00
0784+  0DC4 21 F0 FB                    ld      hl,KEYBUF
0785+  0DC7 77                          ld      (hl),a
0786+  0DC8 11 F1 FB                    ld      de,KEYBUF+1
0787+  0DCB 01 27 00                    ld      bc,39
0788+  0DCE ED B0                       ldir
0789+  0DD0             
0790+  0DD0             
0791+  0DD0             ; Set address pointer
0792+  0DD0 21 F0 FB                    ld      hl,KEYBUF
0793+  0DD3 22 F8 F3                    ld      (PUTPNT),hl
0794+  0DD6 22 FA F3                    ld      (GETPNT),hl
0795+  0DD9             
0796+  0DD9             ;                ld      hl,$8000
0797+  0DD9 D9                          exx
0798+  0DDA 22 48 FC                    ld      (BOTTOM),hl     ; Page1 and 2 is ROM,Page3 and 4 is RAM.
0799+  0DDD D9                          exx
0800+  0DDE             
0801+  0DDE                             ; I don't know exactly what is stored between $F168 and $F380,
0802+  0DDE                             ; but the disk ROM nee.ds some space there, so I'll just
0803+  0DDE                             ; reserve all of it.
0804+  0DDE 21 80 F3                    ld      hl,$F380        ; was $F168, but nee.ds to be changed by disk ROM
0805+  0DE1 22 4A FC                    ld      (HIMEM),hl      ; limit of usable memory
0806+  0DE4 22 74 F6                    ld      (STKTOP),hl     ; position of BASIC stack
0807+  0DE7             
0808+  0DE7             
0809+  0DE7             ; Initialize table of screen 0
0810+  0DE7 21 00 00                    ld      hl,$0000
0811+  0DEA 22 B3 F3                    ld      (TXTNAM),hl
0812+  0DED 21 00 08                    ld      hl,$0800
0813+  0DF0 22 B7 F3                    ld      (TXTCGP),hl
0814+  0DF3             
0815+  0DF3             ; Initialize table of screen 1
0816+  0DF3 21 00 18                    ld      hl,$1800
0817+  0DF6 22 BD F3                    ld      (T32NAM),hl
0818+  0DF9 21 00 20                    ld      hl,$2000
0819+  0DFC 22 BF F3                    ld      (T32COL),hl
0820+  0DFF 21 00 00                    ld      hl,$0000
0821+  0E02 22 C1 F3                    ld      (T32CGP),hl
0822+  0E05 21 00 1B                    ld      hl,$1B00
0823+  0E08 22 C3 F3                    ld      (T32ATR),hl
0824+  0E0B 21 00 38                    ld      hl,$3800
0825+  0E0E 22 C5 F3                    ld      (T32PAT),hl
0826+  0E11             
0827+  0E11             ; Initialize table of screen 2
0828+  0E11             
0829+  0E11 21 00 18                    ld      hl,$1800
0830+  0E14 22 C7 F3                    ld      (GRPNAM),hl
0831+  0E17 21 00 20                    ld      hl,$2000
0832+  0E1A 22 C9 F3                    ld      (GRPCOL),hl
0833+  0E1D 21 00 00                    ld      hl,$0000
0834+  0E20 22 CB F3                    ld      (GRPCGP),hl
0835+  0E23 21 00 1B                    ld      hl,$1B00
0836+  0E26 22 CD F3                    ld      (GRPATR),hl
0837+  0E29 21 00 38                    ld      hl,$3800
0838+  0E2C 22 CF F3                    ld      (GRPPAT),hl
0839+  0E2F             
0840+  0E2F             ; Initialize table fo screen 3
0841+  0E2F 21 00 08                    ld      hl,$0800
0842+  0E32 22 D1 F3                    ld      (MLTNAM),hl
0843+  0E35 21 00 00                    ld      hl,$0000
0844+  0E38 22 D5 F3                    ld      (MLTCGP),hl
0845+  0E3B 21 00 1B                    ld      hl,$1B00
0846+  0E3E 22 D7 F3                    ld      (MLTATR),hl
0847+  0E41 21 00 38                    ld      hl,$3800
0848+  0E44 22 D9 F3                    ld      (MLTPAT),hl
0849+  0E47             
0850+  0E47             ; Initialise QUETAB.
0851+  0E47 21 59 F9                    ld      hl,QUETAB
0852+  0E4A 22 F3 F3                    ld      (QUEUES),hl
0853+  0E4D 21 75 F9                    ld      hl,VOICAQ
0854+  0E50 22 1A D8                    ld      ($FFFF &(QUETAB+0*6+4)),hl
0855+  0E53 21 F5 F9                    ld      hl,VOICBQ
0856+  0E56 22 20 D8                    ld      ($FFFF &(QUETAB+1*6+4)),hl
0857+  0E59 21 75 FA                    ld      hl,VOICCQ
0858+  0E5C 22 26 D8                    ld      ($FFFF &(QUETAB+2*6+4)),hl
0859+  0E5F 3E 7F                       ld      a,$7F
0860+  0E61 32 19 D8                    ld      ($FFFF &(QUETAB+0*6+3)),a
0861+  0E64 32 1F D8                    ld      ($FFFF &(QUETAB+1*6+3)),a
0862+  0E67 32 25 D8                    ld      ($FFFF &(QUETAB+2*6+3)),a
0863+  0E6A             
0864+  0E6A             ; other settings
0865+  0E6A 3E 27                       ld      a,39
0866+  0E6C 32 AE F3                    ld      (LINL40),a
0867+  0E6F 3E 20                       ld      a,32            ; Set to 29 after splash screen.
0868+  0E71 32 AF F3                    ld      (LINL32),a
0869+  0E74                             ;TODO: Rely on call to INIT32 instead.
0870+  0E74 3A AF F3                    ld      a,(LINL32)
0871+  0E77 32 B0 F3                    ld      (LINLEN),a
0872+  0E7A 3E 18                       ld      a,24
0873+  0E7C 32 B1 F3                    ld      (CRTCNT),a
0874+  0E7F             
0875+  0E7F 3E 04                       ld      a,$04
0876+  0E81 32 EB F3                    ld      (BDRCLR),a
0877+  0E84 32 EA F3                    ld      (BAKCLR),a
0878+  0E87 3E 0F                       ld      a,$0F
0879+  0E89 32 E9 F3                    ld      (FORCLR),a
0880+  0E8C             
0881+  0E8C 3E A0                       ld      a,$A0
0882+  0E8E 32 E0 F3                    ld      (RG1SAV),a
0883+  0E91             
0884+  0E91 3A C1 FC                    ld      a,(EXPTBL)
0885+  0E94 32 1F F9                    ld      (CGPNT),a
0886+  0E97 2A 04 00                    ld      hl,(4)
0887+  0E9A 22 20 F9                    ld      (CGPNT+1),hl
0888+  0E9D             
0889+  0E9D             ; set up hook
0890+  0E9D 3E C3                       ld      a,$c3
0891+  0E9F 21 C7 0F                    ld      hl,chput
0892+  0EA2 22 E5 FE                    ld      (H_OUTD+1),hl
0893+  0EA5 32 E4 FE                    ld      (H_OUTD),a
0894+  0EA8             
0895+  0EA8 C9                          ret
0896+  0EA9             
0897+  0EA9             
0898+  0EA9             ;------------------------
0899+  0EA9             ; wait routine
0900+  0EA9             ; caution,already EI when call the rouine
0901+  0EA9             ; B = frequency of loop
0902+  0EA9             wait_b:
0903+  0EA9 76                          halt
0904+  0EAA 10 FD                       djnz    wait_b
0905+  0EAC C9                          ret
0906+  0EAD             
0907+  0EAD             ;------------------------
0908+  0EAD             ;prn_text
0909+  0EAD             ; HL = string with null termination
0910+  0EAD             
0911+  0EAD             prn_text:
0912+  0EAD 3A AF FC                    ld      a,(SCRMOD)
0913+  0EB0 FE 05                       cp      5
0914+  0EB2 30 09                       jr      nc,prn_text_graph
0915+  0EB4             prn_text_char:
0916+  0EB4 7E                          ld      a,(hl)
0917+  0EB5 B7                          or      a
0918+  0EB6 C8                          ret     z
0919+  0EB7 CD C7 0F                    call    chput
0920+  0EBA 23                          inc     hl
0921+  0EBB 18 F7                       jr      prn_text_char
0922+  0EBD             prn_text_graph:
0923+  0EBD 7E                          ld      a,(hl)
0924+  0EBE B7                          or      a
0925+  0EBF C8                          ret     z
0926+  0EC0 DD 21 89 00                 ld      ix,$0089
0927+  0EC4 CD C3 17                    call    extrom
0928+  0EC7 23                          inc     hl
0929+  0EC8 18 F3                       jr      prn_text_graph
0930+  0ECA             
0931+  0ECA             ;--------------------------------
0932+  0ECA             ; Determine bytes per line in the current text mode.
0933+  0ECA             ; Input:   SCRMOD, LINLEN
0934+  0ECA             ; Output:  C = number of bytes per line
0935+  0ECA             ; Changes: AF
0936+  0ECA             text_bytes_per_line:
0937+  0ECA 0E 20                       ld      c,32            ; text32
0938+  0ECC 3A AF FC                    ld      a,(SCRMOD)
0939+  0ECF B7                          or      a
0940+  0ED0 C0                          ret     nz
0941+  0ED1 0E 28                       ld      c,40            ; text40
0942+  0ED3 3A B0 F3                    ld      a,(LINLEN)
0943+  0ED6 FE 29                       cp      41
0944+  0ED8 D8                          ret     c
0945+  0ED9 0E 50                       ld      c,80            ; text80
0946+  0EDB C9                          ret
0947+  0EDC             
0948+  0EDC             ;--------------------------------
0949+  0EDC             ; Calculate the VRAM address that correspon.ds to the current cursor position.
0950+  0EDC             ; Input:   CSRX, CSRY
0951+  0EDC             ; Output:  HL = VRAM address
0952+  0EDC             ; Changes: none
0953+  0EDC             curs2hl:
0954+  0EDC C5                          push    bc
0955+  0EDD F5                          push    af
0956+  0EDE             
0957+  0EDE CD CA 0E                    call    text_bytes_per_line
0958+  0EE1             
0959+  0EE1                             ; Calculate left border.
0960+  0EE1 3A B0 F3                    ld      a,(LINLEN)
0961+  0EE4 ED 44                       neg
0962+  0EE6 81                          add     a,c             ; A = bytes_per_line - LINLEN
0963+  0EE7 3C                          inc     a               ; round up
0964+  0EE8 CB 3F                       srl     a               ; A = A / 2
0965+  0EEA 6F                          ld      l,a             ; L = size of left border
0966+  0EEB             
0967+  0EEB                             ; Add X coordinate.
0968+  0EEB 3A DD F3                    ld      a,(CSRX)
0969+  0EEE 3D                          dec     a               ; from 1-based to 0-based
0970+  0EEF 85                          add     a,l             ; add border size
0971+  0EF0 6F                          ld      l,a
0972+  0EF1             
0973+  0EF1                             ; Convert to 16-bits counters.
0974+  0EF1 26 00                       ld      h,0
0975+  0EF3 44                          ld      b,h
0976+  0EF4             
0977+  0EF4                             ; Add Y * bytes_per_line.
0978+  0EF4 3A DC F3                    ld      a,(CSRY)
0979+  0EF7 3D                          dec     a               ; from 1-based to 0-based
0980+  0EF8             curs2hl_mult_loop:
0981+  0EF8 CB 3F                       srl     a
0982+  0EFA 30 01                       jr      nc,curs2hl_mult_skip
0983+  0EFC 09                          add     hl,bc
0984+  0EFD             curs2hl_mult_skip:
0985+  0EFD CB 21                       sla     c               ; BC = BC * 2
0986+  0EFF CB 10                       rl      b
0987+  0F01 B7                          or      a
0988+  0F02 20 F4                       jr      nz,curs2hl_mult_loop
0989+  0F04             
0990+  0F04                             ; Add base address.
0991+  0F04 ED 4B 22 F9                 ld      bc,(NAMBAS)
0992+  0F08 09                          add     hl,bc
0993+  0F09             
0994+  0F09 F1                          pop     af
0995+  0F0A C1                          pop     bc
0996+  0F0B C9                          ret
0997+  0F0C             
0998+  0F0C             
0999+  0F0C             ;---------------------------
1000+  0F0C             ; Subroutines
1001+  0F0C             ;---------------------------
1002+  0F0C             
1003+  0F0C             ; the extensive descriptions were taken with permission from http://map.tni.nl/
1004+  0F0C             
1005+  0F0C             ;-------------------------------------
1006+  0F0C             ;0008h SYNCHR
1007+  0F0C             ;Function:  tests whether the character of [HL] is the specified character
1008+  0F0C             ;           if not, it generates SYNTAX ERROR, otherwise it goes to CHRGTR
1009+  0F0C             ;           (#0010)
1010+  0F0C             ;Input:     set the character to be tested in [HL] and the character to be
1011+  0F0C             ;           compared next to RST instruction which calls this routine (inline
1012+  0F0C             ;           parameter)
1013+  0F0C             ;Output:    HL is increased by one and A receives [HL], When the tested character
1014+  0F0C             ;           is numerical, the CY flag is set the end of the statement (00h or
1015+  0F0C             ;           3Ah) causes the Z flag to be set
1016+  0F0C             ;Registers: AF, HL
1017+  0F0C             ;NOTE: this implementation is still a stub!
1018+  0F0C             synchr:
1019+  0F0C E5                          push    hl
1020+  0F0D F5                          push    af
1021+  0F0E 21 14 0F                    ld      hl,synchr_text
1022+  0F11             ;                call    print_debug
1023+  0F11 F1                          pop     af
1024+  0F12 E1                          pop     hl
1025+  0F13 C9                          ret
1026+  0F14 53 59 4E 43 synchr_text:    .db      "SYNCHR",0
1026+  0F18 48 52 00 
1027+  0F1B             
1028+  0F1B             ;-------------------------------------
1029+  0F1B             ; $0010 CHRGTR
1030+  0F1B             ; Read the next program character.
1031+  0F1B             ; In:      HL = pointer to the program text
1032+  0F1B             ; Out:     A  = the next program character
1033+  0F1B             ;          HL = pointer to the next program character
1034+  0F1B             ;          ZF = set if it's the end of statement
1035+  0F1B             ;          CF = set if it's a number
1036+  0F1B             ; Changes: AF, HL
1037+  0F1B             chrgtr:
1038+  0F1B CD 48 FF                    call    H_CHRG
1039+  0F1E             chrgtr_lp:
1040+  0F1E 7E                          ld      a,(hl)
1041+  0F1F 23                          inc     hl
1042+  0F20                             ; Check for the end of statement.
1043+  0F20 FE 00                       cp      $00             ; end of line
1044+  0F22 C8                          ret     z
1045+  0F23 FE 3A                       cp      $3A             ; statement separator
1046+  0F25 C8                          ret     z
1047+  0F26                             ; Check for digits.
1048+  0F26 FE 30                       cp      '0'
1049+  0F28 38 03                       jr      c,chrgtr_no_digit
1050+  0F2A FE 3A                       cp      '9'+1
1051+  0F2C D8                          ret     c
1052+  0F2D             chrgtr_no_digit:
1053+  0F2D                             ; Skip whitespace.
1054+  0F2D FE 20                       cp      $20             ; space
1055+  0F2F 28 ED                       jr      z,chrgtr_lp
1056+  0F31 FE 09                       cp      $09             ; tab
1057+  0F33 28 E9                       jr      z,chrgtr_lp
1058+  0F35                             ; Otherwise it's a normal program character.
1059+  0F35 B7                          or      a               ; Clear CF and ZF.
1060+  0F36 C9                          ret
1061+  0F37             
1062+  0F37             ;-------------------------------------
1063+  0F37             ; $0018 OUTDO
1064+  0F37             ; Function : Output to current outputchannel (printer, diskfile, etc.)
1065+  0F37             ; Input    : A  - PRTFIL, PRTFLG
1066+  0F37             ; Remark   : Used in basic, in ML it's pretty difficult.
1067+  0F37             outdo:
1068+  0F37 F5                          push    af
1069+  0F38 CD E4 FE                    call    H_OUTD      ; H_OUTD does the real outputting
1070+  0F3B F1                          pop     af
1071+  0F3C C9                          ret
1072+  0F3D             
1073+  0F3D             ;--------------------------------
1074+  0F3D             ; $0020 DCOMPR
1075+  0F3D             ; Function : Compared HL to DE
1076+  0F3D             ; Output   : flags influenced like CP instruction
1077+  0F3D             ; Registers: A
1078+  0F3D             dcompr:
1079+  0F3D 7C                          ld      a,h
1080+  0F3E BA                          cp      d
1081+  0F3F C0                          ret     nz
1082+  0F40 7D                          ld      a,l
1083+  0F41 BB                          cp      e
1084+  0F42 C9                          ret
1085+  0F43             
1086+  0F43             ;--------------------------------
1087+  0F43             ; $0028 GETYPR
1088+  0F43             ; Function : Returns Type of DAC
1089+  0F43             ; Input    : VALTYP(F663)
1090+  0F43             ; Output   : C, Z, S
1091+  0F43             ;       C       Z       S       Type    VALTYP
1092+  0F43             ;       low     -       -       double  8
1093+  0F43             ;       high    high    low     string  3
1094+  0F43             ;       high    low     high    integer 2
1095+  0F43             ;       high    low     low     float   4
1096+  0F43             ; Registers: AF
1097+  0F43             ;NOTE: this implementation is still a stub!
1098+  0F43             getypr:
1099+  0F43 E5                          push    hl
1100+  0F44 F5                          push    af
1101+  0F45 21 4B 0F                    ld      hl,getypr_text
1102+  0F48             ;                call    print_debug
1103+  0F48 F1                          pop     af
1104+  0F49 E1                          pop     hl
1105+  0F4A C9                          ret
1106+  0F4B 47 45 54 59 getypr_text:    .db      "GETYPR",0
1106+  0F4F 50 52 00 
1107+  0F52             
1108+  0F52             ;--------------------------------
1109+  0F52             ; $0030 CALLF
1110+  0F52             callf:
1111+  0F52 08                          ex      af,af'
1112+  0F53 D9                          exx
1113+  0F54 E1                          pop     hl              ; Get data from return address.
1114+  0F55 7E                          ld      a,(hl)
1115+  0F56 23                          inc     hl
1116+  0F57 5E                          ld      e,(hl)
1117+  0F58 23                          inc     hl
1118+  0F59 56                          ld      d,(hl)
1119+  0F5A 23                          inc     hl
1120+  0F5B D5                          push    de              ; IX = call address
1121+  0F5C DD E1                       pop     ix
1122+  0F5E F5                          push    af              ; IY = slot
1123+  0F5F FD E1                       pop     iy
1124+  0F61 E5                          push    hl              ; Update return address.
1125+  0F62 08                          ex      af,af'
1126+  0F63 D9                          exx
1127+  0F64 C3 05 24                    jp      calslt          ; Perform inter-slot call.
1128+  0F67             
1129+  0F67             ;--------------------------------
1130+  0F67             ; $003B INITIO
1131+  0F67             ;Function:  Initialises the device
1132+  0F67             ;Registers: All
1133+  0F67             initio:
1134+  0F67~                            .IF KB_USE_PS2=1
1135+  0F67~            		call	KB_INITIALIZE
1136+  0F67             		.ENDIF
1137+  0F67 1E FF                       ld      e,$FF           ; strobe off, triggers on
1138+  0F69 3E 0F                       ld      a,$0F
1139+  0F6B CD 71 15                    call    wrtpsg
1140+  0F6E                             ; TODO: What else must be initialized here?
1141+  0F6E             
1142+  0F6E C3 59 15                    jp      gicini
1143+  0F71             
1144+  0F71             ;--------------------------------
1145+  0F71             ; $003E INIFNK
1146+  0F71             ; Function : Initialises the contents of the function keys
1147+  0F71             ; Registers: All
1148+  0F71             ;NOTE: this implementation is still a stub!
1149+  0F71             inifnk:
1150+  0F71 E5                          push    hl
1151+  0F72 F5                          push    af
1152+  0F73 21 79 0F                    ld      hl,inifnk_text
1153+  0F76             ;                call    print_debug
1154+  0F76 F1                          pop     af
1155+  0F77 E1                          pop     hl
1156+  0F78 C9                          ret
1157+  0F79 49 4E 49 46 inifnk_text:    .db      "INIFNK",0
1157+  0F7D 4E 4B 00 
1158+  0F80             
1159+  0F80             ;--------------------------------
1160+  0F80             ; $0099 STRTMS
1161+  0F80             ; Function : Tests whether the PLAY statement is being executed as a background
1162+  0F80             ;            task. If not, begins to execute the PLAY statement
1163+  0F80             ; Registers: All
1164+  0F80             ;NOTE: this implementation is still a stub!
1165+  0F80             strtms:
1166+  0F80 E5                          push    hl
1167+  0F81 F5                          push    af
1168+  0F82 21 88 0F                    ld      hl,strtms_text
1169+  0F85             ;                call    print_debug
1170+  0F85 F1                          pop     af
1171+  0F86 E1                          pop     hl
1172+  0F87 C9                          ret
1173+  0F88 53 54 52 54 strtms_text:    .db      "STRTMS",0
1173+  0F8C 4D 53 00 
1174+  0F8F             
1175+  0F8F             
1176+  0F8F             ;--------------------------------
1177+  0F8F             ; $009C CHSNS
1178+  0F8F             ; Function : Tests the status of the keyboard buffer
1179+  0F8F             ; Output   : Z-flag set if buffer is filled
1180+  0F8F             ; Registers: AF
1181+  0F8F             chsns:
1182+  0F8F FB                          ei
1183+  0F90 E5                          push    hl
1184+  0F91 D5                          push    de
1185+  0F92 2A FA F3                    ld      hl,(GETPNT)
1186+  0F95 ED 5B F8 F3                 ld      de,(PUTPNT)
1187+  0F99 E7                          rst     20h
1188+  0F9A 3E FF                       ld      a,$ff
1189+  0F9C 20 01                       jr      nz,chsns_inbuf
1190+  0F9E AF                          xor     a
1191+  0F9F             chsns_inbuf:
1192+  0F9F D1                          pop     de
1193+  0FA0 E1                          pop     hl
1194+  0FA1 C9                          ret
1195+  0FA2             
1196+  0FA2             ;--------------------------------
1197+  0FA2             ; $009F CHGET
1198+  0FA2             ; Function : One character input (waiting)
1199+  0FA2             ; Output   : A  - ASCII-code of the input character
1200+  0FA2             ; Registers: AF
1201+  0FA2             
1202+  0FA2             chget:
1203+  0FA2 CD C2 FD                    call    H_CHGE
1204+  0FA5 E5                          push    hl
1205+  0FA6 D5                          push    de
1206+  0FA7             chget_wait:
1207+  0FA7 2A FA F3                    ld      hl,(GETPNT)
1208+  0FAA ED 5B F8 F3                 ld      de,(PUTPNT)
1209+  0FAE E7                          rst     20h
1210+  0FAF 20 04                       jr      nz,chget_char
1211+  0FB1 FB                          ei
1212+  0FB2 76                          halt
1213+  0FB3 18 F2                       jr      chget_wait
1214+  0FB5             chget_char:
1215+  0FB5 7E                          ld      a,(hl)          ; HL = (GETPNT)
1216+  0FB6 F5                          push    af
1217+  0FB7 23                          inc     hl
1218+  0FB8                             ; See comment in keyint (below label key_store).
1219+  0FB8 7D                          ld      a,l
1220+  0FB9                             ; Currently, tniASM doesn't support "&" and SjASM doesn't
1221+  0FB9                             ; support "AND", so we have to hardcode the result.
1222+  0FB9             ;                cp      $00FF & (KEYBUF + 40)
1223+  0FB9 FE 18                       cp      $18
1224+  0FBB 20 03                       jr      nz,chget_nowrap
1225+  0FBD 21 F0 FB                    ld      hl,KEYBUF
1226+  0FC0             chget_nowrap:
1227+  0FC0 22 FA F3                    ld      (GETPNT),hl
1228+  0FC3 F1                          pop     af
1229+  0FC4 D1                          pop     de
1230+  0FC5 E1                          pop     hl
1231+  0FC6 C9                          ret
1232+  0FC7             
1233+  0FC7             ;--------------------------------
1234+  0FC7             ; $00A2 CHPUT
1235+  0FC7             ; Input:   A = character code
1236+  0FC7             ; Changes: none
1237+  0FC7             
1238+  0FC7                             .include "chput.asm"
0001++ 0FC7             ; $Id: chput.asm 525 2008-12-22 22:16:42Z mthuurne $
0002++ 0FC7             ; CHPUT routine for C-BIOS
0003++ 0FC7             ;
0004++ 0FC7             ; Copyright (c) 2006 Eric Boon.  All rights reserved.
0005++ 0FC7             ;
0006++ 0FC7             ; Redistribution and use in source and binary forms, with or without
0007++ 0FC7             ; modification, are permitted provided that the following conditions
0008++ 0FC7             ; are met:
0009++ 0FC7             ; 1. Redistributions of source code must retain the above copyright
0010++ 0FC7             ;    notice, this list of conditions and the following disclaimer.
0011++ 0FC7             ; 2. Redistributions in binary form must reproduce the above copyright
0012++ 0FC7             ;    notice, this list of conditions and the following disclaimer in the
0013++ 0FC7             ;    documentation and/or other materials provided with the distribution.
0014++ 0FC7             ;
0015++ 0FC7             ; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
0016++ 0FC7             ; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
0017++ 0FC7             ; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
0018++ 0FC7             ; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
0019++ 0FC7             ; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
0020++ 0FC7             ; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0021++ 0FC7             ; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0022++ 0FC7             ; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0023++ 0FC7             ; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
0024++ 0FC7             ; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0025++ 0FC7             ;
0026++ 0FC7             ; -------------------------------------
0027++ 0FC7             ; $00A2 CHPUT
0028++ 0FC7             ; Function : Output character in A to screen
0029++ 0FC7             ; Input    : A = character code
0030++ 0FC7             ; Output   : -
0031++ 0FC7             ; Changes  : -
0032++ 0FC7             
0033++ 0FC7             chput:
0034++ 0FC7 E5                          push    hl                      ; save all regs
0035++ 0FC8 D5                          push    de
0036++ 0FC9 C5                          push    bc
0037++ 0FCA F5                          push    af
0038++ 0FCB CD A4 FD                    call    H_CHPU                  ; call hook
0039++ 0FCE 3A AF FC                    ld      a,(SCRMOD)              ; this only works in
0040++ 0FD1 FE 02                       cp      2                       ; screen modes 0 and 1
0041++ 0FD3 30 13                       jr      nc,chput_exit
0042++ 0FD5 F1                          pop     af                      ; restore char to put in A
0043++ 0FD6 F5                          push    af
0044++ 0FD7 CD 17 12                    call    chput_remove_cursor
0045++ 0FDA F1                          pop     af                      ; restore char to put in A
0046++ 0FDB F5                          push    af
0047++ 0FDC CD ED 0F                    call    chput_decode_char
0048++ 0FDF CD 2C 12                    call    chput_restore_cursor
0049++ 0FE2 3A DD F3                    ld      a,(CSRX)                ; CSRX -> TTYPOS
0050++ 0FE5 32 61 F6                    ld      (TTYPOS),a
0051++ 0FE8             chput_exit:
0052++ 0FE8 F1                          pop     af
0053++ 0FE9 C1                          pop     bc
0054++ 0FEA D1                          pop     de
0055++ 0FEB E1                          pop     hl
0056++ 0FEC C9                          ret
0057++ 0FED             
0058++ 0FED             ; -- decode character in A
0059++ 0FED             chput_decode_char:                              
0060++ 0FED CD 24 13                    call    cnvchr                  ; Graphic character?
0061++ 0FF0 D0                          ret     nc                      ; NC  -> graphic extension hdr
0062++ 0FF1 28 12                       jr      z,chput_putchar         ; C,Z -> graphic character
0063++ 0FF3 F5                          push    af                      ; (C,NZ -> normal char)
0064++ 0FF4 3A A7 FC                    ld      a,(ESCCNT)              ; ESC sequence?
0065++ 0FF7 B7                          or      a
0066++ 0FF8 C2 D0 10                    jp      nz,chput_escape
0067++ 0FFB F1                          pop     af
0068++ 0FFC FE 20                       cp      $20                     ; Control code?
0069++ 0FFE 38 2A                       jr      c,chput_ctrl_search
0070++ 1000 FE 7F                       cp      127                     ; DEL? 
0071++ 1002 CA 09 12                    jp      z,chput_erase
0072++ 1005                     
0073++ 1005             ; -- print a normal character and move cursor to next position
0074++ 1005             chput_putchar:
0075++ 1005 CD DC 0E                    call    curs2hl                 ; output character to screen
0076++ 1008 CD 4B 02                    call    wrtvrm
0077++ 100B                             
0078++ 100B 2A DC F3                    ld      hl,(CSRY)               ; h = (CSRX), l = (CSRY)
0079++ 100E 3A B0 F3                    ld      a,(LINLEN)
0080++ 1011 24                          inc     h
0081++ 1012 BC                          cp      h
0082++ 1013 38 04                       jr      c,chput_continue_line
0083++ 1015 22 DC F3                    ld      (CSRY),hl
0084++ 1018 C9                          ret
0085++ 1019             
0086++ 1019             chput_continue_line:
0087++ 1019 11 B1 FB                    ld      de,LINTTB-1             ; make logical line continue
0088++ 101C 26 00                       ld      h,0
0089++ 101E 19                          add     hl,de
0090++ 101F AF                          xor     a
0091++ 1020 77                          ld      (hl),a
0092++ 1021             
0093++ 1021 2A DC F3                    ld      hl,(CSRY)               ; move cursor to start of
0094++ 1024 CD 7F 10                    call    chput_ctrl_cr           ; new line
0095++ 1027 C3 41 10                    jp      chput_ctrl_lf
0096++ 102A             
0097++ 102A             ; -- Handle control code
0098++ 102A             chput_ctrl_search:
0099++ 102A 06 0C                       ld      b,12
0100++ 102C 21 9B 12                    ld      hl,chput_ctrl_table
0101++ 102F C3 08 02                    jp      search_table 
0102++ 1032             
0103++ 1032             ; -- Fill with spaces until next TAB stop
0104++ 1032             chput_ctrl_tab:
0105++ 1032 3E 20                       ld      a,$20
0106++ 1034 CD 05 10                    call    chput_putchar
0107++ 1037 3A DD F3                    ld      a,(CSRX)
0108++ 103A E6 07                       and     7
0109++ 103C FE 01                       cp      1
0110++ 103E 20 F2                       jr      nz,chput_ctrl_tab
0111++ 1040 C9                          ret
0112++ 1041             
0113++ 1041             ; -- Line Feed.
0114++ 1041             chput_ctrl_lf:
0115++ 1041 2A DC F3                    ld      hl,(CSRY)
0116++ 1044 3A B1 F3                    ld      a,(CRTCNT)
0117++ 1047 2C                          inc     l
0118++ 1048 BD                          cp      l
0119++ 1049 30 09                       jr      nc,chput_ctrl_lf_done
0120++ 104B             
0121++ 104B E5                          push    hl
0122++ 104C CD 58 10                    call    chput_ctrl_home         ; home cursor
0123++ 104F CD A3 11                    call    chput_esc_m             ; delete top line (scroll!)
0124++ 1052 E1                          pop     hl
0125++ 1053 2D                          dec     l
0126++ 1054             
0127++ 1054             chput_ctrl_lf_done:
0128++ 1054 22 DC F3                    ld      (CSRY),hl
0129++ 1057 C9                          ret
0130++ 1058             
0131++ 1058             ; -- Home cursor
0132++ 1058             chput_ctrl_home:
0133++ 1058             chput_esc_h:
0134++ 1058 21 01 01                    ld      hl,$0101
0135++ 105B 22 DC F3                    ld      (CSRY),hl
0136++ 105E C9                          ret
0137++ 105F             
0138++ 105F             ; -- Form Feed / Cls
0139++ 105F             chput_ctrl_ff:  .equ     cls
0140++ 105F             chput_esc_e:    .equ     cls
0141++ 105F             chput_esc_j:    .equ     cls
0142++ 105F             
0143++ 105F             ; -- Clear till end of screen
0144++ 105F             chput_esc_jj:
0145++ 105F CD 41 11                    call    chput_esc_k             ; clear till end of line
0146++ 1062 2A DC F3                    ld      hl,(CSRY)               ; save current cursor pos
0147++ 1065 E5                          push    hl
0148++ 1066 CD 7F 10                    call    chput_ctrl_cr           ; move to line start
0149++ 1069             chput_esc_jj_loop:
0150++ 1069 3A DC F3                    ld      a,(CSRY)                ; while no at end of screen
0151++ 106C 21 B1 F3                    ld      hl,CRTCNT
0152++ 106F BE                          cp      (hl)
0153++ 1070 30 08                       jr      nc,chput_esc_jj_done
0154++ 1072 CD 41 10                    call    chput_ctrl_lf           ;   move to next line
0155++ 1075 CD 41 11                    call    chput_esc_k             ;   clear till end of line
0156++ 1078 18 EF                       jr      chput_esc_jj_loop       ; loop
0157++ 107A             chput_esc_jj_done:
0158++ 107A E1                          pop     hl                      ; restore cursor pos
0159++ 107B 22 DC F3                    ld      (CSRY),hl
0160++ 107E C9                          ret
0161++ 107F                             
0162++ 107F             ; -- Carriage return
0163++ 107F             chput_ctrl_cr:
0164++ 107F 3E 01                       ld      a,1
0165++ 1081 32 DD F3                    ld      (CSRX),a
0166++ 1084 C9                          ret
0167++ 1085             
0168++ 1085             ; -- Escape
0169++ 1085             chput_ctrl_esc:
0170++ 1085 3E FF                       ld      a,$FF
0171++ 1087 32 A7 FC                    ld      (ESCCNT),a
0172++ 108A C9                          ret
0173++ 108B             
0174++ 108B             ; -- Cursor right
0175++ 108B             chput_ctrl_right:
0176++ 108B 3A DD F3                    ld      a,(CSRX)
0177++ 108E 21 B0 F3                    ld      hl,LINLEN
0178++ 1091 BE                          cp      (hl)
0179++ 1092 30 03                       jr      nc,chput_ctrl_right_next
0180++ 1094 3C                          inc     a
0181++ 1095 18 1F                       jr      chput_right_left_ok
0182++ 1097             chput_ctrl_right_next:
0183++ 1097 3A DC F3                    ld      a,(CSRY)
0184++ 109A 21 B1 F3                    ld      hl,CRTCNT
0185++ 109D BE                          cp      (hl)
0186++ 109E D0                          ret     nc
0187++ 109F 3C                          inc     a
0188++ 10A0 32 DC F3                    ld      (CSRY),a
0189++ 10A3 18 DA                       jr      chput_ctrl_cr
0190++ 10A5             
0191++ 10A5             ; -- Cursor left
0192++ 10A5             chput_ctrl_bs:
0193++ 10A5             chput_ctrl_left:
0194++ 10A5 3A DD F3                    ld      a,(CSRX)
0195++ 10A8 3D                          dec     a
0196++ 10A9 20 0B                       jr      nz,chput_right_left_ok
0197++ 10AB 3A DC F3                    ld      a,(CSRY)
0198++ 10AE 3D                          dec     a
0199++ 10AF C8                          ret     z
0200++ 10B0 32 DC F3                    ld      (CSRY),a
0201++ 10B3 3A B0 F3                    ld      a,(LINLEN)
0202++ 10B6             chput_right_left_ok:
0203++ 10B6 32 DD F3                    ld      (CSRX),a
0204++ 10B9 C9                          ret
0205++ 10BA                             
0206++ 10BA             ; -- Cursor up
0207++ 10BA             chput_ctrl_up:
0208++ 10BA             chput_esc_a:
0209++ 10BA 3A DC F3                    ld      a,(CSRY)
0210++ 10BD 3D                          dec     a
0211++ 10BE C8                          ret     z
0212++ 10BF 32 DC F3                    ld      (CSRY),a
0213++ 10C2 C9                          ret
0214++ 10C3             
0215++ 10C3             ; -- Cursor down
0216++ 10C3             chput_ctrl_down:
0217++ 10C3             chput_esc_b:
0218++ 10C3 3A DC F3                    ld      a,(CSRY)
0219++ 10C6 21 B1 F3                    ld      hl,CRTCNT
0220++ 10C9 BE                          cp      (hl)
0221++ 10CA D0                          ret     nc
0222++ 10CB 3C                          inc     a
0223++ 10CC 32 DC F3                    ld      (CSRY),a
0224++ 10CF C9                          ret
0225++ 10D0             
0226++ 10D0             ; -- Handle ESC mode (ESCCNT in A and != 0)
0227++ 10D0             chput_escape:
0228++ 10D0 47                          ld      b,a                     ; b := (ESCCNT)
0229++ 10D1 3C                          inc     a                       ; (ESCCNT) == -1 ?
0230++ 10D2 20 0C                       jr      nz,chput_escape_1
0231++ 10D4 32 A7 FC                    ld      (ESCCNT),a
0232++ 10D7 F1                          pop     af                        ; restore character in A 
0233++ 10D8 06 0F                       ld      b,15                    ; search in table
0234++ 10DA 21 BF 12                    ld      hl,chput_esc_table
0235++ 10DD C3 08 02                    jp      search_table
0236++ 10E0             
0237++ 10E0             chput_escape_1: ; ----------------------------
0238++ 10E0 F1                          pop     af
0239++ 10E1 10 04                       djnz    chput_escape_2
0240++ 10E3                             
0241++ 10E3                             ; -- ESCCNT == 1: 'ESC x <n>'
0242++ 10E3 0E 00                       ld      c,0                     ; CSTYLE/CSRSW := 0
0243++ 10E5 18 04                       jr      chput_esc_xy
0244++ 10E7             
0245++ 10E7             chput_escape_2: ; ----------------------------
0246++ 10E7 10 18                       djnz    chput_escape_3
0247++ 10E9             
0248++ 10E9                             ; -- ESCCNT == 2: 'ESC y <n>'
0249++ 10E9 0E 01                       ld      c,1                     ; CSTYLE/CSRSW := 1
0250++ 10EB             
0251++ 10EB             chput_esc_xy:
0252++ 10EB FE 34                       cp      '4'
0253++ 10ED 28 06                       jr      z,chput_esc_xy_4
0254++ 10EF FE 35                       cp      '5'
0255++ 10F1 28 08                       jr      z,chput_esc_xy_5
0256++ 10F3 18 2E                       jr      chput_escape_reset
0257++ 10F5             chput_esc_xy_4:
0258++ 10F5 79                          ld      a,c
0259++ 10F6 32 AA FC                    ld      (CSTYLE),a
0260++ 10F9 18 28                       jr      chput_escape_reset
0261++ 10FB             chput_esc_xy_5:
0262++ 10FB 79                          ld      a,c
0263++ 10FC 32 A9 FC                    ld      (CSRSW),a
0264++ 10FF 18 22                       jr      chput_escape_reset
0265++ 1101             
0266++ 1101             chput_escape_3: ; ----------------------------
0267++ 1101 10 08                       djnz    chput_escape_4
0268++ 1103             
0269++ 1103                             ; -- ESCCNT == 3: 'ESC Y <n> <m>'
0270++ 1103 06 1F                       ld      b,$1F
0271++ 1105 90                          sub     b
0272++ 1106 32 DD F3                    ld      (CSRX),a
0273++ 1109 18 18                       jr      chput_escape_reset
0274++ 110B             
0275++ 110B             chput_escape_4: ; ----------------------------
0276++ 110B 10 16                       djnz    chput_escape_reset
0277++ 110D             
0278++ 110D                             ; -- ESCCNT == 4: 'ESC Y <n>'
0279++ 110D 06 1F                       ld      b,$1F
0280++ 110F 90                          sub     b
0281++ 1110 32 DC F3                    ld      (CSRY),a
0282++ 1113 3E 03                       ld      a,3
0283++ 1115 18 0D                       jr      chput_escape_set
0284++ 1117             
0285++ 1117             ; -- ESCCNT := 1
0286++ 1117             chput_esc_x:
0287++ 1117 3E 01                       ld      a,1
0288++ 1119 18 09                       jr      chput_escape_set
0289++ 111B             
0290++ 111B             ; -- ESCCNT := 2
0291++ 111B             chput_esc_y:
0292++ 111B 3E 02                       ld      a,2
0293++ 111D 18 05                       jr      chput_escape_set
0294++ 111F             
0295++ 111F             ; -- ESCCNT := 4
0296++ 111F             chput_esc_yy:
0297++ 111F 3E 04                       ld      a,4
0298++ 1121 18 01                       jr      chput_escape_set
0299++ 1123             
0300++ 1123             chput_escape_reset:
0301++ 1123 AF                          xor     a
0302++ 1124             chput_escape_set:
0303++ 1124 32 A7 FC                    ld      (ESCCNT),a
0304++ 1127 C9                          ret
0305++ 1128             
0306++ 1128             ; -- Cursor right, no wrap
0307++ 1128             chput_esc_c:
0308++ 1128 3A DD F3                    ld      a,(CSRX)
0309++ 112B 21 B0 F3                    ld      hl,LINLEN
0310++ 112E BE                          cp      (hl)
0311++ 112F D0                          ret     nc
0312++ 1130 3C                          inc     a
0313++ 1131 32 DD F3                    ld      (CSRX),a
0314++ 1134 C9                          ret
0315++ 1135             
0316++ 1135             ; -- Cursor left, no wrap
0317++ 1135             chput_esc_d:
0318++ 1135 3A DD F3                    ld      a,(CSRX)
0319++ 1138 3D                          dec     a
0320++ 1139 C8                          ret     z
0321++ 113A 32 DD F3                    ld      (CSRX),a
0322++ 113D C9                          ret
0323++ 113E             
0324++ 113E             ; -- clear line
0325++ 113E             chput_esc_l:
0326++ 113E CD 7F 10                    call    chput_ctrl_cr
0327++ 1141             
0328++ 1141             ; -- Clear till end of line
0329++ 1141             chput_esc_k:
0330++ 1141 21 B1 FB                    ld      hl,LINTTB-1             ; update LINTTB
0331++ 1144 3A DC F3                    ld      a,(CSRY)
0332++ 1147 5F                          ld      e,a
0333++ 1148 16 00                       ld      d,0
0334++ 114A 19                          add     hl,de
0335++ 114B                             ; a != 0, which is OK
0336++ 114B 77                          ld      (hl),a
0337++ 114C                             
0338++ 114C 3A B0 F3                    ld      a,(LINLEN)
0339++ 114F 3C                          inc     a                       ; because CSRX is 1-based
0340++ 1150 21 DD F3                    ld      hl,CSRX
0341++ 1153 96                          sub     (hl)
0342++ 1154 4F                          ld      c,a
0343++ 1155 06 00                       ld      b,0
0344++ 1157 3E 20                       ld      a,32
0345++ 1159 CD DC 0E                    call    curs2hl
0346++ 115C C3 6B 02                    jp      filvrm
0347++ 115F                             
0348++ 115F             ; -- Insert line
0349++ 115F             chput_esc_ll:
0350++ 115F CD 7F 10                    call    chput_ctrl_cr           ; move to start of line
0351++ 1162 2A DC F3                    ld      hl,(CSRY)               ; save current cursor pos
0352++ 1165 E5                          push    hl
0353++ 1166 45                          ld      b,l
0354++ 1167 3A B1 F3                    ld      a,(CRTCNT)
0355++ 116A 32 DC F3                    ld      (CSRY),a
0356++ 116D 90                          sub     b
0357++ 116E 47                          ld      b,a
0358++ 116F 04                          inc     b
0359++ 1170 3A DC F3                    ld      a,(CSRY)
0360++ 1173 18 0E                       jr      chput_esc_ll_loop_end
0361++ 1175             
0362++ 1175             chput_esc_ll_loop:
0363++ 1175 CD DC 0E                    call    curs2hl
0364++ 1178 EB                          ex      de,hl
0365++ 1179 3D                          dec     a
0366++ 117A 32 DC F3                    ld      (CSRY),a
0367++ 117D CD DC 0E                    call    curs2hl
0368++ 1180 CD E1 11                    call    chput_copy_line
0369++ 1183             chput_esc_ll_loop_end:
0370++ 1183 10 F0                       djnz    chput_esc_ll_loop
0371++ 1185             
0372++ 1185 E1                          pop     hl                      ; restore cursor position
0373++ 1186 22 DC F3                    ld      (CSRY),hl
0374++ 1189 26 00                       ld      h,0
0375++ 118B 3A B1 F3                    ld      a,(CRTCNT)              ; update LINTTB
0376++ 118E 57                          ld      d,a                     ; DE := (CRTCNT)
0377++ 118F 1E 00                       ld      e,0
0378++ 1191 95                          sub     l                       ; BC := (CRTCNT) - (CSRY) - 1
0379++ 1192 3D                          dec     a
0380++ 1193 4F                          ld      c,a
0381++ 1194 06 00                       ld      b,0
0382++ 1196 21 B1 FB                    ld      hl,LINTTB-1             ; DE := LINTTB + (CRTCNT)
0383++ 1199 19                          add     hl,de
0384++ 119A EB                          ex      de,hl
0385++ 119B 62                          ld      h,d                     ; HL := DE - 1
0386++ 119C 6B                          ld      l,e
0387++ 119D 2B                          dec     hl                     
0388++ 119E ED B8                       lddr
0389++ 11A0 C3 41 11                    jp      chput_esc_k
0390++ 11A3             
0391++ 11A3             ; -- Delete line (and scroll rest up)
0392++ 11A3             chput_esc_m:
0393++ 11A3 CD 7F 10                    call    chput_ctrl_cr           ; move to start of line
0394++ 11A6 2A DC F3                    ld      hl,(CSRY)
0395++ 11A9 E5                          push    hl                      ; save cursor pos
0396++ 11AA 45                          ld      b,l
0397++ 11AB 3A B1 F3                    ld      a,(CRTCNT)
0398++ 11AE 90                          sub     b
0399++ 11AF 47                          ld      b,a
0400++ 11B0 04                          inc     b
0401++ 11B1 3A DC F3                    ld      a,(CSRY)
0402++ 11B4 18 0E                       jr      chput_esc_m_loop_end
0403++ 11B6             
0404++ 11B6             chput_esc_m_loop:
0405++ 11B6 CD DC 0E                    call    curs2hl                 ;   Copy 1 line:
0406++ 11B9 EB                          ex      de,hl                   ;     de = dest in VRAM
0407++ 11BA 3C                          inc     a                       ;     next line
0408++ 11BB 32 DC F3                    ld      (CSRY),a
0409++ 11BE CD DC 0E                    call    curs2hl                 ;     hl = src in VRAM
0410++ 11C1 CD E1 11                    call    chput_copy_line
0411++ 11C4             chput_esc_m_loop_end:
0412++ 11C4 10 F0                       djnz    chput_esc_m_loop        ; endloop
0413++ 11C6             
0414++ 11C6 CD 41 11                    call    chput_esc_k             ; clear till end of line
0415++ 11C9 E1                          pop     hl                      ; restore cursor position
0416++ 11CA 22 DC F3                    ld      (CSRY),hl
0417++ 11CD             
0418++ 11CD 26 00                       ld      h,0                     ; update LINTTB
0419++ 11CF 3A B1 F3                    ld      a,(CRTCNT)              ; BC := (CRTCNT) - (CRSY) - 1
0420++ 11D2 95                          sub     l                       
0421++ 11D3 3D                          dec     a
0422++ 11D4 4F                          ld      c,a
0423++ 11D5 06 00                       ld      b,0
0424++ 11D7 11 B1 FB                    ld      de,LINTTB-1             ; DE := LINTTB + (CSRY)
0425++ 11DA 19                          add     hl,de
0426++ 11DB 54                          ld      d,h
0427++ 11DC 5D                          ld      e,l
0428++ 11DD 23                          inc     hl                      ; HL := DE + 1
0429++ 11DE ED B0                       ldir
0430++ 11E0 C9                          ret
0431++ 11E1             
0432++ 11E1             ; -- Copy line: from HL to DE
0433++ 11E1             chput_copy_line:
0434++ 11E1 F5                          push    af
0435++ 11E2 C5                          push    bc
0436++ 11E3 06 00                       ld      b,0
0437++ 11E5 3A B0 F3                    ld      a,(LINLEN)
0438++ 11E8 4F                          ld      c,a
0439++ 11E9                             
0440++ 11E9~                    .IF MODEL_MSX != MODEL_MSX1
0441++ 11E9~                            cp      41
0442++ 11E9~                            jr      c,chput_copy_line_2
0443++ 11E9~                            ld      c,40
0444++ 11E9~                            call    chput_copy_line_copy
0445++ 11E9~                            ld      a,(LINLEN)
0446++ 11E9~                            sub     40
0447++ 11E9~                            ld      c,a
0448++ 11E9~            chput_copy_line_2:
0449++ 11E9                     .ENDIF
0450++ 11E9             
0451++ 11E9 CD EF 11                    call    chput_copy_line_copy
0452++ 11EC C1                          pop     bc
0453++ 11ED F1                          pop     af
0454++ 11EE C9                          ret
0455++ 11EF             
0456++ 11EF             chput_copy_line_copy:
0457++ 11EF E5                          push    hl
0458++ 11F0 D5                          push    de
0459++ 11F1 C5                          push    bc
0460++ 11F2 11 18 FC                    ld      de,LINWRK
0461++ 11F5 CD 80 02                    call    ldirmv
0462++ 11F8 C1                          pop     bc
0463++ 11F9 D1                          pop     de
0464++ 11FA D5                          push    de
0465++ 11FB C5                          push    bc
0466++ 11FC 21 18 FC                    ld      hl,LINWRK
0467++ 11FF CD 97 02                    call    ldirvm
0468++ 1202 C1                          pop     bc
0469++ 1203 E1                          pop     hl
0470++ 1204 09                          add     hl,bc
0471++ 1205 EB                          ex      de,hl
0472++ 1206 E1                          pop     hl
0473++ 1207 09                          add     hl,bc
0474++ 1208 C9                          ret
0475++ 1209             
0476++ 1209             ; -- Erase
0477++ 1209             chput_erase:
0478++ 1209 3A DD F3                    ld      a,(CSRX)
0479++ 120C FE 01                       cp      1
0480++ 120E C8                          ret     z
0481++ 120F 3E 20                       ld      a,32
0482++ 1211 CD 05 10                    call    chput_putchar
0483++ 1214 C3 A5 10                    jp      chput_ctrl_left
0484++ 1217             
0485++ 1217             ; -- disable cursor
0486++ 1217             chput_remove_cursor:
0487++ 1217 3A A9 FC                    ld      a,(CSRSW)               ; Cursor visible?
0488++ 121A FE 01                       cp      1
0489++ 121C C0                          ret     nz
0490++ 121D 3A AF FC                    ld      a,(SCRMOD)              ; Are we in text mode?
0491++ 1220 FE 02                       cp      2
0492++ 1222 D0                          ret     nc
0493++ 1223             
0494++ 1223 3A CC FB                    ld      a,(CURSAV)              ; get saved character
0495++ 1226 CD DC 0E                    call    curs2hl                 ; and drop it at the
0496++ 1229 C3 4B 02                    jp      wrtvrm
0497++ 122C             
0498++ 122C             ; -- enable cursor
0499++ 122C             chput_restore_cursor:
0500++ 122C 3A A9 FC                    ld      a,(CSRSW)               ; Cursor visible?
0501++ 122F FE 01                       cp      1
0502++ 1231 C0                          ret     nz
0503++ 1232 3A AF FC                    ld      a,(SCRMOD)
0504++ 1235 FE 02                       cp      2
0505++ 1237 D0                          ret     nc
0506++ 1238             
0507++ 1238 CD DC 0E                    call    curs2hl                 ; get character at cursor
0508++ 123B CD 45 02                    call    rdvrm                   ; and store at CURSAV
0509++ 123E 32 CC FB                    ld      (CURSAV),a
0510++ 1241                             
0511++ 1241 A7                          and     a                       ; reset carry
0512++ 1242 16 00                       ld      d,0                     ; de := 8 * a
0513++ 1244 5F                          ld      e,a
0514++ 1245 CB 13                       rl      e
0515++ 1247 CB 12                       rl      d
0516++ 1249 CB 13                       rl      e
0517++ 124B CB 12                       rl      d
0518++ 124D CB 13                       rl      e
0519++ 124F CB 12                       rl      d
0520++ 1251 AF                          xor     a                       ; get pattern table address
0521++ 1252 21 AF FC                    ld      hl,SCRMOD
0522++ 1255 BE                          cp      (hl)
0523++ 1256 20 05                       jr      nz,chput_restore_cursor_t32
0524++ 1258             
0525++ 1258 2A B7 F3                    ld      hl,(TXTCGP)
0526++ 125B 18 03                       jr      chput_restore_cursor_getpattern
0527++ 125D             
0528++ 125D             chput_restore_cursor_t32:
0529++ 125D 2A C1 F3                    ld      hl,(T32CGP)
0530++ 1260             
0531++ 1260             chput_restore_cursor_getpattern:
0532++ 1260 E5                          push    hl
0533++ 1261 19                          add     hl,de                   ; add offset of character
0534++ 1262 11 18 FC                    ld      de,LINWRK               ; copy pattern to LINWRK
0535++ 1265 01 08 00                    ld      bc,8
0536++ 1268 CD 80 02                    call    ldirmv
0537++ 126B             
0538++ 126B 3A AA FC                    ld      a,(CSTYLE)              ; depending on CSTYLE
0539++ 126E FE 00                       cp      0
0540++ 1270 20 07                       jr      nz,chput_restore_cursor_ins
0541++ 1272 21 18 FC                    ld      hl,LINWRK               ; invert the complete pattern
0542++ 1275 06 08                       ld      b,8
0543++ 1277 18 05                       jr      chput_restore_cursor_invert
0544++ 1279             chput_restore_cursor_ins:
0545++ 1279 21 1E FC                    ld      hl,LINWRK+6             ; or only the lower 2 lines
0546++ 127C 06 02                       ld      b,2
0547++ 127E             
0548++ 127E             chput_restore_cursor_invert:
0549++ 127E 7E                          ld      a,(hl)                  ; invert!
0550++ 127F 2F                          cpl
0551++ 1280 77                          ld      (hl),a
0552++ 1281 23                          inc     hl
0553++ 1282 10 FA                       djnz    chput_restore_cursor_invert
0554++ 1284 E1                          pop     hl                      ; copy inverted pattern to
0555++ 1285 11 F8 07                    ld      de,255*8                ; pattern 255
0556++ 1288 19                          add     hl,de
0557++ 1289 EB                          ex      de,hl
0558++ 128A 21 18 FC                    ld      hl,LINWRK
0559++ 128D 01 08 00                    ld      bc,8
0560++ 1290 CD 97 02                    call    ldirvm
0561++ 1293             
0562++ 1293 CD DC 0E                    call    curs2hl                 ; place char 255 at cursor pos
0563++ 1296 3E FF                       ld      a,255
0564++ 1298 C3 4B 02                    jp      wrtvrm
0565++ 129B             
0566++ 129B             ; -- Control character search table
0567++ 129B             chput_ctrl_table:
0568++ 129B 07                          .db      7
0569++ 129C 93 14                       .dw      beep ; chput_ctrl_beep
0570++ 129E 08                          .db      8
0571++ 129F A5 10                       .dw      chput_ctrl_bs
0572++ 12A1 09                          .db      9
0573++ 12A2 32 10                       .dw      chput_ctrl_tab
0574++ 12A4 0A                          .db      10
0575++ 12A5 41 10                       .dw      chput_ctrl_lf
0576++ 12A7 0B                          .db      11
0577++ 12A8 58 10                       .dw      chput_ctrl_home
0578++ 12AA 0C                          .db      12
0579++ 12AB AC 07                       .dw      chput_ctrl_ff
0580++ 12AD 0D                          .db      13
0581++ 12AE 7F 10                       .dw      chput_ctrl_cr
0582++ 12B0 1B                          .db      27
0583++ 12B1 85 10                       .dw      chput_ctrl_esc
0584++ 12B3 1C                          .db      28
0585++ 12B4 8B 10                       .dw      chput_ctrl_right
0586++ 12B6 1D                          .db      29
0587++ 12B7 A5 10                       .dw      chput_ctrl_left
0588++ 12B9 1E                          .db      30
0589++ 12BA BA 10                       .dw      chput_ctrl_up
0590++ 12BC 1F                          .db      31
0591++ 12BD C3 10                       .dw      chput_ctrl_down
0592++ 12BF             
0593++ 12BF             ; -- Escape character search table
0594++ 12BF             chput_esc_table:
0595++ 12BF 6A                          .db      'j'
0596++ 12C0 AC 07                       .dw      chput_esc_j
0597++ 12C2 45                          .db      'E'
0598++ 12C3 AC 07                       .dw      chput_esc_e
0599++ 12C5 4B                          .db      'K'
0600++ 12C6 41 11                       .dw      chput_esc_k
0601++ 12C8 4A                          .db      'J'
0602++ 12C9 5F 10                       .dw      chput_esc_jj
0603++ 12CB 6C                          .db      'l'
0604++ 12CC 3E 11                       .dw      chput_esc_l
0605++ 12CE 4C                          .db      'L'
0606++ 12CF 5F 11                       .dw      chput_esc_ll
0607++ 12D1 4D                          .db      'M'
0608++ 12D2 A3 11                       .dw      chput_esc_m
0609++ 12D4 59                          .db      'Y'
0610++ 12D5 1F 11                       .dw      chput_esc_yy
0611++ 12D7 41                          .db      'A'
0612++ 12D8 BA 10                       .dw      chput_esc_a
0613++ 12DA 42                          .db      'B'
0614++ 12DB C3 10                       .dw      chput_esc_b
0615++ 12DD 43                          .db      'C'
0616++ 12DE 28 11                       .dw      chput_esc_c
0617++ 12E0 44                          .db      'D'
0618++ 12E1 35 11                       .dw      chput_esc_d
0619++ 12E3 48                          .db      'H'
0620++ 12E4 58 10                       .dw      chput_esc_h
0621++ 12E6 78                          .db      'x'
0622++ 12E7 17 11                       .dw      chput_esc_x
0623++ 12E9 79                          .db      'y'
0624++ 12EA 1B 11                       .dw      chput_esc_y
0625++ 12EC             
0626++ 12EC             ; vim:ts=8:expandtab:filetype=z8a:syntax=z8a:
1239+  12EC             
1240+  12EC             ;--------------------------------
1241+  12EC             ; $00A5 LPTOUT
1242+  12EC             ; Function : Sen.ds one character to printer
1243+  12EC             ; Input    : A  - ASCII-code of character to send
1244+  12EC             ; Output   : C-flag set if failed
1245+  12EC             ; Registers: F
1246+  12EC             
1247+  12EC             lptout:
1248+  12EC CD B6 FF                    call    H_LPTO
1249+  12EF F5                          push    af
1250+  12F0             lptout_wait:
1251+  12F0 CD 71 14                    call    breakx
1252+  12F3 38 08                       jr      c,lptout_abort
1253+  12F5 CD 16 13                    call    lptstt
1254+  12F8 28 F6                       jr      z,lptout_wait
1255+  12FA F1                          pop     af
1256+  12FB 18 0C                       jr      lptout_write
1257+  12FD             
1258+  12FD             lptout_abort:
1259+  12FD 3E 0D                       ld      a,13
1260+  12FF CD 09 13                    call    lptout_write
1261+  1302 AF                          xor     a
1262+  1303 32 15 F4                    ld      (LPTPOS),a
1263+  1306 F1                          pop     af
1264+  1307 37                          scf
1265+  1308 C9                          ret
1266+  1309             
1267+  1309             lptout_write:
1268+  1309 F5                          push    af
1269+  130A D3 91                       out     (PRN_DATA),a
1270+  130C 3E 00                       ld      a,0
1271+  130E D3 90                       out     (PRN_STAT),a
1272+  1310 2F                          cpl
1273+  1311 D3 90                       out     (PRN_STAT),a
1274+  1313 F1                          pop     af
1275+  1314 A7                          and     a
1276+  1315 C9                          ret
1277+  1316             
1278+  1316             ;--------------------------------
1279+  1316             ; $00A8 LPTSTT
1280+  1316             ; Function : Tests printer status
1281+  1316             ; Output   : A  - #FF and Z-flag reset if printer is ready
1282+  1316             ;                 #00 and Z-flag set if not ready
1283+  1316             ; Registers: AF
1284+  1316             
1285+  1316             lptstt:
1286+  1316 CD BB FF                    call    H_LPTS
1287+  1319 DB 90                       in      a,(PRN_STAT)
1288+  131B 1F                          rra
1289+  131C 1F                          rra
1290+  131D 3E FF                       ld      a,$FF
1291+  131F 30 01                       jr      nc,lptstt_end
1292+  1321 2F                          cpl
1293+  1322             lptstt_end:
1294+  1322 A7                          and     a
1295+  1323 C9                          ret
1296+  1324             
1297+  1324             ;--------------------------------
1298+  1324             ; $00AB CNVCHR
1299+  1324             ; Function : tests for the graphic header and transforms the code
1300+  1324             ; Input    : A  - charactercode
1301+  1324             ;            GRPHED(FCA6): indicates if previous char was an extension code
1302+  1324             ; Output:                               C-flag  Z-flag  A
1303+  1324             ;       if byte is extension byte       low     high    1
1304+  1324             ;       if byte is normal ASCII         high    low     ASCII code
1305+  1324             ;       if byte is graphical extension  high    high    extension code
1306+  1324             ;       GRPHED is updated
1307+  1324             ; Registers: AF
1308+  1324             
1309+  1324             cnvchr:
1310+  1324 E5                          push    hl
1311+  1325 F5                          push    af
1312+  1326 21 A6 FC                    ld      hl,GRPHED
1313+  1329 AF                          xor     a
1314+  132A BE                          cp      (hl)
1315+  132B 77                          ld      (hl),a                  ; reset GRPHED in advance
1316+  132C 20 08                       jr      nz,cnvchr_handlegfx
1317+  132E             
1318+  132E F1                          pop     af                      ; we're not in graphic mode
1319+  132F FE 01                       cp      1                       ; graphic header?
1320+  1331 20 13                       jr      nz,cnvchr_normal
1321+  1333             
1322+  1333 77                          ld      (hl),a                  ; yes! -> Set GRPHED
1323+  1334 18 11                       jr      cnvchr_normal_exit      ; we've got NC and Z - perfect!
1324+  1336             
1325+  1336             cnvchr_handlegfx:
1326+  1336 F1                          pop     af
1327+  1337 FE 40                       cp      $40
1328+  1339 38 09                       jr      c,cnvchr_nogfx
1329+  133B FE 60                       cp      $60
1330+  133D 30 05                       jr      nc,cnvchr_nogfx
1331+  133F D6 40                       sub     $40                     ; graphic char
1332+  1341 BF                          cp      a                       ; set Z (and NC)
1333+  1342 18 02                       jr      cnvchr_normal
1334+  1344             
1335+  1344             cnvchr_nogfx:
1336+  1344 FE 50                       cp      $50                     ; A is definitely not #50
1337+  1346                                                             ; so this sets NZ :-)
1338+  1346             cnvchr_normal:
1339+  1346 37                          scf                             ; NZ/Z already ok, now set C
1340+  1347             cnvchr_normal_exit:
1341+  1347 E1                          pop     hl
1342+  1348 C9                          ret
1343+  1349             
1344+  1349                             .include "inlin.asm"
0001++ 1349             ; $Id: inlin.asm 525 2008-12-22 22:16:42Z mthuurne $
0002++ 1349             ; INLIN/PINLIN/QINLIN routines for C-BIOS
0003++ 1349             ;
0004++ 1349             ; Copyright (c) 2007 Eric Boon.  All rights reserved.
0005++ 1349             ;
0006++ 1349             ; Redistribution and use in source and binary forms, with or without
0007++ 1349             ; modification, are permitted provided that the following conditions
0008++ 1349             ; are met:
0009++ 1349             ; 1. Redistributions of source code must retain the above copyright
0010++ 1349             ;    notice, this list of conditions and the following disclaimer.
0011++ 1349             ; 2. Redistributions in binary form must reproduce the above copyright
0012++ 1349             ;    notice, this list of conditions and the following disclaimer in the
0013++ 1349             ;    documentation and/or other materials provided with the distribution.
0014++ 1349             ;
0015++ 1349             ; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
0016++ 1349             ; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
0017++ 1349             ; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
0018++ 1349             ; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
0019++ 1349             ; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
0020++ 1349             ; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0021++ 1349             ; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0022++ 1349             ; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0023++ 1349             ; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
0024++ 1349             ; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0025++ 1349             ;
0026++ 1349             ;--------------------------------
0027++ 1349             ; $00AE PINLIN
0028++ 1349             ; Function : Stores in the specified buffer the character codes input
0029++ 1349             ;           until the return key or STOP key is pressed
0030++ 1349             ; Output   : HL - for the starting address of the buffer -1
0031++ 1349             ;            C-flag set when it ends with the STOP key
0032++ 1349             ; Registers: All
0033++ 1349             ; TODO: call H_PINL
0034++ 1349             pinlin:
0035++ 1349 CD DB FD                    call    H_PINL
0036++ 134C 3A AA F6                    ld      a,(AUTFLG)              ; If AUTO is active
0037++ 134F A7                          and     a
0038++ 1350 CA 67 13                    jp      z,inlin                 ; then start line input
0039++ 1353 3E 01                       ld      a,1                     ; else set cursor
0040++ 1355 32 DD F3                    ld      (CSRX),a                ;    to left border first
0041++ 1358 C3 67 13                    jp      inlin                   ;    and then start line input
0042++ 135B             
0043++ 135B             ;--------------------------------
0044++ 135B             ; $00B4 QINLIN
0045++ 135B             ; Function : Prints a questionmark and one space and continues with INLIN
0046++ 135B             ; Output   : HL - for the starting address of the buffer -1
0047++ 135B             ;            C-flag set when it ends with the STOP key
0048++ 135B             ; Registers: All
0049++ 135B             qinlin_prompt:
0050++ 135B 3F 20 00                    .db      "? ",0
0051++ 135E             qinlin:
0052++ 135E CD E0 FD                    call    H_QINL
0053++ 1361 21 5B 13                    ld      hl,qinlin_prompt
0054++ 1364 CD AD 0E                    call    prn_text
0055++ 1367                             ; continue with inlin
0056++ 1367             
0057++ 1367             ;--------------------------------
0058++ 1367             ; $00B1 INLIN
0059++ 1367             ; Function : Main line input routine
0060++ 1367             ; Output   : HL - for the starting address of the buffer -1
0061++ 1367             ;            C-flag set when it ends with the STOP key
0062++ 1367             ; Registers: All
0063++ 1367             
0064++ 1367             inlin:
0065++ 1367 DD 21 5E F5 		LD	IX,BUF			; RESET TO BEGINNING OF BUFFER
0066++ 136B 3E 00       		LD	A,0			;
0067++ 136D 32 60 F6    		LD	(ENDBUF),A		;
0068++ 1370             inlin_LOOP1:
0069++ 1370 2A DD F3                    ld      hl,(CSRX)               ; loads CSRX and CSRY
0070++ 1373 22 CA FB                    ld      (FSTPOS),hl             ; save in FSTPOS
0071++ 1376 11 B0 FB                    ld      de,LINTTB-2             ; break logical line
0072++ 1379 26 00                       ld      h,0                     ; above cursor pos
0073++ 137B 7D                          ld      a,l
0074++ 137C 19                          add     hl,de
0075++ 137D 77                          ld      (hl),a
0076++ 137E             inlin_loop:
0077++ 137E CD A2 0F                    call    chget                   ; get a character from the kbd
0078++ 1381             
0079++ 1381 FE 7F                       cp      $7F
0080++ 1383 CA 30 14                    jp      z,inlin_del
0081++ 1386 FE 20                       cp      $20
0082++ 1388 30 11                       jr      nc,inlin_printable
0083++ 138A             
0084++ 138A 06 14                       ld      b,20
0085++ 138C 21 31 14                    ld      hl,inlin_table
0086++ 138F CD 00 02                    call    jump_table
0087++ 1392                             
0088++ 1392 AF                          xor     a                       ; we just put out a ctrl char
0089++ 1393 32 A8 FC                    ld      (INSFLG),a              ; switch insert mode off
0090++ 1396 32 AA FC                    ld      (CSTYLE),a
0091++ 1399 18 E3                       jr      inlin_loop
0092++ 139B             
0093++ 139B             inlin_printable:                                ; else...
0094++ 139B F5                          push    af
0095++ 139C 3A A8 FC                    ld      a,(INSFLG)
0096++ 139F A7                          and     a
0097++ 13A0 C4 B8 13                    call    nz,inlin_insert
0098++ 13A3 F1                          pop     af                
0099++ 13A4 DD 77 00                    LD	(IX),A                                
0100++ 13A7 DD 23                       INC	IX  
0101++ 13A9 47                          LD	B,A
0102++ 13AA 3A 60 F6                    LD	A,(ENDBUF)                 
0103++ 13AD 3C                          INC	A
0104++ 13AE 32 60 F6                    LD	(ENDBUF),A
0105++ 13B1 CA 1B 14                    JP	Z,inlin_cr            
0106++ 13B4 78                          LD	A,B
0107++ 13B5 DF                          rst     18h
0108++ 13B6 18 B8                       jr      inlin_LOOP1
0109++ 13B8             ; ----------------------------------------------
0110++ 13B8             inlin_insert:
0111++ 13B8 CD 17 12                    call    chput_remove_cursor
0112++ 13BB 2A DC F3                    ld      hl,(CSRY)               ; save cursorpos
0113++ 13BE 22 BC F6                    ld      (TEMP2),hl
0114++ 13C1             
0115++ 13C1 3E 20                       ld      a,' '                   ; oldchar = space
0116++ 13C3 32 A7 F6                    ld      (TEMP),a
0117++ 13C6             
0118++ 13C6             inlin_insert_loop:                              ; REPEAT
0119++ 13C6 CD DC 0E                    call    curs2hl                 ;   get char under curpos
0120++ 13C9 CD 45 02                    call    rdvrm
0121++ 13CC             
0122++ 13CC FE 20                       cp      ' '                     ;   IF is space
0123++ 13CE 20 25                       jr      nz,inlin_insert_cont
0124++ 13D0             
0125++ 13D0 2A DC F3                    ld      hl,(CSRY)               ;   AND at end of line
0126++ 13D3 3A B0 F3                    ld      a,(LINLEN)
0127++ 13D6 BC                          cp      h
0128++ 13D7 20 1A                       jr      nz,inlin_insert_cont1
0129++ 13D9             
0130++ 13D9 26 00                       ld      h,0                     ;   AND logical line does
0131++ 13DB 11 B1 FB                    ld      de,LINTTB-1             ;     not continue
0132++ 13DE 19                          add     hl,de
0133++ 13DF 7E                          ld      a,(hl)
0134++ 13E0 B7                          or      a
0135++ 13E1 28 10                       jr      z,inlin_insert_cont1
0136++ 13E3             
0137++ 13E3 3A A7 F6                    ld      a,(TEMP)                ;   THEN
0138++ 13E6 CD DC 0E                    call    curs2hl
0139++ 13E9 CD 4B 02                    call    wrtvrm                  ;     put old char
0140++ 13EC 2A BC F6                    ld      hl,(TEMP2)              ;     restore cursor pos
0141++ 13EF 22 DC F3                    ld      (CSRY),hl
0142++ 13F2 C9                          ret
0143++ 13F3             
0144++ 13F3             inlin_insert_cont1:
0145++ 13F3 3E 20                       ld      a,' '
0146++ 13F5             inlin_insert_cont:
0147++ 13F5 F5                          push    af                      ;   ELSE
0148++ 13F6 3A A7 F6                    ld      a,(TEMP)                ;     put old char
0149++ 13F9 DF                          rst     18h
0150++ 13FA F1                          pop     af
0151++ 13FB 32 A7 F6                    ld      (TEMP),a                ;   oldchar = character read
0152++ 13FE 18 C6                       jr      inlin_insert_loop       ; ENDREP
0153++ 1400             
0154++ 1400             ; ----------------------------------------------
0155++ 1400             inlin_wback:
0156++ 1400 C9                          ret
0157++ 1401             
0158++ 1401             ; ----------------------------------------------
0159++ 1401             inlin_break:
0160++ 1401 37                          scf                             ; C
0161++ 1402 E1                          pop     hl                      ; do not return to INLIN
0162++ 1403 C9                          ret                             ; but to caller of INLIN
0163++ 1404             
0164++ 1404             ; ----------------------------------------------
0165++ 1404             inlin_clear:
0166++ 1404 C9                          ret
0167++ 1405             
0168++ 1405             ; ----------------------------------------------
0169++ 1405             inlin_wfwd:
0170++ 1405 C9                          ret
0171++ 1406             
0172++ 1406             ; ----------------------------------------------
0173++ 1406             inlin_bs:	
0174++ 1406 47          		LD	B,A
0175++ 1407 3A 60 F6                    LD	A,(ENDBUF)                 
0176++ 140A 3C                          INC	A
0177++ 140B 3D                          DEC	A
0178++ 140C C8                          RET	Z
0179++ 140D DD 2B       		DEC	IX
0180++ 140F 3A 60 F6                    LD	A,(ENDBUF)                 
0181++ 1412 3D                          DEC	A
0182++ 1413 32 60 F6                    LD	(ENDBUF),A
0183++ 1416 78                          LD	A,B
0184++ 1417 CD 18 00    		CALL	$0018
0185++ 141A C9                          ret
0186++ 141B             
0187++ 141B             ; ----------------------------------------------
0188++ 141B             inlin_cr:
0189++ 141B AF                          xor     a                       ; NZ, NC
0190++ 141C DD 77 00                    LD	(IX),A			; NULL TERM
0191++ 141F CD 17 12                    CALL	chput_remove_cursor	;
0192++ 1422 E1                          pop     hl                      ; do not return to INLIN
0193++ 1423 21 5E F5                    LD	HL,BUF			; RETURN BUFFER
0194++ 1426 C9                          ret
0195++ 1427             
0196++ 1427             ; ----------------------------------------------
0197++ 1427             inlin_end:
0198++ 1427 AF                          xor     a                       ; NZ, NC
0199++ 1428 E1                          pop     hl                      ; do not return to INLIN
0200++ 1429 21 5E F5                    LD	HL,BUF			; RETURN BUFFER
0201++ 142C C9                          ret                             ; but to caller of INLIN
0202++ 142D             
0203++ 142D             ; ----------------------------------------------
0204++ 142D             inlin_ins:
0205++ 142D C9                          ret
0206++ 142E             
0207++ 142E             ; ----------------------------------------------
0208++ 142E             inlin_clrlin:
0209++ 142E C9                          ret
0210++ 142F             
0211++ 142F             ; -- ESCAPE
0212++ 142F             inlin_esc:
0213++ 142F C9                          ret                             ; Do nothing
0214++ 1430             
0215++ 1430             ; -- DELETE
0216++ 1430             inlin_del:
0217++ 1430 C9                          ret
0218++ 1431             
0219++ 1431             ; -- Jump table. Control chars not handled in one of the routines above
0220++ 1431             ;    are simply forwarded to OUTDO
0221++ 1431             inlin_table:
0222++ 1431 18 00                       .dw      $0018                   ; @
0223++ 1433 18 00                       .dw      $0018                   ; A - 
0224++ 1435 00 14                       .dw      inlin_wback             ; B word back
0225++ 1437 01 14                       .dw      inlin_break             ; C stop, abort, quit
0226++ 1439 18 00                       .dw      $0018                   ; D
0227++ 143B 04 14                       .dw      inlin_clear             ; E: clear to end of line
0228++ 143D 05 14                       .dw      inlin_wfwd              ; F: word fwd
0229++ 143F 18 00                       .dw      $0018                   ; G
0230++ 1441 06 14                       .dw      inlin_bs                ; H BACKSP: erase char left
0231++ 1443 18 00                       .dw      $0018                   ; I
0232++ 1445 18 00                       .dw      $0018                   ; J
0233++ 1447 18 00                       .dw      $0018                   ; K
0234++ 1449 18 00                       .dw      $0018                   ; L
0235++ 144B 1B 14                       .dw      inlin_cr                ; M ENTER : confirm, yes, ok
0236++ 144D 27 14                       .dw      inlin_end               ; N to end of line
0237++ 144F 18 00                       .dw      $0018                   ; O
0238++ 1451 18 00                       .dw      $0018                   ; P
0239++ 1453 18 00                       .dw      $0018                   ; Q
0240++ 1455 2D 14                       .dw      inlin_ins               ; R INSERT: toggle insert mode
0241++ 1457 18 00                       .dw      $0018                   ; S
0242++ 1459 18 00                       .dw      $0018                   ; T
0243++ 145B 2E 14                       .dw      inlin_clrlin            ; U clear line
0244++ 145D 18 00                       .dw      $0018                   ; V
0245++ 145F 18 00                       .dw      $0018                   ; W
0246++ 1461 18 00                       .dw      $0018                   ; X
0247++ 1463 18 00                       .dw      $0018                   ; Y
0248++ 1465 18 00                       .dw      $0018                   ; Z
0249++ 1467 2F 14                       .dw      inlin_esc               ; ESCAPE: ignore
0250++ 1469 18 00                       .dw      $0018                   ; (28)
0251++ 146B 18 00                       .dw      $0018                   ; (29)
0252++ 146D 18 00                       .dw      $0018                   ; (30)
0253++ 146F 18 00                       .dw      $0018                   ; (31)
0254++ 1471             
0255++ 1471             ; vim:ts=8:expandtab:filetype=z8a:syntax=z8a:
1345+  1471             
1346+  1471             ;--------------------------------
1347+  1471             ; $00B7 BREAKX
1348+  1471             ; Tests status of CTRL-STOP.
1349+  1471             ; This routine reads the keyboard status from the hardware, so its result
1350+  1471             ; will be accurate even if interrupts have been disabled for a while.
1351+  1471             ; Output:  CF set if CTRL-STOP is pressed
1352+  1471             ; Changes: AF
1353+  1471             breakx:
1354+  1471 3A 1C F4    		LD	A,(BREAKFLAG)
1355+  1474 FE FF       		CP	$FF
1356+  1476 28 02       		JR	Z,BREAKX_1
1357+  1478             		
1358+  1478 3F          BREAKX_0:       CCF
1359+  1479 C9                          ret
1360+  147A             BREAKX_1:       
1361+  147A 3E 00       		LD	A,0
1362+  147C 32 1C F4    		LD	(BREAKFLAG),A
1363+  147F 37          		scf
1364+  1480 C9          		ret
1365+  1481             
1366+  1481             ;--------------------------------
1367+  1481             ; $00BA ISCNTC
1368+  1481             ; Function: Test status of STOP or CTRL-STOP; if BASIC is in a ROM (see BASROM),
1369+  1481             ;           then check for STOP or CTRL-STOP is not done. Otherways:
1370+  1481             ;       INTLFLG: 0 => no action
1371+  1481             ;       INTLFLG: 3 => CTRL-STOP pressed => break program, if "STOP-interrupts not on"??
1372+  1481             ;       INTLFLG: 4 => STOP pressed => wait in ISCNTC till stop pressed again
1373+  1481             ; Input: INTFLG, BASROM
1374+  1481             ; Registers: AF
1375+  1481             ; NOTE: this implementation is still a stub!
1376+  1481             iscntc:
1377+  1481 E5                          push    hl
1378+  1482 F5                          push    af
1379+  1483 21 89 14                    ld      hl,iscntc_text
1380+  1486             ;                call    print_debug
1381+  1486 F1                          pop     af
1382+  1487 E1                          pop     hl
1383+  1488 C9                          ret
1384+  1489 49 53 43 4E iscntc_text:    .db      "ISCNTC",0
1384+  148D 54 43 00 
1385+  1490             
1386+  1490             ;--------------------------------
1387+  1490             ; $00BD CKCNTC
1388+  1490             ; Function : Same as ISCNTC. used in Basic
1389+  1490             ckcntc:
1390+  1490 C3 81 14                    jp      iscntc
1391+  1493             
1392+  1493             ;--------------------------------
1393+  1493             ; $00C0 BEEP
1394+  1493             ; Function : play a short beep, and reset sound system via GICINI
1395+  1493             ; Registers: All
1396+  1493             ; NOTE: this implementation is still a stub!
1397+  1493             beep:
1398+  1493             ; Note: Called by CHPUT; if you need to change more regs than AF, HL, DE, BC
1399+  1493             ;       then update CHPUT.
1400+  1493 E5                          push    hl
1401+  1494 F5                          push    af
1402+  1495 21 9B 14                    ld      hl,beep_text
1403+  1498             ;                call    print_debug
1404+  1498 F1                          pop     af
1405+  1499 E1                          pop     hl
1406+  149A C9                          ret
1407+  149B 42 45 45 50 beep_text:      .db      "BEEP",0
1407+  149F 00 
1408+  14A0             
1409+  14A0             ;--------------------------------
1410+  14A0             ; $00C6 POSIT
1411+  14A0             ; Sets cursor position.
1412+  14A0             ; Input:   H = column
1413+  14A0             ;          L = row
1414+  14A0             ; Changes: AF
1415+  14A0             posit:
1416+  14A0                             ; Note: this works because CSRX == CSRY + 1
1417+  14A0 22 DC F3                    ld      (CSRY),hl
1418+  14A3 C9                          ret
1419+  14A4             
1420+  14A4             ;--------------------------------
1421+  14A4             ; $00C9 FNKSB
1422+  14A4             ; Tests whether the function key display is active (FNKFLG),
1423+  14A4             ; if so, displays them, otherwise erases them.
1424+  14A4             ; Input:   FNKFLG (#FBCE)
1425+  14A4             ; Changes: all
1426+  14A4             ; NOTE: This implementation is still a stub!
1427+  14A4             fnksb:
1428+  14A4 E5                          push    hl
1429+  14A5 F5                          push    af
1430+  14A6 21 AC 14                    ld      hl,fnksb_text
1431+  14A9             ;                call    print_debug
1432+  14A9 F1                          pop     af
1433+  14AA E1                          pop     hl
1434+  14AB C9                          ret
1435+  14AC 46 4E 4B 53 fnksb_text:     .db      "FNKSB",0
1435+  14B0 42 00 
1436+  14B2             
1437+  14B2             ;--------------------------------
1438+  14B2             ; $00CC ERAFNK
1439+  14B2             ; Erase function key display.
1440+  14B2             ; Changes: all
1441+  14B2             ; NOTE: This implementation is still a stub!
1442+  14B2             ; TODO: call H_ERAF
1443+  14B2             erafnk:
1444+  14B2             ;               call    H_ERAF
1445+  14B2 E5                          push    hl
1446+  14B3 F5                          push    af
1447+  14B4 21 BA 14                    ld      hl,erafnk_text
1448+  14B7             ;                call    print_debug
1449+  14B7 F1                          pop     af
1450+  14B8 E1                          pop     hl
1451+  14B9 C9                          ret
1452+  14BA 45 52 41 46 erafnk_text:    .db      "ERAFNK",0
1452+  14BE 4E 4B 00 
1453+  14C1             
1454+  14C1             ;--------------------------------
1455+  14C1             ; $00CF dsPFNK
1456+  14C1             ; Display function keys.
1457+  14C1             ; Changes: all
1458+  14C1             ; NOTE: This implementation is still a stub!
1459+  14C1             ; TODO: call H_dsPF
1460+  14C1             dspfnk:
1461+  14C1             ;               call    H_dsPF
1462+  14C1 E5                          push    hl
1463+  14C2 F5                          push    af
1464+  14C3 21 C9 14                    ld      hl,dspfnk_text
1465+  14C6             ;                call    print_debug
1466+  14C6 F1                          pop     af
1467+  14C7 E1                          pop     hl
1468+  14C8 C9                          ret
1469+  14C9 44 53 50 46 dspfnk_text:    .db      "DSPFNK",0
1469+  14CD 4E 4B 00 
1470+  14D0             
1471+  14D0             ;--------------------------------
1472+  14D0             ; $00D2 TOTEXT
1473+  14D0             ; Forces the screen to be in the text mode.
1474+  14D0             ; Input: SCRMOD, OLdsCR
1475+  14D0             ; Changes: all
1476+  14D0             totext:
1477+  14D0 3A AF FC                    ld      a,(SCRMOD)
1478+  14D3 FE 02                       cp      2
1479+  14D5 D8                          ret     c
1480+  14D6 3A B0 FC                    ld      a,(OLDSCR)
1481+  14D9 CD BD FD                    call    H_TOTE
1482+  14DC B7                          or      a
1483+  14DD CA 7F 03                    jp      z,initxt
1484+  14E0 C3 BF 03                    jp      init32
1485+  14E3             
1486+  14E3             ;--------------------------------
1487+  14E3             ; $00E1 TAPION
1488+  14E3             ; Rea.ds the header block after turning the cassette motor on.
1489+  14E3             ; Output:  CF = set if failed
1490+  14E3             ; Changes: all
1491+  14E3             ; NOTE: This implementation is still a stub!
1492+  14E3             tapion:
1493+  14E3 E5                          push    hl
1494+  14E4 F5                          push    af
1495+  14E5 21 EC 14                    ld      hl,tapion_text
1496+  14E8             ;                call    print_debug
1497+  14E8 F1                          pop     af
1498+  14E9 E1                          pop     hl
1499+  14EA                             ; TODO: not implemented -> always fail
1500+  14EA 37                          scf
1501+  14EB C9                          ret
1502+  14EC 54 41 50 49 tapion_text:    .db      "TAPION",0
1502+  14F0 4F 4E 00 
1503+  14F3             
1504+  14F3             ;--------------------------------
1505+  14F3             ; $00E4 TAPIN
1506+  14F3             ; Read data from the tape.
1507+  14F3             ; Output:  A = data read
1508+  14F3             ; Changes: all
1509+  14F3             ; NOTE: This implementation is still a stub!
1510+  14F3             tapin:
1511+  14F3 E5                          push    hl
1512+  14F4 F5                          push    af
1513+  14F5 21 FC 14                    ld      hl,tapin_text
1514+  14F8             ;                call    print_debug
1515+  14F8 F1                          pop     af
1516+  14F9 E1                          pop     hl
1517+  14FA                             ; TODO: not implemented -> always fail
1518+  14FA 37                          scf
1519+  14FB C9                          ret
1520+  14FC 54 41 50 49 tapin_text:     .db      "TAPIN",0
1520+  1500 4E 00 
1521+  1502             
1522+  1502             ;--------------------------------
1523+  1502             ; $00E7 TAPIOF
1524+  1502             ; Stops reading from the tape.
1525+  1502             ; NOTE: This implementation is still a stub!
1526+  1502             tapiof:
1527+  1502 E5                          push    hl
1528+  1503 F5                          push    af
1529+  1504 21 0A 15                    ld      hl,tapiof_text
1530+  1507             ;                call    print_debug
1531+  1507 F1                          pop     af
1532+  1508 E1                          pop     hl
1533+  1509 C9                          ret
1534+  150A 54 41 50 49 tapiof_text:    .db      "TAPIOF",0
1534+  150E 4F 46 00 
1535+  1511             
1536+  1511             ;--------------------------------
1537+  1511             ; $00EA TAPOON
1538+  1511             ; Turns on the cassette motor and writes the header.
1539+  1511             ; Input:   A  = zero for short header, non-zero for long header
1540+  1511             ; Output:  CF = set if failed
1541+  1511             ; Changes: all
1542+  1511             ; NOTE: This implementation is still a stub!
1543+  1511             tapoon:
1544+  1511 E5                          push    hl
1545+  1512 F5                          push    af
1546+  1513 21 1A 15                    ld      hl,tapoon_text
1547+  1516             ;                call    print_debug
1548+  1516 F1                          pop     af
1549+  1517 E1                          pop     hl
1550+  1518                             ; TODO: not implemented -> always fail
1551+  1518 37                          scf
1552+  1519 C9                          ret
1553+  151A 54 41 50 4F tapoon_text:    .db      "TAPOON",0
1553+  151E 4F 4E 00 
1554+  1521             
1555+  1521             ;--------------------------------
1556+  1521             ; $00ED TAPOUT
1557+  1521             ; Writes data to the tape.
1558+  1521             ; Input:   A  = data to write
1559+  1521             ; Output:  CF = set if failed
1560+  1521             ; Changes: all
1561+  1521             ; NOTE: This implementation is still a stub!
1562+  1521             tapout:
1563+  1521 E5                          push    hl
1564+  1522 F5                          push    af
1565+  1523 21 2A 15                    ld      hl,tapout_text
1566+  1526             ;                call    print_debug
1567+  1526 F1                          pop     af
1568+  1527 E1                          pop     hl
1569+  1528                             ; TODO: not implemented -> always fail
1570+  1528 37                          scf
1571+  1529 C9                          ret
1572+  152A 54 41 50 4F tapout_text:    .db      "TAPOUT",0
1572+  152E 55 54 00 
1573+  1531             
1574+  1531             ;--------------------------------
1575+  1531             ; $00F0 TAPOOF
1576+  1531             ; Stops writing on the tape.
1577+  1531             ; NOTE: This implementation is still a stub!
1578+  1531             tapoof:
1579+  1531 E5                          push    hl
1580+  1532 F5                          push    af
1581+  1533 21 39 15                    ld      hl,tapoof_text
1582+  1536             ;                call    print_debug
1583+  1536 F1                          pop     af
1584+  1537 E1                          pop     hl
1585+  1538 C9                          ret
1586+  1539 54 41 50 4F tapoof_text:    .db      "TAPOOF",0
1586+  153D 4F 46 00 
1587+  1540             
1588+  1540             ;--------------------------------
1589+  1540             ; $00F3 STMOTR
1590+  1540             ; Changes the cassette motor state.
1591+  1540             ; Input:   A = action: #00 stops motor, #01 starts motor,
1592+  1540             ;                      #FF inverts current state
1593+  1540             ; Changes: AF
1594+  1540             stmotr:
1595+  1540 C5                          push    bc
1596+  1541 47                          ld      b,a
1597+  1542 DB AA                       in      a,(GIO_REGS)
1598+  1544 04                          inc     b
1599+  1545 28 0C                       jr      z,stmotr_inv
1600+  1547 CB E7                       set     4,a
1601+  1549 05                          dec     b
1602+  154A 28 09                       jr      z,stmotr_set
1603+  154C CB A7                       res     4,a
1604+  154E 05                          dec     b
1605+  154F 28 04                       jr      z,stmotr_set
1606+  1551 C1                          pop     bc
1607+  1552 C9                          ret
1608+  1553             
1609+  1553 EE 10       stmotr_inv:     xor     16
1610+  1555 D3 AA       stmotr_set:     out     (GIO_REGS),a
1611+  1557 C1                          pop     bc
1612+  1558 C9                          ret
1613+  1559             
1614+  1559             ;--------------------------------
1615+  1559             ; $0090 GICINI  Initialize Sound IC
1616+  1559             ; Function : Initialises PSG and sets initial value for the PLAY statement
1617+  1559             ; Registers: All
1618+  1559             gicini:
1619+  1559 1E 00                       ld      e,$00
1620+  155B 3E 08                       ld      a,$08
1621+  155D CD 71 15                    call    wrtpsg
1622+  1560 3C                          inc     a
1623+  1561 CD 71 15                    call    wrtpsg
1624+  1564 3C                          inc     a
1625+  1565 CD 71 15                    call    wrtpsg
1626+  1568 3C                          inc     a
1627+  1569             
1628+  1569 1E B8                       ld      e,$B8
1629+  156B 3E 07                       ld      a,$07
1630+  156D CD 71 15                    call    wrtpsg
1631+  1570             
1632+  1570 C9                          ret
1633+  1571             
1634+  1571             ;--------------------------------
1635+  1571             ; $0093 WRTPSG
1636+  1571             ; Function : Writes data to PSG-register
1637+  1571             ; Input    : A  - PSG register number
1638+  1571             ;            E  - data write
1639+  1571             wrtpsg:
1640+  1571 F3                          di
1641+  1572 D3 9A                       out     (PSG_REGS),a
1642+  1574 F5                          push    af
1643+  1575 7B                          ld      a,e
1644+  1576 D3 9B                       out     (PSG_DATA),a
1645+  1578 FB                          ei
1646+  1579 F1                          pop     af
1647+  157A C9                          ret
1648+  157B             
1649+  157B             ;--------------------------------
1650+  157B             ; $0096 RDPSG
1651+  157B             ; Function : Rea.ds value from PSG-register
1652+  157B             ; Input    : A  - PSG-register read
1653+  157B             ; Output   : A  - value read
1654+  157B             rdpsg:
1655+  157B D3 9A                       out     (PSG_REGS),a
1656+  157D DB 9A                       in      a,(PSG_STAT)
1657+  157F C9                          ret
1658+  1580             
1659+  1580             ;--------------------------------
1660+  1580             ; $0135 CHGSND
1661+  1580             ; Write to the 1-bit sound port.
1662+  1580             ; Input:   A = zero to set sound state to 0, non-zero to set sound state to 1
1663+  1580             ; Changes: AF
1664+  1580             chgsnd:
1665+  1580 B7                          or      a
1666+  1581 3E 0E                       ld      a,$0E           ; $0E = command to reset bit 7
1667+  1583 28 01                       jr      z,chgsnd_write
1668+  1585 3C                          inc     a               ; $0F = command to set bit 7
1669+  1586             chgsnd_write:
1670+  1586 D3 AB                       out     (PPI_REGS),a    ; set/reset bit of port C
1671+  1588 C9                          ret
1672+  1589             
1673+  1589             ;--------------------------------
1674+  1589             ; $0138 RSLREG
1675+  1589             ; Function : Reads the primary slot register
1676+  1589             ; Output   : A  - for the value which was read
1677+  1589             ;            33221100
1678+  1589             ;            ||||||- Pagina 0 (#0000-#3FFF)
1679+  1589             ;            ||||--- Pagina 1 (#4000-#7FFF)
1680+  1589             ;            ||----- Pagina 2 (#8000-#BFFF)
1681+  1589             ;            ------- Pagina 3 (#C000-#FFFF)
1682+  1589             ; Registers: A
1683+  1589             rslreg:
1684+  1589 DB A8                       in      a,(PSL_STAT)
1685+  158B C9                          ret
1686+  158C             
1687+  158C             ;--------------------------------
1688+  158C             ; $013B WSLREG
1689+  158C             ; Function : Writes value to the primary slot register
1690+  158C             ; Input    : A  - value value to (see RSLREG)
1691+  158C             wslreg:
1692+  158C D3 A8                       out     (PSL_STAT),a
1693+  158E C9                          ret
1694+  158F             
1695+  158F             ;--------------------------------
1696+  158F             ; $013E RDVDP
1697+  158F             ; Function : Reads VDP status register
1698+  158F             ; Output   : A  - Value which was read
1699+  158F             ; Registers: A
1700+  158F             rdvdp:
1701+  158F DB 99                       in      a,(VDP_STAT)
1702+  1591 C9                          ret
1703+  1592             
1704+  1592             ;--------------------------------
1705+  1592             ;0141h SNSMAT
1706+  1592             ; Function : Returns the value of the specified line from the keyboard matrix
1707+  1592             ; Input    : A  - for the specified line
1708+  1592             ; Output   : A  - for data (the bit corresponding to the pressed key will be 0)
1709+  1592             ; Registers: AF
1710+  1592             snsmat:
1711+  1592 3E FF       		LD	A,$FF
1712+  1594 C9          		RET
1713+  1595             
1714+  1595             ;--------------------------------
1715+  1595             ; $0144 PHYDIO
1716+  1595             ; Executes I/O for mass-storage media like diskettes.
1717+  1595             ; All this routine does is call H_PHYD, which should be installed by the main
1718+  1595             ; disk ROM.
1719+  1595             ; Input:     B  = number of sectors to save/load
1720+  1595             ;            C  = media ID of the disk
1721+  1595             ;            DE = begin sector
1722+  1595             ;            HL = begin address in memory
1723+  1595             ; Changes:   all
1724+  1595             ; Remark:    Before the call is called, the Z-flag must be reset, and the
1725+  1595             ;            execution address which was in HL must be at the last stack address
1726+  1595             phydio:
1727+  1595 CD A7 FF                    call    H_PHYD
1728+  1598 C9                          ret
1729+  1599             
1730+  1599             ;--------------------------------
1731+  1599             ; $0147 FORMAT
1732+  1599             ; Initialises mass-storage media like formatting of diskettes.
1733+  1599             ; All this routine does is call H_FORM, which should be installed by the main
1734+  1599             ; disk ROM.
1735+  1599             ; Changes:   all
1736+  1599             format:
1737+  1599 CD AC FF                    call    H_FORM
1738+  159C C9                          ret
1739+  159D             
1740+  159D             ;--------------------------------
1741+  159D             ; $014A ISFLIO
1742+  159D             ; Function : Tests if I/O to device is taking place
1743+  159D             ; Output   : A  - #00 if not taking place
1744+  159D             ;             not #00 if taking place
1745+  159D             ; Registers: AF
1746+  159D             ; TODO: call H_ISFL
1747+  159D             isflio:
1748+  159D             ;                call    H_ISFL
1749+  159D 3A 64 F8                    ld      a,(PTRFIL)
1750+  15A0 A7                          and     a               ; adjust flags
1751+  15A1 C9                          ret
1752+  15A2             
1753+  15A2             ;--------------------------------
1754+  15A2             ; $00D5 GTSTCK
1755+  15A2             ; Function : Returns the joystick status
1756+  15A2             ; Input    : A  - Joystick number to test (0 = cursors, 1 = port 1, 2 = port 2)
1757+  15A2             ; Output   : A  - Direction,D = $00(when A=0)
1758+  15A2             ; Registers: All
1759+  15A2             gtstck:
1760+  15A2 C5                          push    bc
1761+  15A3 FE 00                       cp      $00
1762+  15A5 20 22                       jr      nz,joy_stc1
1763+  15A7             
1764+  15A7                             .IF KB_USE_SERIAL=1
1765+  15A7 CD 85 17         		CALL	key_in
1766+  15AA                  	     		
1767+  15AA 3A 56 16    		LD	A,(N8VEM_KB_STICK_CACHE)
1768+  15AD E6 0F       		AND	$0F
1769+  15AF CA BC 15    		JP	Z,GSTICK_N8VEM_END	; IF NO DATA END
1770+  15B2 47          		LD	B,A
1771+  15B3 3A 56 16    		LD	A,(N8VEM_KB_STICK_CACHE)
1772+  15B6 E6 F0       		AND	$F0
1773+  15B8 32 56 16    		LD	(N8VEM_KB_STICK_CACHE),A
1774+  15BB 78          		LD	A,B
1775+  15BC             GSTICK_N8VEM_END:
1776+  15BC E5                          push    hl
1777+  15BD 21 00 16                    ld      hl,joypos_kbd_tbl
1778+  15C0 16 00                       ld      d,0
1779+  15C2 5F                          ld      e,a
1780+  15C3 19                          add     hl,de
1781+  15C4 7E                          ld      a,(hl)
1782+  15C5 E1                          pop     hl
1783+  15C6                             .ENDIF
1784+  15C6 C1                          pop     bc
1785+  15C7 A7                          and     a
1786+  15C8 C9                          ret
1787+  15C9             joy_stc1:
1788+  15C9             ;PSG reg 15h
1789+  15C9             ;0J001111
1790+  15C9             ;PSG reg 14h
1791+  15C9             ;00BARLDU
1792+  15C9             
1793+  15C9 E5                          push    hl
1794+  15CA D5                          push    de
1795+  15CB             
1796+  15CB 1E 00                       ld      e,$00
1797+  15CD 3D                          dec     a
1798+  15CE 28 04                       jr      z,sel_stc1
1799+  15D0             	; N8VEM SITCK 2		
1800+  15D0 3E 0F                       ld      a,$0F
1801+  15D2 18 02       		JR	N8_STKREAD
1802+  15D4             sel_stc1:		
1803+  15D4 3E 0E       		LD	A,$0E
1804+  15D6             N8_STKREAD:                
1805+  15D6 F3                          di
1806+  15D7 CD 7B 15                    call    rdpsg
1807+  15DA FB                          ei
1808+  15DB 2F                          CPL
1809+  15DC E6 0F                       and     $0F
1810+  15DE 21 F0 15                    ld      hl,joypos_joy_tbl
1811+  15E1 06 00                       ld      b,0
1812+  15E3 4F                          ld      c,a
1813+  15E4 09                          add     hl,bc
1814+  15E5 7E                          ld      a,(hl)
1815+  15E6 D1                          pop     de
1816+  15E7 E1                          pop     hl
1817+  15E8             
1818+  15E8 C1                          pop     bc
1819+  15E9 A7                          and     a
1820+  15EA C9                          ret
1821+  15EB             
1822+  15EB             joy_end:
1823+  15EB 3E 00                       ld      a,$00
1824+  15ED C1                          pop     bc
1825+  15EE A7                          and     a
1826+  15EF C9                          ret
1827+  15F0             	
1828+  15F0             joypos_joy_tbl:
1829+  15F0                             ;         0   1   2   3   4   5   6   7
1830+  15F0 00 01 05 00                 .db      $00,$01,$05,$00,$07,$08,$06,$07
1830+  15F4 07 08 06 07 
1831+  15F8                             ;         8   9   A   B   C   D   E   F
1832+  15F8 03 02 04 03                 .db      $03,$02,$04,$03,$00,$01,$05,$00
1832+  15FC 00 01 05 00 
1833+  1600             
1834+  1600             joypos_kbd_tbl:
1835+  1600                             ;         0   1   2   3   4   5   6   7
1836+  1600 00 07 01 08                 .db      $00,$07,$01,$08,$05,$06,$00,$07
1836+  1604 05 06 00 07 
1837+  1608                             ;         8   9   A   B   C   D   E   F
1838+  1608 03 00 02 01                 .db      $03,$00,$02,$01,$04,$05,$03,$00
1838+  160C 04 05 03 00 
1839+  1610             
1840+  1610             
1841+  1610             N8VEM_KB_STICK:
1842+  1610 3A 56 16    		LD	A,(N8VEM_KB_STICK_CACHE)		               
1843+  1613 FE 00       		CP	00
1844+  1615 C2 55 16    		JP	NZ,N8VEM_KB_STICK_END
1845+  1618 78          		LD	A,B			
1846+  1619 FE 53       		CP	'S'			;
1847+  161B CA 35 16    		JP	Z,N8VEM_KB_STICK_R
1848+  161E FE 5A       		CP	'Z'			;
1849+  1620 CA 3B 16    		JP	Z,N8VEM_KB_STICK_D
1850+  1623 FE 57       		CP	'W'			;
1851+  1625 CA 41 16    		JP	Z,N8VEM_KB_STICK_U
1852+  1628 FE 41       		CP	'A'			;
1853+  162A CA 47 16    		JP	Z,N8VEM_KB_STICK_L	
1854+  162D FE 20       		CP	' '			;
1855+  162F CA 4D 16    		JP	Z,N8VEM_KB_STICK_B			
1856+  1632 C3 53 16    		JP	N8VEM_KB_STICK_NONE
1857+  1635             N8VEM_KB_STICK_R:
1858+  1635 3E 08       		LD	A,%00001000
1859+  1637 32 56 16    		LD	(N8VEM_KB_STICK_CACHE),A
1860+  163A C9          		RET
1861+  163B             N8VEM_KB_STICK_D:
1862+  163B 3E 04       		LD	A,%00000100
1863+  163D 32 56 16    		LD	(N8VEM_KB_STICK_CACHE),A
1864+  1640 C9          		RET
1865+  1641             N8VEM_KB_STICK_U:
1866+  1641 3E 02       		LD	A,%00000010
1867+  1643 32 56 16    		LD	(N8VEM_KB_STICK_CACHE),A
1868+  1646 C9          		RET
1869+  1647             N8VEM_KB_STICK_L:
1870+  1647 3E 01       		LD	A,%00000001
1871+  1649 32 56 16    		LD	(N8VEM_KB_STICK_CACHE),A
1872+  164C C9          		RET
1873+  164D             N8VEM_KB_STICK_B:
1874+  164D 3E 10       		LD	A,%00010000
1875+  164F 32 56 16    		LD	(N8VEM_KB_STICK_CACHE),A
1876+  1652 C9          		RET		
1877+  1653             N8VEM_KB_STICK_NONE:
1878+  1653 3E 00       		LD	A,%00000000
1879+  1655             N8VEM_KB_STICK_END:
1880+  1655 C9          		RET 
1881+  1656             N8VEM_KB_STICK_CACHE:
1882+  1656 00                          .DB	00
1883+  1657                             
1884+  1657             ;--------------------------------
1885+  1657             ; $00D8 GTTRIG
1886+  1657             ; Function : Returns current trigger status
1887+  1657             ; Input    : A  - trigger button to test
1888+  1657             ;            0 = spacebar(included A-1 = minus)
1889+  1657             ;            1 = port 1, button A
1890+  1657             ;            2 = port 2, button A
1891+  1657             ;            3 = port 1, button B
1892+  1657             ;            4 = port 2, button B
1893+  1657             ; Output   : A  - #00 trigger button not pressed
1894+  1657             ;                 #FF trigger button pressed
1895+  1657             ; Note     : Some programs rely on ZF to be set according to the value in A.
1896+  1657             ; Registers: All
1897+  1657             gttrig:
1898+  1657 FE 05                       cp      5
1899+  1659 30 03                       jr      nc,gttrig_space ; if value of A is above 5,go space routine
1900+  165B B7                          or      a
1901+  165C 20 14                       jr      nz,joy_trig
1902+  165E             gttrig_space:
1903+  165E             ; Keyboard (spacebar)
1904+  165E             		.IF KB_USE_SERIAL=1
1905+  165E CD 85 17    		CALL	key_in
1906+  1661 3A 56 16    		LD	A,(N8VEM_KB_STICK_CACHE)
1907+  1664 E6 F0       		AND	$F0
1908+  1666 C8          		RET	Z		; IF NO DATA END
1909+  1667 3A 56 16    		LD	A,(N8VEM_KB_STICK_CACHE)
1910+  166A E6 0F       		AND	$0F
1911+  166C 32 56 16    		LD	(N8VEM_KB_STICK_CACHE),A
1912+  166F 3E FF       		LD	A,$FF
1913+  1671 C9          		RET
1914+  1672~            		.ELSE
1915+  1672~            		LD	A,$00
1916+  1672~            		RET
1917+  1672             		.ENDIF
1918+  1672             
1919+  1672             ; Joystick triggers
1920+  1672             joy_trig:
1921+  1672 F3                          di
1922+  1673 3D                          dec     a
1923+  1674 D5                          push    de
1924+  1675 1E 03                       ld      e,$03   ; enable trig A+B of stick 1
1925+  1677 47                          ld      b,a
1926+  1678 E6 01                       and     $01
1927+  167A 28 04                       jr      z,sel_trig1
1928+  167C             ; TRIGGER 2
1929+  167C 3E 0F                       ld      a,$0F
1930+  167E 18 02       		JR	N8_TRGREAD
1931+  1680             sel_trig1:		
1932+  1680 3E 0E       		LD	A,$0E
1933+  1682             N8_TRGREAD:                
1934+  1682 F3                          di
1935+  1683 CD 7B 15                    call    rdpsg
1936+  1686 FB                          ei
1937+  1687 5F                          LD	E,A
1938+  1688 78                          LD	A,B   
1939+  1689 E6 02                       AND	02            
1940+  168B 28 08       		JR	Z,istrg_a
1941+  168D 7B          		LD	A,E
1942+  168E D1                          POP	DE 		
1943+  168F E6 80       		AND	$80
1944+  1691 28 0A                       jr      z,trig_on
1945+  1693 18 0B                       jr      trig_off                                
1946+  1695             istrg_a:                
1947+  1695 7B          		LD	A,E
1948+  1696 D1          		POP	DE 
1949+  1697 E6 10       		AND	$10
1950+  1699 28 02                       jr      z,trig_on
1951+  169B 18 03                       jr      trig_off
1952+  169D             
1953+  169D             trig_on:
1954+  169D 3E FF                       ld      a,$FF
1955+  169F C9                          ret
1956+  16A0             trig_off:
1957+  16A0 AF                          xor     a
1958+  16A1 C9                          ret
1959+  16A2                          
1960+  16A2             
1961+  16A2             ;--------------------------------
1962+  16A2             ; $00db GTPAD
1963+  16A2             ; Function : Returns current touch pad status
1964+  16A2             ; Input    : A  - Touchpad number to test
1965+  16A2             ; Output   : A  - Value
1966+  16A2             ; Registers: All
1967+  16A2             ; NOTE     : This implementation is still a stub!
1968+  16A2             gtpad:
1969+  16A2 E5                          push    hl
1970+  16A3 F5                          push    af
1971+  16A4 21 AB 16                    ld      hl,gtpad_text
1972+  16A7             ;                call    print_debug
1973+  16A7 F1                          pop     af
1974+  16A8 E1                          pop     hl
1975+  16A9 AF                          xor     a  ; haywire
1976+  16AA C9                          ret
1977+  16AB 47 54 50 41 gtpad_text:     .db      "GTPAD",0
1977+  16AF 44 00 
1978+  16B1             
1979+  16B1             ;--------------------------------
1980+  16B1             ; $00DE GTPDL
1981+  16B1             ; Function : Returns currenct value of paddle
1982+  16B1             ; Input    : A  - Paddle number
1983+  16B1             ; Output   : A  - Value
1984+  16B1             ; Registers: All
1985+  16B1             ; NOTE     : This implementation is still a stub!
1986+  16B1             gtpdl:
1987+  16B1 E5                          push    hl
1988+  16B2 F5                          push    af
1989+  16B3 21 B9 16                    ld      hl,gtpdl_text
1990+  16B6             ;                call    print_debug
1991+  16B6 F1                          pop     af
1992+  16B7 E1                          pop     hl
1993+  16B8 C9                          ret
1994+  16B9 47 54 50 44 gtpdl_text:     .db      "GTPDL",0
1994+  16BD 4C 00 
1995+  16BF             
1996+  16BF             ;--------------------------------
1997+  16BF             ; $00F6 LFTQ
1998+  16BF             ; Give the number of bytes left in a queue.
1999+  16BF             ; In:      A  = queue number
2000+  16BF             ; Out:     HL = number of bytes left
2001+  16BF             ; Changes: AF, BC, HL
2002+  16BF             lftq:
2003+  16BF CD EF 16                    call    calc_queue_address
2004+  16C2 46                          ld      b,(hl)          ; B = put position
2005+  16C3 04                          inc     b
2006+  16C4 23                          inc     hl
2007+  16C5 7E                          ld      a,(hl)          ; A = get position
2008+  16C6 90                          sub     b               ; (getpos - putpos) & size
2009+  16C7 23                          inc     hl
2010+  16C8 23                          inc     hl
2011+  16C9 A6                          and     (hl)
2012+  16CA 6F                          ld      l,a
2013+  16CB 26 00                       ld      h,$00           ; Queues are smaller than 256 bytes.
2014+  16CD C9                          ret
2015+  16CE             
2016+  16CE             ;--------------------------------
2017+  16CE             ; $00F9 PUTQ
2018+  16CE             ; Put a byte in a queue.
2019+  16CE             ; In:      A  = queue number
2020+  16CE             ;          E  = data
2021+  16CE             ; Out:     ZF = set if the queue is full
2022+  16CE             ; Changes: AF, BC, HL
2023+  16CE             putq:
2024+  16CE                             ; Check whether the queue is full.
2025+  16CE CD EF 16                    call    calc_queue_address
2026+  16D1 7E                          ld      a,(hl)
2027+  16D2 3C                          inc     a
2028+  16D3 47                          ld      b,a             ; B = put position + 1
2029+  16D4 23                          inc     hl
2030+  16D5 96                          sub     (hl)
2031+  16D6 C8                          ret     z
2032+  16D7             
2033+  16D7                             ; Save the new put position.
2034+  16D7 78                          ld      a,b
2035+  16D8 23                          inc     hl
2036+  16D9 23                          inc     hl
2037+  16DA E5                          push    hl
2038+  16DB A6                          and     (hl)            ; (putpos + 1) & size
2039+  16DC 2B                          dec     hl
2040+  16DD 2B                          dec     hl
2041+  16DE 2B                          dec     hl
2042+  16DF 77                          ld      (hl),a
2043+  16E0             
2044+  16E0                             ; Put the data byte in the queue.
2045+  16E0 E1                          pop     hl
2046+  16E1 23                          inc     hl
2047+  16E2 7E                          ld      a,(hl)          ; Get the buffer address.
2048+  16E3 23                          inc     hl
2049+  16E4 66                          ld      h,(hl)
2050+  16E5 6F                          ld      l,a
2051+  16E6 05                          dec     b               ; Add putpos.
2052+  16E7 48                          ld      c,b
2053+  16E8 06 00                       ld      b,0
2054+  16EA 09                          add     hl,bc
2055+  16EB 73                          ld      (hl),e
2056+  16EC F6 01                       or      1
2057+  16EE C9                          ret
2058+  16EF             
2059+  16EF                             ; Calculate the address to the start of queue control block.
2060+  16EF                             ; A = queue number
2061+  16EF             calc_queue_address:
2062+  16EF 2A F3 F3                    ld      hl,(QUEUES)     ; See QUETAB in systemvars.asm.
2063+  16F2 47                          ld      b,a             ; (queue number * 6)
2064+  16F3 07                          rlca
2065+  16F4 07                          rlca
2066+  16F5 80                          add     a,b
2067+  16F6 80                          add     a,b
2068+  16F7 4F                          ld      c,a
2069+  16F8 06 00                       ld      b,0
2070+  16FA 09                          add     hl,bc
2071+  16FB C9                          ret
2072+  16FC             
2073+  16FC             ;--------------------------------
2074+  16FC             ; $0132 CHGCAP
2075+  16FC             ; Function : Alternates the CAP lamp status
2076+  16FC             ; Input    : A  - #00 is lamp on
2077+  16FC             ;             not #00 is lamp off
2078+  16FC             ; Registers: AF
2079+  16FC             chgcap:
2080+  16FC             ;// TODO: n8vem code
2081+  16FC C9                          ret
2082+  16FD             
2083+  16FD             ;--------------------------------
2084+  16FD             ; $014D OUTDLP
2085+  16FD             ; Function : Printer output
2086+  16FD             ; Input    : A  - code to print
2087+  16FD             ; Registers: F
2088+  16FD             ; Remark   : Differences with LPTOUT:
2089+  16FD             ;            1. TAB is expanded to spaces
2090+  16FD             ;            2. For non-MSX printers, Hiragana is transformed to katakana
2091+  16FD             ;               and graphic characters are transformed to 1-byte characters
2092+  16FD             ;            3. If failed, device I/O error occurs
2093+  16FD             ; TODO     : This implementation is still a stub!
2094+  16FD             outdlp:
2095+  16FD E5                          push    hl
2096+  16FE F5                          push    af
2097+  16FF 21 05 17                    ld      hl,outdlp_text
2098+  1702             ;                call    print_debug
2099+  1702 F1                          pop     af
2100+  1703 E1                          pop     hl
2101+  1704 C9                          ret
2102+  1705 4F 55 54 44 outdlp_text:    .db      "OUTDLP",0
2102+  1709 4C 50 00 
2103+  170C             
2104+  170C             ;--------------------------------
2105+  170C             ; $0150 GETVCP
2106+  170C             ; Returns pointer to a variable at offset 2 in a voice structure.
2107+  170C             ; TODO: find out the purpose of this variable.
2108+  170C             ; Address  : #0150
2109+  170C             ; Function : Returns pointer to play queue
2110+  170C             ; Input    : A  - Channel number
2111+  170C             ; Output   : HL - Pointer
2112+  170C             ; Registers: AF
2113+  170C             ; Remark   : Only used to play music in background
2114+  170C             getvcp:
2115+  170C 2E 02                       ld      l,2
2116+  170E 18 03                       jr      getvc2_a
2117+  1710             
2118+  1710             ;--------------------------------
2119+  1710             ; $0153 GETVC2
2120+  1710             ; Returns pointer to a given variable in a voice structure.
2121+  1710             ; Input    : L        - Pointer in play buffer
2122+  1710             ;            (VOICEN) - Voice structure number
2123+  1710             ; Output   : HL - Pointer
2124+  1710             ; Registers: AF
2125+  1710             getvc2:
2126+  1710 3A 38 FB                    ld      a,(VOICEN)
2127+  1713             getvc2_a:
2128+  1713 D5                          push    de
2129+  1714 16 00                       ld      d,0
2130+  1716 5D                          ld      e,l
2131+  1717 21 41 FB                    ld      hl,VCBA
2132+  171A 19                          add     hl,de
2133+  171B 1E 25                       ld      e,37            ; Size of a structure
2134+  171D             getvc2_loop:
2135+  171D B7                          or      a
2136+  171E 28 04                       jr      z,getvc2_exit
2137+  1720 19                          add     hl,de
2138+  1721 3D                          dec     a
2139+  1722 18 F9                       jr      getvc2_loop
2140+  1724             getvc2_exit:
2141+  1724 D1                          pop     de
2142+  1725 C9                          ret
2143+  1726             
2144+  1726             ;--------------------------------
2145+  1726             ; $0156 KILBUF
2146+  1726             ; Empties the keyboard buffer.
2147+  1726             ; Changes: HL
2148+  1726             kilbuf:
2149+  1726 2A FA F3                    ld      hl,(GETPNT)
2150+  1729 22 F8 F3                    ld      (PUTPNT),hl
2151+  172C C9                          ret
2152+  172D             
2153+  172D             ;--------------------------------
2154+  172D             ; Interrupt routine ($0038h)
2155+  172D             ;--------------------------------
2156+  172D             ; some games uses Reg.R and the routine affects the register's value.
2157+  172D             ; if you want to add something to the routine,please try the following first
2158+  172D             ;
2159+  172D             ; Riseout , Replicart
2160+  172D             
2161+  172D             keyint:
2162+  172D E5                          push    hl
2163+  172E D5                          push    de
2164+  172F C5                          push    bc
2165+  1730 F5                          push    af
2166+  1731 D9                          exx
2167+  1732 08                          ex      af,af'
2168+  1733 E5                          push    hl
2169+  1734 D5                          push    de
2170+  1735 C5                          push    bc
2171+  1736 F5                          push    af
2172+  1737 FD E5                       push    iy
2173+  1739 DD E5                       push    ix
2174+  173B             
2175+  173B CD 9A FD                    call    H_KEYI
2176+  173E DB 99                       in      a,(VDP_STAT)
2177+  1740 B7                          or      a
2178+  1741 32 E7 F3                    ld      (STATFL),a      ; save status
2179+  1744 F2 70 17                    jp      p,int_end       ; exit if this is not the VDP int
2180+  1747 CD 9F FD                    call    H_TIMI
2181+  174A             
2182+  174A                             ; TODO: (BASIC related stuff)
2183+  174A                             ;       Check sprite collision
2184+  174A                             ;       Update INTCNT
2185+  174A             
2186+  174A 2A 9E FC                    ld      hl,(JIFFY)
2187+  174D 23                          inc     hl
2188+  174E 22 9E FC                    ld      (JIFFY),hl
2189+  1751             
2190+  1751                             ; TODO: MUSICF
2191+  1751             
2192+  1751                             ; TODO: It seems unsafe to me to already allow interrupts
2193+  1751                             ;       while this one is still busy: possible interference
2194+  1751                             ;       between two interrupts and also the amount of stack
2195+  1751                             ;       space claimed is a lot.
2196+  1751                             ;ei
2197+  1751             
2198+  1751                             ; Riseout needs that count of RegR in the routine is not
2199+  1751                             ; even number
2200+  1751                             ; nop
2201+  1751             
2202+  1751 AF                          xor     a
2203+  1752 32 D9 FB                    ld      (CLIKFL),a
2204+  1755             
2205+  1755                             
2206+  1755             		
2207+  1755                             ; Scan the keyboard every three interrupts.
2208+  1755                                                             
2209+  1755 3A F6 F3                    ld      a,(SCNCNT)
2210+  1758 3D                          dec     a
2211+  1759 32 F6 F3                    ld      (SCNCNT),a
2212+  175C 20 12                       jr      nz,int_end
2213+  175E 3E 03                       ld      a,3
2214+  1760 32 F6 F3                    ld      (SCNCNT),a
2215+  1763                             
2216+  1763                             ; TODO read joystick triggers and space for TRGFLG
2217+  1763 AF                          xor     a
2218+  1764 CD 57 16                    call    gttrig
2219+  1767 2F                          cpl
2220+  1768 E6 01                       and     $01
2221+  176A 32 E8 F3                    ld      (TRGFLG),a
2222+  176D                    
2223+  176D                             .IF KB_USE_SERIAL=1
2224+  176D CD 85 17                    call    key_in     
2225+  1770                             .ENDIF 
2226+  1770                             
2227+  1770~                            .IF KB_USE_PS2=1
2228+  1770~            		call 	KB_PROCESS
2229+  1770             		.ENDIF
2230+  1770             
2231+  1770                            
2232+  1770             int_end:
2233+  1770 DD E1                       pop     ix
2234+  1772 FD E1                       pop     iy
2235+  1774 F1                          pop     af
2236+  1775 C1                          pop     bc
2237+  1776 D1                          pop     de
2238+  1777 E1                          pop     hl
2239+  1778 D9                          exx
2240+  1779 08                          ex      af,af'
2241+  177A F1                          pop     af
2242+  177B C1                          pop     bc
2243+  177C D1                          pop     de
2244+  177D E1                          pop     hl
2245+  177E FB                          ei
2246+  177F C9                          ret
2247+  1780             
2248+  1780             ;--------------------------------
2249+  1780             ; 0066h NMI interrupt
2250+  1780             nmi:
2251+  1780 CD D6 FD                    call    H_NMI
2252+  1783 ED 45                       retn
2253+  1785             
2254+  1785             ;--------------------------------
2255+  1785             ; Get buffer from keyboard input
2256+  1785             key_in:
2257+  1785 DB 6D               	IN	A,(UART5)	; READ LINE STATUS REGISTER
2258+  1787 CB 47       		BIT	0,A		; TEST IF DATA IN RECEIVE BUFFER
2259+  1789 CA A6 17    		JP	Z,N8VEM_KEY_END	; IF NO DATA END
2260+  178C DB 68       		IN	A,(UART0)	; THEN READ THE CHAR FROM THE UART
2261+  178E F5          		PUSH	AF		;
2262+  178F C5          		PUSH	BC		;
2263+  1790 47          		LD	B,A		;
2264+  1791 CD 10 16    		CALL	N8VEM_KB_STICK	;
2265+  1794 C1          		POP	BC		;
2266+  1795 F1          		POP	AF		;
2267+  1796 E5                          push    hl		;
2268+  1797 FE 03                       CP	03		;
2269+  1799 20 07       		JR	NZ,KEY_IN1      ;         
2270+  179B 3E FF       		LD	A,$FF		;
2271+  179D 32 1C F4    		LD	(BREAKFLAG),A	;
2272+  17A0 18 03       		JR	KEY_IN2		;
2273+  17A2 CD A7 17    KEY_IN1:        call    key_put_into_buf;
2274+  17A5 E1          KEY_IN2:        pop     hl		;                
2275+  17A6             N8VEM_KEY_END:
2276+  17A6 C9          		RET
2277+  17A7             		
2278+  17A7             		
2279+  17A7             ;--------------------------------
2280+  17A7             key_put_into_buf:
2281+  17A7 2A F8 F3                    ld      hl,(PUTPNT)
2282+  17AA 77                          ld      (hl),a
2283+  17AB                             ; Note: Ashguine 2 has a bug: it puts KEYBUF at FDF0 iso FBF0
2284+  17AB                             ;       in the name input routine. This writes keys in memory
2285+  17AB                             ;       reserved for hooks, but since those hooks are only used
2286+  17AB                             ;       by BASIC, the game doesn't suffer. When PUTPNT reaches
2287+  17AB                             ;       FE18, it wraps back to FBF0.
2288+  17AB 23                          inc     hl
2289+  17AC 7D                          ld      a,l
2290+  17AD             ;                cp      $00FF & (KEYBUF + 40)
2291+  17AD FE 18                       cp      $18
2292+  17AF 20 03                       jr      nz,key_store_nowrap
2293+  17B1 21 F0 FB                    ld      hl,KEYBUF
2294+  17B4             key_store_nowrap:
2295+  17B4                             ; Check whether the buffer is full.
2296+  17B4 D5                          push    de
2297+  17B5 ED 5B FA F3                 ld      de,(GETPNT)
2298+  17B9 E7                          rst     20h
2299+  17BA D1                          pop     de
2300+  17BB C8                          ret     z
2301+  17BC 22 F8 F3                    ld      (PUTPNT),hl
2302+  17BF C9                          ret
2303+  17C0             
2304+  17C0             
2305+  17C0             ;--------------------------------
2306+  17C0             ; $015C SUBROM
2307+  17C0             ; Function : Calls a routine in SUB-ROM
2308+  17C0             ; Input    : IX - Address of routine in SUB-ROM
2309+  17C0             ; Output   : Depen.ds on the routine
2310+  17C0             ; Registers: Alternative registers, IY
2311+  17C0             ; Remark   : Use of EXTROM or CALSLT is more convenient.
2312+  17C0             ;            You have to use this routine like this:
2313+  17C0             ;               push    ix
2314+  17C0             ;               jp      subrom
2315+  17C0             ;            The purpose is unclear
2316+  17C0             subrom:
2317+  17C0 DD E1                       pop     ix
2318+  17C2 C9                          ret
2319+  17C3             
2320+  17C3             
2321+  17C3             ;--------------------------------
2322+  17C3             ; $015F EXTROM
2323+  17C3             ; Function : Calls a routine in SUB-ROM. Most common way
2324+  17C3             ; Input    : IX - Address of routine in SUB-ROM
2325+  17C3             ; Output   : Depends on the routine
2326+  17C3             ; Registers: Alternative registers, IY
2327+  17C3             ; Remark   : Use: LD IX,address
2328+  17C3             ;                 CALL EXTROM
2329+  17C3             extrom:
2330+  17C3                             ; EXTROM needs to save alternative registers
2331+  17C3                             ; and when call with certain status, returns with EI
2332+  17C3 C9                          ret
2333+  17C4             
2334+  17C4             ;------------------------------------
2335+  17C4             hang_up_mode:
2336+  17C4 18 FE                       jr      $
2337+  17C6             
2338+  17C6             ;------------------------------------
2339+  17C6             ; Called if the stack underflows.
2340+  17C6             stack_error:
2341+  17C6 CD DA FE                    call    H_STKE
2342+  17C9 11 4D 24                    ld      de,str_stack_error
2343+  17CC C3 E3 17                    jp      print_error
2344+  17CF             
2345+  17CF             ;------------------------------------
2346+  17CF             ; $0159 CALBAS
2347+  17CF             ; Function : Executes inter-slot call to the routine in BASIC interpreter
2348+  17CF             ; Input    : IX - for the calling address
2349+  17CF             ; Output   : Depen.ds on the called routine
2350+  17CF             ; Registers: Depen.ds on the called routine
2351+  17CF             calbas:
2352+  17CF E5                          push    hl
2353+  17D0 F5                          push    af
2354+  17D1 21 DC 17                    ld      hl,calbas_text
2355+  17D4             ;                call    print_debug
2356+  17D4 F1                          pop     af
2357+  17D5 E1                          pop     hl
2358+  17D6 11 32 24                    ld      de,str_no_basic_intr
2359+  17D9 C3 E3 17                    jp      print_error
2360+  17DC 43 41 4C 42 calbas_text:    .db      "CALBAS",0
2360+  17E0 41 53 00 
2361+  17E3             
2362+  17E3             ;------------------------------------
2363+  17E3             ;Display error
2364+  17E3             ;in DE= message address
2365+  17E3             
2366+  17E3             print_error:
2367+  17E3 DB 99                       in      a,(VDP_STAT) ; reset Latch
2368+  17E5 21 5A 24                    ld      hl,vdp_bios
2369+  17E8 06 0C                       ld      b,$0C
2370+  17EA 0E 99                       ld      c,VDP_ADDR
2371+  17EC ED B3                       otir
2372+  17EE             
2373+  17EE 01 00 08                    ld      bc,$0800
2374+  17F1             lp_clearmem:
2375+  17F1 AF                          xor     a
2376+  17F2 D3 98                       out     (VDP_DATA),a
2377+  17F4 0B                          dec     bc
2378+  17F5 78                          ld      a,b
2379+  17F6 B1                          or      c
2380+  17F7 20 F8                       jr      nz,lp_clearmem
2381+  17F9             
2382+  17F9 21 BF 1B                    ld      hl,B_Font
2383+  17FC 01 00 08                    ld      bc,$0800
2384+  17FF             lp_fontset:
2385+  17FF 7E                          ld      a,(hl)
2386+  1800 D3 98                       out     (VDP_DATA),a
2387+  1802 23                          inc     hl
2388+  1803 0B                          dec     bc
2389+  1804 78                          ld      a,b
2390+  1805 B1                          or      c
2391+  1806 20 F7                       jr      nz,lp_fontset
2392+  1808             
2393+  1808             ;set cursor to (0,0)
2394+  1808 3E 00                       ld      a,$00
2395+  180A D3 99                       out     (VDP_ADDR),a
2396+  180C 3E 40                       ld      a,$40
2397+  180E D3 99                       out     (VDP_ADDR),a
2398+  1810             
2399+  1810 21 2B 24                    ld      hl,str_error_prompt
2400+  1813             
2401+  1813 7E                          ld      a,(hl)
2402+  1814             lp_errprn:
2403+  1814 D3 98                       out     (VDP_DATA),a
2404+  1816 23                          inc     hl
2405+  1817 7E                          ld      a,(hl)
2406+  1818 A7                          and     a
2407+  1819 20 F9                       jr      nz,lp_errprn
2408+  181B             
2409+  181B 1A                          ld      a,(de)
2410+  181C             lp_strprn:
2411+  181C D3 98                       out     (VDP_DATA),a
2412+  181E 13                          inc     de
2413+  181F 1A                          ld      a,(de)
2414+  1820 A7                          and     a
2415+  1821 20 F9                       jr      nz,lp_strprn
2416+  1823             
2417+  1823 C3 C4 17                    jp      hang_up_mode
2418+  1826             
2419+  1826                             .ds      $1bbf - $
2420+  1BBF                             .include "font.asm"
0001++ 1BBF             ; $Id: font.asm 525 2008-12-22 22:16:42Z mthuurne $
0002++ 1BBF             ; Font data for C-BIOS. Font designed by Eric Boon.
0003++ 1BBF             ; JP version font designed by BouKiCHi.
0004++ 1BBF             ;
0005++ 1BBF             ; Copyright (c) 2004 Eric Boon.  All rights reserved.
0006++ 1BBF             ; Copyright (c) 2002-2005 BouKiCHi.  All rights reserved.
0007++ 1BBF             ;
0008++ 1BBF             ; Redistribution and use in source and binary forms, with or without
0009++ 1BBF             ; modification, are permitted provided that the following conditions
0010++ 1BBF             ; are met:
0011++ 1BBF             ; 1. Redistributions of source code must retain the above copyright
0012++ 1BBF             ;    notice, this list of conditions and the following disclaimer.
0013++ 1BBF             ; 2. Redistributions in binary form must reproduce the above copyright
0014++ 1BBF             ;    notice, this list of conditions and the following disclaimer in the
0015++ 1BBF             ;    documentation and/or other materials provided with the distribution.
0016++ 1BBF             ;
0017++ 1BBF             ; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
0018++ 1BBF             ; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
0019++ 1BBF             ; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
0020++ 1BBF             ; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
0021++ 1BBF             ; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
0022++ 1BBF             ; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0023++ 1BBF             ; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0024++ 1BBF             ; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0025++ 1BBF             ; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
0026++ 1BBF             ; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0027++ 1BBF             
0028++ 1BBF             B_Font:
0029++ 1BBF                    .IF LOCALE_CHSET = LOCAL_CHSET_US
0030++ 1BBF             ; International version
0031++ 1BBF 00 00 00 00                 .db      $00,$00,$00,$00,$00,$00,$00,$00         ; 0
0031++ 1BC3 00 00 00 00 
0032++ 1BC7 3C 42 A5 A5                 .db      $3C,$42,$A5,$A5,$C3,$BD,$42,$3C         ; 1
0032++ 1BCB C3 BD 42 3C 
0033++ 1BCF 3C 7E DB DB                 .db      $3C,$7E,$DB,$DB,$BD,$C3,$7E,$3C         ; 2
0033++ 1BD3 BD C3 7E 3C 
0034++ 1BD7 6C AA 92 44                 .db      $6C,$AA,$92,$44,$44,$28,$10,$00         ; 3
0034++ 1BDB 44 28 10 00 
0035++ 1BDF 10 28 44 82                 .db      $10,$28,$44,$82,$44,$28,$10,$00         ; 4
0035++ 1BE3 44 28 10 00 
0036++ 1BE7 10 38 38 D6                 .db      $10,$38,$38,$D6,$FE,$D6,$38,$00         ; 5
0036++ 1BEB FE D6 38 00 
0037++ 1BEF 10 38 7C 7C                 .db      $10,$38,$7C,$7C,$FE,$D6,$38,$00         ; 6
0037++ 1BF3 FE D6 38 00 
0038++ 1BF7 00 00 00 18                 .db      $00,$00,$00,$18,$18,$00,$00,$00         ; 7
0038++ 1BFB 18 00 00 00 
0039++ 1BFF FF FF FF E7                 .db      $FF,$FF,$FF,$E7,$E7,$FF,$FF,$FF         ; 8
0039++ 1C03 E7 FF FF FF 
0040++ 1C07 3C 42 81 81                 .db      $3C,$42,$81,$81,$81,$81,$42,$3C         ; 9
0040++ 1C0B 81 81 42 3C 
0041++ 1C0F C3 BD 7E 7E                 .db      $C3,$BD,$7E,$7E,$7E,$7E,$BD,$C3         ; 10
0041++ 1C13 7E 7E BD C3 
0042++ 1C17 0C 04 08 70                 .db      $0C,$04,$08,$70,$88,$88,$70,$00         ; 11
0042++ 1C1B 88 88 70 00 
0043++ 1C1F 00 70 88 88                 .db      $00,$70,$88,$88,$70,$20,$70,$20         ; 12
0043++ 1C23 70 20 70 20 
0044++ 1C27 20 30 28 28                 .db      $20,$30,$28,$28,$20,$E0,$C0,$00         ; 13
0044++ 1C2B 20 E0 C0 00 
0045++ 1C2F 38 3C 24 24                 .db      $38,$3C,$24,$24,$E4,$DC,$18,$00         ; 14
0045++ 1C33 E4 DC 18 00 
0046++ 1C37 10 44 38 AA                 .db      $10,$44,$38,$AA,$38,$44,$10,$00         ; 15
0046++ 1C3B 38 44 10 00 
0047++ 1C3F 10 10 10 38                 .db      $10,$10,$10,$38,$10,$10,$10,$10         ; 16
0047++ 1C43 10 10 10 10 
0048++ 1C47 10 10 10 EF                 .db      $10,$10,$10,$EF,$00,$00,$00,$00         ; 17
0048++ 1C4B 00 00 00 00 
0049++ 1C4F 00 00 00 EF                 .db      $00,$00,$00,$EF,$10,$10,$10,$10         ; 18
0049++ 1C53 10 10 10 10 
0050++ 1C57 10 10 10 E0                 .db      $10,$10,$10,$E0,$10,$10,$10,$10         ; 19
0050++ 1C5B 10 10 10 10 
0051++ 1C5F 10 10 10 0F                 .db      $10,$10,$10,$0F,$10,$10,$10,$10         ; 20
0051++ 1C63 10 10 10 10 
0052++ 1C67 10 10 10 EF                 .db      $10,$10,$10,$EF,$10,$10,$10,$10         ; 21
0052++ 1C6B 10 10 10 10 
0053++ 1C6F 10 10 10 10                 .db      $10,$10,$10,$10,$10,$10,$10,$10         ; 22
0053++ 1C73 10 10 10 10 
0054++ 1C77 00 00 00 FF                 .db      $00,$00,$00,$FF,$00,$00,$00,$00         ; 23
0054++ 1C7B 00 00 00 00 
0055++ 1C7F 00 00 00 0F                 .db      $00,$00,$00,$0F,$10,$10,$10,$10         ; 24
0055++ 1C83 10 10 10 10 
0056++ 1C87 00 00 00 E0                 .db      $00,$00,$00,$E0,$10,$10,$10,$10         ; 25
0056++ 1C8B 10 10 10 10 
0057++ 1C8F 10 10 10 0F                 .db      $10,$10,$10,$0F,$00,$00,$00,$00         ; 26
0057++ 1C93 00 00 00 00 
0058++ 1C97 10 10 10 E0                 .db      $10,$10,$10,$E0,$00,$00,$00,$00         ; 27
0058++ 1C9B 00 00 00 00 
0059++ 1C9F 81 42 24 18                 .db      $81,$42,$24,$18,$18,$24,$42,$81         ; 28
0059++ 1CA3 18 24 42 81 
0060++ 1CA7 01 02 04 08                 .db      $01,$02,$04,$08,$10,$20,$40,$80         ; 29
0060++ 1CAB 10 20 40 80 
0061++ 1CAF 80 40 20 10                 .db      $80,$40,$20,$10,$08,$04,$02,$01         ; 30
0061++ 1CB3 08 04 02 01 
0062++ 1CB7 00 00 10 FF                 .db      $00,$00,$10,$FF,$10,$00,$00,$00         ; 31
0062++ 1CBB 10 00 00 00 
0063++ 1CBF 00 00 00 00                 .db      $00,$00,$00,$00,$00,$00,$00,$00         ; 32
0063++ 1CC3 00 00 00 00 
0064++ 1CC7 20 20 20 20                 .db      $20,$20,$20,$20,$00,$20,$00,$00         ; 33
0064++ 1CCB 00 20 00 00 
0065++ 1CCF 50 50 00 00                 .db      $50,$50,$00,$00,$00,$00,$00,$00         ; 34
0065++ 1CD3 00 00 00 00 
0066++ 1CD7 00 50 F8 50                 .db      $00,$50,$F8,$50,$F8,$50,$00,$00         ; 35
0066++ 1CDB F8 50 00 00 
0067++ 1CDF 20 70 A0 70                 .db      $20,$70,$A0,$70,$28,$70,$20,$00         ; 36
0067++ 1CE3 28 70 20 00 
0068++ 1CE7 00 C8 D0 20                 .db      $00,$C8,$D0,$20,$58,$98,$00,$00         ; 37
0068++ 1CEB 58 98 00 00 
0069++ 1CEF 60 90 60 A8                 .db      $60,$90,$60,$A8,$98,$60,$00,$00         ; 38
0069++ 1CF3 98 60 00 00 
0070++ 1CF7 40 40 00 00                 .db      $40,$40,$00,$00,$00,$00,$00,$00         ; 39
0070++ 1CFB 00 00 00 00 
0071++ 1CFF 20 40 40 40                 .db      $20,$40,$40,$40,$40,$20,$00,$00         ; 40
0071++ 1D03 40 20 00 00 
0072++ 1D07 20 10 10 10                 .db      $20,$10,$10,$10,$10,$20,$00,$00         ; 41
0072++ 1D0B 10 20 00 00 
0073++ 1D0F 00 20 A8 70                 .db      $00,$20,$A8,$70,$50,$88,$00,$00         ; 42
0073++ 1D13 50 88 00 00 
0074++ 1D17 00 20 20 F8                 .db      $00,$20,$20,$F8,$20,$20,$00,$00         ; 43
0074++ 1D1B 20 20 00 00 
0075++ 1D1F 00 00 00 00                 .db      $00,$00,$00,$00,$00,$40,$40,$00         ; 44
0075++ 1D23 00 40 40 00 
0076++ 1D27 00 00 00 F8                 .db      $00,$00,$00,$F8,$00,$00,$00,$00         ; 45
0076++ 1D2B 00 00 00 00 
0077++ 1D2F 00 00 00 00                 .db      $00,$00,$00,$00,$00,$40,$00,$00         ; 46
0077++ 1D33 00 40 00 00 
0078++ 1D37 00 08 10 20                 .db      $00,$08,$10,$20,$40,$80,$00,$00         ; 47
0078++ 1D3B 40 80 00 00 
0079++ 1D3F 70 88 A8 A8                 .db      $70,$88,$A8,$A8,$88,$70,$00,$00         ; 48
0079++ 1D43 88 70 00 00 
0080++ 1D47 20 60 20 20                 .db      $20,$60,$20,$20,$20,$70,$00,$00         ; 49
0080++ 1D4B 20 70 00 00 
0081++ 1D4F 70 88 08 70                 .db      $70,$88,$08,$70,$80,$F8,$00,$00         ; 50
0081++ 1D53 80 F8 00 00 
0082++ 1D57 F8 08 30 08                 .db      $F8,$08,$30,$08,$88,$70,$00,$00         ; 51
0082++ 1D5B 88 70 00 00 
0083++ 1D5F 10 30 50 F8                 .db      $10,$30,$50,$F8,$10,$10,$00,$00         ; 52
0083++ 1D63 10 10 00 00 
0084++ 1D67 F8 80 70 08                 .db      $F8,$80,$70,$08,$88,$70,$00,$00         ; 53
0084++ 1D6B 88 70 00 00 
0085++ 1D6F 30 40 70 88                 .db      $30,$40,$70,$88,$88,$70,$00,$00         ; 54
0085++ 1D73 88 70 00 00 
0086++ 1D77 F8 88 10 20                 .db      $F8,$88,$10,$20,$20,$20,$00,$00         ; 55
0086++ 1D7B 20 20 00 00 
0087++ 1D7F 70 88 70 88                 .db      $70,$88,$70,$88,$88,$70,$00,$00         ; 56
0087++ 1D83 88 70 00 00 
0088++ 1D87 70 88 88 78                 .db      $70,$88,$88,$78,$08,$70,$00,$00         ; 57
0088++ 1D8B 08 70 00 00 
0089++ 1D8F 00 00 40 00                 .db      $00,$00,$40,$00,$00,$40,$00,$00         ; 58
0089++ 1D93 00 40 00 00 
0090++ 1D97 00 00 40 00                 .db      $00,$00,$40,$00,$00,$40,$40,$00         ; 59
0090++ 1D9B 00 40 40 00 
0091++ 1D9F 00 18 60 80                 .db      $00,$18,$60,$80,$60,$18,$00,$00         ; 60
0091++ 1DA3 60 18 00 00 
0092++ 1DA7 00 00 F8 00                 .db      $00,$00,$F8,$00,$F8,$00,$00,$00         ; 61
0092++ 1DAB F8 00 00 00 
0093++ 1DAF 00 C0 30 08                 .db      $00,$C0,$30,$08,$30,$C0,$00,$00         ; 62
0093++ 1DB3 30 C0 00 00 
0094++ 1DB7 70 88 30 20                 .db      $70,$88,$30,$20,$00,$20,$00,$00         ; 63
0094++ 1DBB 00 20 00 00 
0095++ 1DBF 70 88 98 A8                 .db      $70,$88,$98,$A8,$A8,$98,$40,$00         ; 64
0095++ 1DC3 A8 98 40 00 
0096++ 1DC7 70 88 88 F8                 .db      $70,$88,$88,$F8,$88,$88,$00,$00         ; 65
0096++ 1DCB 88 88 00 00 
0097++ 1DCF E0 90 E0 90                 .db      $E0,$90,$E0,$90,$88,$F0,$00,$00         ; 66
0097++ 1DD3 88 F0 00 00 
0098++ 1DD7 70 88 80 80                 .db      $70,$88,$80,$80,$88,$70,$00,$00         ; 67
0098++ 1DDB 88 70 00 00 
0099++ 1DDF F0 48 48 48                 .db      $F0,$48,$48,$48,$48,$F0,$00,$00         ; 68
0099++ 1DE3 48 F0 00 00 
0100++ 1DE7 F8 80 E0 80                 .db      $F8,$80,$E0,$80,$80,$F8,$00,$00         ; 69
0100++ 1DEB 80 F8 00 00 
0101++ 1DEF F8 80 80 E0                 .db      $F8,$80,$80,$E0,$80,$80,$00,$00         ; 70
0101++ 1DF3 80 80 00 00 
0102++ 1DF7 70 88 80 B8                 .db      $70,$88,$80,$B8,$88,$70,$00,$00         ; 71
0102++ 1DFB 88 70 00 00 
0103++ 1DFF 88 88 F8 88                 .db      $88,$88,$F8,$88,$88,$88,$00,$00         ; 72
0103++ 1E03 88 88 00 00 
0104++ 1E07 70 20 20 20                 .db      $70,$20,$20,$20,$20,$70,$00,$00         ; 73
0104++ 1E0B 20 70 00 00 
0105++ 1E0F 38 08 08 08                 .db      $38,$08,$08,$08,$88,$70,$00,$00         ; 74
0105++ 1E13 88 70 00 00 
0106++ 1E17 88 90 A0 E0                 .db      $88,$90,$A0,$E0,$90,$88,$00,$00         ; 75
0106++ 1E1B 90 88 00 00 
0107++ 1E1F 80 80 80 80                 .db      $80,$80,$80,$80,$80,$F8,$00,$00         ; 76
0107++ 1E23 80 F8 00 00 
0108++ 1E27 D8 A8 A8 88                 .db      $D8,$A8,$A8,$88,$88,$88,$00,$00         ; 77
0108++ 1E2B 88 88 00 00 
0109++ 1E2F C8 A8 A8 98                 .db      $C8,$A8,$A8,$98,$98,$88,$00,$00         ; 78
0109++ 1E33 98 88 00 00 
0110++ 1E37 70 88 88 88                 .db      $70,$88,$88,$88,$88,$70,$00,$00         ; 79
0110++ 1E3B 88 70 00 00 
0111++ 1E3F F0 88 88 F0                 .db      $F0,$88,$88,$F0,$80,$80,$00,$00         ; 80
0111++ 1E43 80 80 00 00 
0112++ 1E47 70 88 88 A8                 .db      $70,$88,$88,$A8,$90,$68,$00,$00         ; 81
0112++ 1E4B 90 68 00 00 
0113++ 1E4F F0 88 88 F0                 .db      $F0,$88,$88,$F0,$A0,$98,$00,$00         ; 82
0113++ 1E53 A0 98 00 00 
0114++ 1E57 70 80 70 08                 .db      $70,$80,$70,$08,$08,$F0,$00,$00         ; 83
0114++ 1E5B 08 F0 00 00 
0115++ 1E5F F8 20 20 20                 .db      $F8,$20,$20,$20,$20,$20,$00,$00         ; 84
0115++ 1E63 20 20 00 00 
0116++ 1E67 88 88 88 88                 .db      $88,$88,$88,$88,$88,$78,$00,$00         ; 85
0116++ 1E6B 88 78 00 00 
0117++ 1E6F 88 88 88 50                 .db      $88,$88,$88,$50,$50,$20,$00,$00         ; 86
0117++ 1E73 50 20 00 00 
0118++ 1E77 88 88 A8 A8                 .db      $88,$88,$A8,$A8,$A8,$D8,$00,$00         ; 87
0118++ 1E7B A8 D8 00 00 
0119++ 1E7F 88 50 20 50                 .db      $88,$50,$20,$50,$88,$88,$00,$00         ; 88
0119++ 1E83 88 88 00 00 
0120++ 1E87 88 88 70 20                 .db      $88,$88,$70,$20,$20,$20,$00,$00         ; 89
0120++ 1E8B 20 20 00 00 
0121++ 1E8F F8 10 20 40                 .db      $F8,$10,$20,$40,$80,$F8,$00,$00         ; 90
0121++ 1E93 80 F8 00 00 
0122++ 1E97 70 40 40 40                 .db      $70,$40,$40,$40,$40,$70,$00,$00         ; 91
0122++ 1E9B 40 70 00 00 
0123++ 1E9F 00 80 40 20                 .db      $00,$80,$40,$20,$10,$08,$00,$00         ; 92
0123++ 1EA3 10 08 00 00 
0124++ 1EA7 70 10 10 10                 .db      $70,$10,$10,$10,$10,$70,$00,$00         ; 93
0124++ 1EAB 10 70 00 00 
0125++ 1EAF 40 A0 00 00                 .db      $40,$A0,$00,$00,$00,$00,$00,$00         ; 94
0125++ 1EB3 00 00 00 00 
0126++ 1EB7 00 00 00 00                 .db      $00,$00,$00,$00,$00,$00,$F8,$00         ; 95
0126++ 1EBB 00 00 F8 00 
0127++ 1EBF 20 10 00 00                 .db      $20,$10,$00,$00,$00,$00,$00,$00         ; 96
0127++ 1EC3 00 00 00 00 
0128++ 1EC7 00 00 78 88                 .db      $00,$00,$78,$88,$98,$68,$00,$00         ; 97
0128++ 1ECB 98 68 00 00 
0129++ 1ECF 80 80 F0 88                 .db      $80,$80,$F0,$88,$88,$F0,$00,$00         ; 98
0129++ 1ED3 88 F0 00 00 
0130++ 1ED7 00 00 78 80                 .db      $00,$00,$78,$80,$80,$78,$00,$00         ; 99
0130++ 1EDB 80 78 00 00 
0131++ 1EDF 08 08 78 88                 .db      $08,$08,$78,$88,$88,$78,$00,$00         ; 100
0131++ 1EE3 88 78 00 00 
0132++ 1EE7 00 00 70 98                 .db      $00,$00,$70,$98,$E0,$78,$00,$00         ; 101
0132++ 1EEB E0 78 00 00 
0133++ 1EEF 30 48 40 40                 .db      $30,$48,$40,$40,$E0,$40,$40,$40         ; 102
0133++ 1EF3 E0 40 40 40 
0134++ 1EF7 00 00 78 88                 .db      $00,$00,$78,$88,$88,$78,$08,$70         ; 103
0134++ 1EFB 88 78 08 70 
0135++ 1EFF 80 80 F0 88                 .db      $80,$80,$F0,$88,$88,$88,$00,$00         ; 104
0135++ 1F03 88 88 00 00 
0136++ 1F07 20 00 60 20                 .db      $20,$00,$60,$20,$20,$70,$00,$00         ; 105
0136++ 1F0B 20 70 00 00 
0137++ 1F0F 10 00 30 10                 .db      $10,$00,$30,$10,$10,$10,$10,$60         ; 106
0137++ 1F13 10 10 10 60 
0138++ 1F17 80 80 98 A0                 .db      $80,$80,$98,$A0,$E0,$98,$00,$00         ; 107
0138++ 1F1B E0 98 00 00 
0139++ 1F1F C0 40 40 40                 .db      $C0,$40,$40,$40,$40,$70,$00,$00         ; 108
0139++ 1F23 40 70 00 00 
0140++ 1F27 00 00 F0 A8                 .db      $00,$00,$F0,$A8,$A8,$A8,$00,$00         ; 109
0140++ 1F2B A8 A8 00 00 
0141++ 1F2F 00 00 F0 88                 .db      $00,$00,$F0,$88,$88,$88,$00,$00         ; 110
0141++ 1F33 88 88 00 00 
0142++ 1F37 00 00 70 88                 .db      $00,$00,$70,$88,$88,$70,$00,$00         ; 111
0142++ 1F3B 88 70 00 00 
0143++ 1F3F 00 00 F0 88                 .db      $00,$00,$F0,$88,$88,$F0,$80,$80         ; 112
0143++ 1F43 88 F0 80 80 
0144++ 1F47 00 00 78 88                 .db      $00,$00,$78,$88,$88,$78,$08,$08         ; 113
0144++ 1F4B 88 78 08 08 
0145++ 1F4F 00 00 B8 C0                 .db      $00,$00,$B8,$C0,$80,$80,$00,$00         ; 114
0145++ 1F53 80 80 00 00 
0146++ 1F57 00 00 78 F0                 .db      $00,$00,$78,$F0,$08,$F0,$00,$00         ; 115
0146++ 1F5B 08 F0 00 00 
0147++ 1F5F 40 40 F0 40                 .db      $40,$40,$F0,$40,$48,$30,$00,$00         ; 116
0147++ 1F63 48 30 00 00 
0148++ 1F67 00 00 88 88                 .db      $00,$00,$88,$88,$88,$78,$00,$00         ; 117
0148++ 1F6B 88 78 00 00 
0149++ 1F6F 00 00 88 88                 .db      $00,$00,$88,$88,$50,$20,$00,$00         ; 118
0149++ 1F73 50 20 00 00 
0150++ 1F77 00 00 88 A8                 .db      $00,$00,$88,$A8,$A8,$D8,$00,$00         ; 119
0150++ 1F7B A8 D8 00 00 
0151++ 1F7F 00 00 C8 30                 .db      $00,$00,$C8,$30,$60,$98,$00,$00         ; 120
0151++ 1F83 60 98 00 00 
0152++ 1F87 00 00 88 88                 .db      $00,$00,$88,$88,$88,$78,$08,$70         ; 121
0152++ 1F8B 88 78 08 70 
0153++ 1F8F 00 00 F8 30                 .db      $00,$00,$F8,$30,$40,$F8,$00,$00         ; 122
0153++ 1F93 40 F8 00 00 
0154++ 1F97 10 20 20 40                 .db      $10,$20,$20,$40,$20,$20,$10,$00         ; 123
0154++ 1F9B 20 20 10 00 
0155++ 1F9F 20 20 20 20                 .db      $20,$20,$20,$20,$20,$20,$20,$00         ; 124
0155++ 1FA3 20 20 20 00 
0156++ 1FA7 40 20 20 10                 .db      $40,$20,$20,$10,$20,$20,$40,$00         ; 125
0156++ 1FAB 20 20 40 00 
0157++ 1FAF 50 A0 00 00                 .db      $50,$A0,$00,$00,$00,$00,$00,$00         ; 126
0157++ 1FB3 00 00 00 00 
0158++ 1FB7 00 20 50 50                 .db      $00,$20,$50,$50,$F8,$00,$00,$00         ; 127
0158++ 1FBB F8 00 00 00 
0159++ 1FBF 70 88 80 80                 .db      $70,$88,$80,$80,$88,$70,$20,$40         ; 128
0159++ 1FC3 88 70 20 40 
0160++ 1FC7 50 00 88 88                 .db      $50,$00,$88,$88,$88,$78,$00,$00         ; 129
0160++ 1FCB 88 78 00 00 
0161++ 1FCF 08 10 70 98                 .db      $08,$10,$70,$98,$E0,$78,$00,$00         ; 130
0161++ 1FD3 E0 78 00 00 
0162++ 1FD7 20 50 78 88                 .db      $20,$50,$78,$88,$98,$68,$00,$00         ; 131
0162++ 1FDB 98 68 00 00 
0163++ 1FDF 50 00 78 88                 .db      $50,$00,$78,$88,$98,$68,$00,$00         ; 132
0163++ 1FE3 98 68 00 00 
0164++ 1FE7 40 20 78 88                 .db      $40,$20,$78,$88,$98,$68,$00,$00         ; 133
0164++ 1FEB 98 68 00 00 
0165++ 1FEF 20 00 78 88                 .db      $20,$00,$78,$88,$98,$68,$00,$00         ; 134
0165++ 1FF3 98 68 00 00 
0166++ 1FF7 00 00 78 80                 .db      $00,$00,$78,$80,$80,$78,$20,$40         ; 135
0166++ 1FFB 80 78 20 40 
0167++ 1FFF 20 50 70 98                 .db      $20,$50,$70,$98,$E0,$78,$00,$00         ; 136
0167++ 2003 E0 78 00 00 
0168++ 2007 50 00 70 98                 .db      $50,$00,$70,$98,$E0,$78,$00,$00         ; 137
0168++ 200B E0 78 00 00 
0169++ 200F 40 20 70 98                 .db      $40,$20,$70,$98,$E0,$78,$00,$00         ; 138
0169++ 2013 E0 78 00 00 
0170++ 2017 50 00 60 20                 .db      $50,$00,$60,$20,$20,$70,$00,$00         ; 139
0170++ 201B 20 70 00 00 
0171++ 201F 20 50 60 20                 .db      $20,$50,$60,$20,$20,$70,$00,$00         ; 140
0171++ 2023 20 70 00 00 
0172++ 2027 40 20 60 20                 .db      $40,$20,$60,$20,$20,$70,$00,$00         ; 141
0172++ 202B 20 70 00 00 
0173++ 202F 50 70 88 88                 .db      $50,$70,$88,$88,$F8,$88,$00,$00         ; 142
0173++ 2033 F8 88 00 00 
0174++ 2037 20 70 88 88                 .db      $20,$70,$88,$88,$F8,$88,$00,$00         ; 143
0174++ 203B F8 88 00 00 
0175++ 203F 18 F8 80 E0                 .db      $18,$F8,$80,$E0,$80,$F8,$00,$00         ; 144
0175++ 2043 80 F8 00 00 
0176++ 2047 00 00 D0 68                 .db      $00,$00,$D0,$68,$B0,$D8,$00,$00         ; 145
0176++ 204B B0 D8 00 00 
0177++ 204F 78 A0 B0 E0                 .db      $78,$A0,$B0,$E0,$A0,$B8,$00,$00         ; 146
0177++ 2053 A0 B8 00 00 
0178++ 2057 20 50 70 88                 .db      $20,$50,$70,$88,$88,$70,$00,$00         ; 147
0178++ 205B 88 70 00 00 
0179++ 205F 50 00 70 88                 .db      $50,$00,$70,$88,$88,$70,$00,$00         ; 148
0179++ 2063 88 70 00 00 
0180++ 2067 40 20 70 88                 .db      $40,$20,$70,$88,$88,$70,$00,$00         ; 149
0180++ 206B 88 70 00 00 
0181++ 206F 20 50 88 88                 .db      $20,$50,$88,$88,$88,$78,$00,$00         ; 150
0181++ 2073 88 78 00 00 
0182++ 2077 40 20 88 88                 .db      $40,$20,$88,$88,$88,$78,$00,$00         ; 151
0182++ 207B 88 78 00 00 
0183++ 207F 50 00 88 88                 .db      $50,$00,$88,$88,$88,$78,$08,$70         ; 152
0183++ 2083 88 78 08 70 
0184++ 2087 50 70 88 88                 .db      $50,$70,$88,$88,$88,$70,$00,$00         ; 153
0184++ 208B 88 70 00 00 
0185++ 208F 50 88 88 88                 .db      $50,$88,$88,$88,$88,$70,$00,$00         ; 154
0185++ 2093 88 70 00 00 
0186++ 2097 20 20 78 80                 .db      $20,$20,$78,$80,$80,$78,$20,$20         ; 155
0186++ 209B 80 78 20 20 
0187++ 209F 20 50 40 E0                 .db      $20,$50,$40,$E0,$40,$48,$B0,$00         ; 156
0187++ 20A3 40 48 B0 00 
0188++ 20A7 88 88 50 F8                 .db      $88,$88,$50,$F8,$20,$70,$20,$00         ; 157
0188++ 20AB 20 70 20 00 
0189++ 20AF 80 D0 B0 B0                 .db      $80,$D0,$B0,$B0,$B8,$D0,$88,$80         ; 158
0189++ 20B3 B8 D0 88 80 
0190++ 20B7 38 40 F0 40                 .db      $38,$40,$F0,$40,$F0,$40,$38,$00         ; 159
0190++ 20BB F0 40 38 00 
0191++ 20BF 08 10 78 88                 .db      $08,$10,$78,$88,$98,$68,$00,$00         ; 160
0191++ 20C3 98 68 00 00 
0192++ 20C7 10 20 60 20                 .db      $10,$20,$60,$20,$20,$70,$00,$00         ; 161
0192++ 20CB 20 70 00 00 
0193++ 20CF 10 20 70 88                 .db      $10,$20,$70,$88,$88,$70,$00,$00         ; 162
0193++ 20D3 88 70 00 00 
0194++ 20D7 10 20 88 88                 .db      $10,$20,$88,$88,$88,$78,$00,$00         ; 163
0194++ 20DB 88 78 00 00 
0195++ 20DF 28 50 F0 88                 .db      $28,$50,$F0,$88,$88,$88,$00,$00         ; 164
0195++ 20E3 88 88 00 00 
0196++ 20E7 28 D0 A8 A8                 .db      $28,$D0,$A8,$A8,$98,$88,$00,$00         ; 165
0196++ 20EB 98 88 00 00 
0197++ 20EF 00 00 78 88                 .db      $00,$00,$78,$88,$98,$68,$00,$70         ; 166
0197++ 20F3 98 68 00 70 
0198++ 20F7 00 00 70 88                 .db      $00,$00,$70,$88,$88,$70,$00,$70         ; 167
0198++ 20FB 88 70 00 70 
0199++ 20FF 20 00 20 60                 .db      $20,$00,$20,$60,$88,$70,$00,$00         ; 168
0199++ 2103 88 70 00 00 
0200++ 2107 00 00 00 E0                 .db      $00,$00,$00,$E0,$80,$00,$00,$00         ; 169
0200++ 210B 80 00 00 00 
0201++ 210F 00 00 00 E0                 .db      $00,$00,$00,$E0,$20,$00,$00,$00         ; 170
0201++ 2113 20 00 00 00 
0202++ 2117 40 48 50 30                 .db      $40,$48,$50,$30,$48,$90,$38,$00         ; 171
0202++ 211B 48 90 38 00 
0203++ 211F 40 48 50 28                 .db      $40,$48,$50,$28,$58,$B8,$08,$00         ; 172
0203++ 2123 58 B8 08 00 
0204++ 2127 20 00 20 20                 .db      $20,$00,$20,$20,$20,$20,$00,$00         ; 173
0204++ 212B 20 20 00 00 
0205++ 212F 00 00 00 48                 .db      $00,$00,$00,$48,$90,$48,$00,$00         ; 174
0205++ 2133 90 48 00 00 
0206++ 2137 00 00 00 90                 .db      $00,$00,$00,$90,$48,$90,$00,$00         ; 175
0206++ 213B 48 90 00 00 
0207++ 213F 28 50 70 88                 .db      $28,$50,$70,$88,$F8,$88,$00,$00         ; 176
0207++ 2143 F8 88 00 00 
0208++ 2147 28 50 78 88                 .db      $28,$50,$78,$88,$98,$68,$00,$00         ; 177
0208++ 214B 98 68 00 00 
0209++ 214F 28 50 70 20                 .db      $28,$50,$70,$20,$20,$70,$00,$00         ; 178
0209++ 2153 20 70 00 00 
0210++ 2157 28 50 60 20                 .db      $28,$50,$60,$20,$20,$70,$00,$00         ; 179
0210++ 215B 20 70 00 00 
0211++ 215F 28 70 88 88                 .db      $28,$70,$88,$88,$88,$70,$00,$00         ; 180
0211++ 2163 88 70 00 00 
0212++ 2167 28 50 70 88                 .db      $28,$50,$70,$88,$88,$70,$00,$00         ; 181
0212++ 216B 88 70 00 00 
0213++ 216F 28 50 88 88                 .db      $28,$50,$88,$88,$88,$78,$00,$00         ; 182
0213++ 2173 88 78 00 00 
0214++ 2177 28 50 00 88                 .db      $28,$50,$00,$88,$88,$78,$00,$00         ; 183
0214++ 217B 88 78 00 00 
0215++ 217F FC 48 48 48                 .db      $FC,$48,$48,$48,$48,$E8,$08,$30         ; 184
0215++ 2183 48 E8 08 30 
0216++ 2187 48 00 D8 48                 .db      $48,$00,$D8,$48,$48,$E8,$08,$30         ; 185
0216++ 218B 48 E8 08 30 
0217++ 218F E0 68 30 E8                 .db      $E0,$68,$30,$E8,$58,$B8,$08,$00         ; 186
0217++ 2193 58 B8 08 00 
0218++ 2197 50 28 00 00                 .db      $50,$28,$00,$00,$00,$00,$00,$00         ; 187
0218++ 219B 00 00 00 00 
0219++ 219F 00 20 50 88                 .db      $00,$20,$50,$88,$50,$20,$00,$00         ; 188
0219++ 21A3 50 20 00 00 
0220++ 21A7 00 48 50 20                 .db      $00,$48,$50,$20,$68,$A8,$00,$00         ; 189
0220++ 21AB 68 A8 00 00 
0221++ 21AF 7C A8 A8 A8                 .db      $7C,$A8,$A8,$A8,$68,$28,$28,$44         ; 190
0221++ 21B3 68 28 28 44 
0222++ 21B7 70 80 70 88                 .db      $70,$80,$70,$88,$70,$08,$88,$70         ; 191
0222++ 21BB 70 08 88 70 
0223++ 21BF 00 00 00 00                 .db      $00,$00,$00,$00,$00,$00,$FF,$FF         ; 192
0223++ 21C3 00 00 FF FF 
0224++ 21C7 F0 F0 F0 F0                 .db      $F0,$F0,$F0,$F0,$0F,$0F,$0F,$0F         ; 193
0224++ 21CB 0F 0F 0F 0F 
0225++ 21CF 00 00 FF FF                 .db      $00,$00,$FF,$FF,$FF,$FF,$FF,$FF         ; 194
0225++ 21D3 FF FF FF FF 
0226++ 21D7 FF FF 00 00                 .db      $FF,$FF,$00,$00,$00,$00,$00,$00         ; 195
0226++ 21DB 00 00 00 00 
0227++ 21DF 00 00 00 3C                 .db      $00,$00,$00,$3C,$3C,$00,$00,$00         ; 196
0227++ 21E3 3C 00 00 00 
0228++ 21E7 FF FF FF FF                 .db      $FF,$FF,$FF,$FF,$FF,$FF,$00,$00         ; 197
0228++ 21EB FF FF 00 00 
0229++ 21EF C0 C0 C0 C0                 .db      $C0,$C0,$C0,$C0,$C0,$C0,$C0,$C0         ; 198
0229++ 21F3 C0 C0 C0 C0 
0230++ 21F7 0F 0F 0F 0F                 .db      $0F,$0F,$0F,$0F,$F0,$F0,$F0,$F0         ; 199
0230++ 21FB F0 F0 F0 F0 
0231++ 21FF FC FC FC FC                 .db      $FC,$FC,$FC,$FC,$FC,$FC,$FC,$FC         ; 200
0231++ 2203 FC FC FC FC 
0232++ 2207 03 03 03 03                 .db      $03,$03,$03,$03,$03,$03,$03,$03         ; 201
0232++ 220B 03 03 03 03 
0233++ 220F 3F 3F 3F 3F                 .db      $3F,$3F,$3F,$3F,$3F,$3F,$3F,$3F         ; 202
0233++ 2213 3F 3F 3F 3F 
0234++ 2217 11 22 44 88                 .db      $11,$22,$44,$88,$11,$22,$44,$88         ; 203
0234++ 221B 11 22 44 88 
0235++ 221F 88 44 22 11                 .db      $88,$44,$22,$11,$88,$44,$22,$11         ; 204
0235++ 2223 88 44 22 11 
0236++ 2227 FE 7C 38 10                 .db      $FE,$7C,$38,$10,$00,$00,$00,$00         ; 205
0236++ 222B 00 00 00 00 
0237++ 222F 00 00 00 00                 .db      $00,$00,$00,$00,$10,$38,$7C,$FE         ; 206
0237++ 2233 10 38 7C FE 
0238++ 2237 80 C0 E0 F0                 .db      $80,$C0,$E0,$F0,$E0,$C0,$80,$00         ; 207
0238++ 223B E0 C0 80 00 
0239++ 223F 01 03 07 0F                 .db      $01,$03,$07,$0F,$07,$03,$01,$00         ; 208
0239++ 2243 07 03 01 00 
0240++ 2247 FF 7E 3C 18                 .db      $FF,$7E,$3C,$18,$18,$3C,$7E,$FF         ; 209
0240++ 224B 18 3C 7E FF 
0241++ 224F 81 C3 E7 FF                 .db      $81,$C3,$E7,$FF,$FF,$E7,$C3,$81         ; 210
0241++ 2253 FF E7 C3 81 
0242++ 2257 F0 F0 F0 F0                 .db      $F0,$F0,$F0,$F0,$00,$00,$00,$00         ; 211
0242++ 225B 00 00 00 00 
0243++ 225F 00 00 00 00                 .db      $00,$00,$00,$00,$0F,$0F,$0F,$0F         ; 212
0243++ 2263 0F 0F 0F 0F 
0244++ 2267 0F 0F 0F 0F                 .db      $0F,$0F,$0F,$0F,$00,$00,$00,$00         ; 213
0244++ 226B 00 00 00 00 
0245++ 226F 00 00 00 00                 .db      $00,$00,$00,$00,$F0,$F0,$F0,$F0         ; 214
0245++ 2273 F0 F0 F0 F0 
0246++ 2277 33 33 CC CC                 .db      $33,$33,$CC,$CC,$33,$33,$CC,$CC         ; 215
0246++ 227B 33 33 CC CC 
0247++ 227F 00 10 28 28                 .db      $00,$10,$28,$28,$7C,$00,$00,$00         ; 216
0247++ 2283 7C 00 00 00 
0248++ 2287 10 10 38 10                 .db      $10,$10,$38,$10,$38,$10,$10,$00         ; 217
0248++ 228B 38 10 10 00 
0249++ 228F 00 00 50 88                 .db      $00,$00,$50,$88,$A8,$50,$00,$00         ; 218
0249++ 2293 A8 50 00 00 
0250++ 2297 FF FF FF FF                 .db      $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF         ; 219
0250++ 229B FF FF FF FF 
0251++ 229F 00 00 00 00                 .db      $00,$00,$00,$00,$FF,$FF,$FF,$FF         ; 220
0251++ 22A3 FF FF FF FF 
0252++ 22A7 F0 F0 F0 F0                 .db      $F0,$F0,$F0,$F0,$F0,$F0,$F0,$F0         ; 221
0252++ 22AB F0 F0 F0 F0 
0253++ 22AF 0F 0F 0F 0F                 .db      $0F,$0F,$0F,$0F,$0F,$0F,$0F,$0F         ; 222
0253++ 22B3 0F 0F 0F 0F 
0254++ 22B7 FF FF FF FF                 .db      $FF,$FF,$FF,$FF,$00,$00,$00,$00         ; 223
0254++ 22BB 00 00 00 00 
0255++ 22BF 00 00 68 90                 .db      $00,$00,$68,$90,$90,$68,$00,$00         ; 224
0255++ 22C3 90 68 00 00 
0256++ 22C7 60 90 E0 90                 .db      $60,$90,$E0,$90,$90,$E0,$80,$00         ; 225
0256++ 22CB 90 E0 80 00 
0257++ 22CF F8 88 80 80                 .db      $F8,$88,$80,$80,$80,$80,$00,$00         ; 226
0257++ 22D3 80 80 00 00 
0258++ 22D7 F8 50 50 50                 .db      $F8,$50,$50,$50,$50,$48,$80,$00         ; 227
0258++ 22DB 50 48 80 00 
0259++ 22DF F8 48 20 40                 .db      $F8,$48,$20,$40,$88,$F8,$00,$00         ; 228
0259++ 22E3 88 F8 00 00 
0260++ 22E7 00 00 78 90                 .db      $00,$00,$78,$90,$88,$70,$00,$00         ; 229
0260++ 22EB 88 70 00 00 
0261++ 22EF 00 00 88 88                 .db      $00,$00,$88,$88,$C8,$B0,$80,$80         ; 230
0261++ 22F3 C8 B0 80 80 
0262++ 22F7 00 00 50 50                 .db      $00,$00,$50,$50,$20,$50,$50,$20         ; 231
0262++ 22FB 20 50 50 20 
0263++ 22FF 70 20 70 A8                 .db      $70,$20,$70,$A8,$A8,$70,$20,$70         ; 232
0263++ 2303 A8 70 20 70 
0264++ 2307 70 88 F8 88                 .db      $70,$88,$F8,$88,$88,$70,$00,$00         ; 233
0264++ 230B 88 70 00 00 
0265++ 230F 70 88 88 88                 .db      $70,$88,$88,$88,$50,$D8,$00,$00         ; 234
0265++ 2313 50 D8 00 00 
0266++ 2317 30 40 30 48                 .db      $30,$40,$30,$48,$48,$30,$00,$00         ; 235
0266++ 231B 48 30 00 00 
0267++ 231F 00 00 50 A8                 .db      $00,$00,$50,$A8,$A8,$50,$00,$00         ; 236
0267++ 2323 A8 50 00 00 
0268++ 2327 00 10 70 A8                 .db      $00,$10,$70,$A8,$A8,$70,$40,$00         ; 237
0268++ 232B A8 70 40 00 
0269++ 232F 00 70 80 E0                 .db      $00,$70,$80,$E0,$80,$70,$00,$00         ; 238
0269++ 2333 80 70 00 00 
0270++ 2337 70 88 88 88                 .db      $70,$88,$88,$88,$88,$88,$00,$00         ; 239
0270++ 233B 88 88 00 00 
0271++ 233F 00 F8 00 F8                 .db      $00,$F8,$00,$F8,$00,$F8,$00,$00         ; 240
0271++ 2343 00 F8 00 00 
0272++ 2347 00 20 20 F8                 .db      $00,$20,$20,$F8,$20,$20,$F8,$00         ; 241
0272++ 234B 20 20 F8 00 
0273++ 234F 00 C0 30 08                 .db      $00,$C0,$30,$08,$30,$C0,$F8,$00         ; 242
0273++ 2353 30 C0 F8 00 
0274++ 2357 00 18 60 80                 .db      $00,$18,$60,$80,$60,$18,$F8,$00         ; 243
0274++ 235B 60 18 F8 00 
0275++ 235F 00 18 20 20                 .db      $00,$18,$20,$20,$20,$20,$20,$20         ; 244
0275++ 2363 20 20 20 20 
0276++ 2367 20 20 20 20                 .db      $20,$20,$20,$20,$20,$20,$C0,$00         ; 245
0276++ 236B 20 20 C0 00 
0277++ 236F 00 20 00 F8                 .db      $00,$20,$00,$F8,$00,$20,$00,$00         ; 246
0277++ 2373 00 20 00 00 
0278++ 2377 00 68 B0 00                 .db      $00,$68,$B0,$00,$68,$B0,$00,$00         ; 247
0278++ 237B 68 B0 00 00 
0279++ 237F 00 30 48 48                 .db      $00,$30,$48,$48,$30,$00,$00,$00         ; 248
0279++ 2383 30 00 00 00 
0280++ 2387 00 30 78 78                 .db      $00,$30,$78,$78,$30,$00,$00,$00         ; 249
0280++ 238B 30 00 00 00 
0281++ 238F 00 00 00 00                 .db      $00,$00,$00,$00,$30,$00,$00,$00         ; 250
0281++ 2393 30 00 00 00 
0282++ 2397 1C 10 10 90                 .db      $1C,$10,$10,$90,$50,$30,$10,$00         ; 251
0282++ 239B 50 30 10 00 
0283++ 239F E0 90 90 00                 .db      $E0,$90,$90,$00,$00,$00,$00,$00         ; 252
0283++ 23A3 00 00 00 00 
0284++ 23A7 60 10 60 F0                 .db      $60,$10,$60,$F0,$00,$00,$00,$00         ; 253
0284++ 23AB 00 00 00 00 
0285++ 23AF 00 70 70 70                 .db      $00,$70,$70,$70,$70,$70,$70,$00         ; 254
0285++ 23B3 70 70 70 00 
0286++ 23B7 AA 55 AA 55                 .db      $AA,$55,$AA,$55,$AA,$55,$AA,$55         ; 255
0286++ 23BB AA 55 AA 55 
0287++ 23BF~                  .ELSE
0288++ 23BF~            ; Japanese Localized font
0289++ 23BF~                      .db        $00,$00,$00,$00,$00,$00,$00,$00                ;1
0290++ 23BF~                      .db        $00,$7C,$44,$7C,$44,$7C,$44,$8C                ;2
0291++ 23BF~                      .db        $00,$20,$A4,$A4,$20,$30,$48,$84                ;3
0292++ 23BF~                      .db        $00,$12,$14,$F8,$38,$54,$92,$10                ;4
0293++ 23BF~                      .db        $00,$10,$7C,$10,$38,$54,$92,$10                ;5
0294++ 23BF~                      .db        $00,$38,$54,$BA,$10,$38,$54,$FE                ;6
0295++ 23BF~                      .db        $00,$10,$10,$7C,$10,$10,$10,$FE                ;7
0296++ 23BF~                      .db        $00,$7C,$44,$44,$7C,$44,$44,$7C                ;8
0297++ 23BF~                      .db        $00,$40,$7C,$90,$7C,$50,$FC,$10                ;9
0298++ 23BF~                      .db        $00,$FC,$A4,$A4,$FC,$84,$84,$84                ;10
0299++ 23BF~                      .db        $00,$04,$EE,$A4,$FE,$AC,$E4,$0C                ;11
0300++ 23BF~                      .db        $00,$28,$44,$82,$7C,$24,$44,$48                ;12
0301++ 23BF~                      .db        $00,$24,$CE,$55,$EC,$62,$D2,$44                ;13
0302++ 23BF~                      .db        $00,$7C,$20,$7C,$44,$7C,$44,$7C                ;14
0303++ 23BF~                      .db        $00,$1C,$70,$10,$FE,$10,$10,$10                ;15
0304++ 23BF~                      .db        $00,$FC,$40,$40,$7C,$44,$84,$88                ;16
0305++ 23BF~                      .db        $00,$00,$7C,$28,$28,$48,$48,$8C                ;17
0306++ 23BF~                      .db        $10,$10,$10,$10,$FF,$00,$00,$00                ;18
0307++ 23BF~                      .db        $00,$00,$00,$00,$FF,$10,$10,$10                ;19
0308++ 23BF~                      .db        $10,$10,$10,$10,$F0,$10,$10,$10                ;20
0309++ 23BF~                      .db        $10,$10,$10,$10,$1F,$10,$10,$10                ;21
0310++ 23BF~                      .db        $10,$10,$10,$10,$FF,$10,$10,$10                ;22
0311++ 23BF~                      .db        $10,$10,$10,$10,$10,$10,$10,$10                ;23
0312++ 23BF~                      .db        $00,$00,$00,$00,$FF,$00,$00,$00                ;24
0313++ 23BF~                      .db        $00,$00,$00,$00,$1F,$10,$10,$10                ;25
0314++ 23BF~                      .db        $00,$00,$00,$00,$F0,$10,$10,$10                ;26
0315++ 23BF~                      .db        $10,$10,$10,$10,$1F,$00,$00,$00                ;27
0316++ 23BF~                      .db        $10,$10,$10,$10,$F0,$00,$00,$00                ;28
0317++ 23BF~                      .db        $81,$42,$24,$18,$18,$24,$42,$81                ;29
0318++ 23BF~                      .db        $00,$10,$7C,$10,$10,$28,$48,$84                ;30
0319++ 23BF~                      .db        $00,$10,$7C,$54,$7C,$10,$10,$10                ;31
0320++ 23BF~                      .db        $00,$10,$10,$54,$54,$94,$10,$30                ;32
0321++ 23BF~                      .db        $00,$00,$00,$00,$00,$00,$00,$00                ;33
0322++ 23BF~                      .db        $00,$18,$18,$18,$18,$18,$00,$18                ;34
0323++ 23BF~                      .db        $00,$6C,$6C,$24,$00,$00,$00,$00                ;35
0324++ 23BF~                      .db        $00,$24,$7E,$24,$7E,$24,$24,$00                ;36
0325++ 23BF~                      .db        $14,$3E,$54,$54,$3E,$15,$15,$3E                ;37
0326++ 23BF~                      .db        $00,$22,$54,$28,$12,$25,$42,$00                ;38
0327++ 23BF~                      .db        $38,$44,$44,$28,$32,$4A,$7C,$00                ;39
0328++ 23BF~                      .db        $00,$60,$60,$20,$00,$00,$00,$00                ;40
0329++ 23BF~                      .db        $00,$08,$10,$10,$10,$10,$08,$00                ;41
0330++ 23BF~                      .db        $00,$10,$08,$08,$08,$08,$10,$00                ;42
0331++ 23BF~                      .db        $00,$10,$54,$38,$10,$38,$54,$00                ;43
0332++ 23BF~                      .db        $00,$00,$10,$10,$7C,$10,$10,$00                ;44
0333++ 23BF~                      .db        $00,$00,$00,$00,$60,$60,$20,$00                ;45
0334++ 23BF~                      .db        $00,$00,$00,$7E,$00,$00,$00,$00                ;46
0335++ 23BF~                      .db        $00,$00,$00,$00,$00,$60,$60,$00                ;47
0336++ 23BF~                      .db        $00,$02,$04,$08,$10,$20,$40,$00                ;48
0337++ 23BF~                      .db        $00,$38,$4C,$54,$54,$64,$38,$00                ;49
0338++ 23BF~                      .db        $00,$10,$30,$10,$10,$10,$38,$00                ;50
0339++ 23BF~                      .db        $00,$38,$44,$04,$38,$40,$7C,$00                ;51
0340++ 23BF~                      .db        $00,$78,$04,$38,$04,$04,$78,$00                ;52
0341++ 23BF~                      .db        $00,$44,$44,$44,$7C,$04,$04,$00                ;53
0342++ 23BF~                      .db        $00,$7C,$40,$78,$04,$04,$78,$00                ;54
0343++ 23BF~                      .db        $00,$38,$40,$78,$44,$44,$38,$00                ;55
0344++ 23BF~                      .db        $00,$7C,$44,$08,$08,$10,$10,$00                ;56
0345++ 23BF~                      .db        $00,$38,$44,$38,$44,$44,$38,$00                ;57
0346++ 23BF~                      .db        $00,$38,$44,$44,$3C,$04,$38,$00                ;58
0347++ 23BF~                      .db        $00,$18,$18,$00,$00,$18,$18,$00                ;59
0348++ 23BF~                      .db        $00,$18,$18,$00,$00,$18,$18,$08                ;60
0349++ 23BF~                      .db        $00,$08,$10,$20,$40,$20,$10,$08                ;61
0350++ 23BF~                      .db        $00,$00,$7C,$00,$7C,$00,$00,$00                ;62
0351++ 23BF~                      .db        $00,$20,$10,$08,$04,$08,$10,$20                ;63
0352++ 23BF~                      .db        $00,$38,$44,$04,$18,$10,$00,$10                ;64
0353++ 23BF~                      .db        $00,$3C,$5A,$6A,$5A,$46,$3C,$00                ;65
0354++ 23BF~                      .db        $00,$10,$28,$28,$7C,$44,$44,$00                ;66
0355++ 23BF~                      .db        $00,$78,$44,$78,$44,$44,$78,$00                ;67
0356++ 23BF~                      .db        $00,$38,$44,$40,$40,$44,$38,$00                ;68
0357++ 23BF~                      .db        $00,$78,$44,$44,$44,$44,$78,$00                ;69
0358++ 23BF~                      .db        $00,$7C,$40,$7C,$40,$40,$7C,$00                ;70
0359++ 23BF~                      .db        $00,$7C,$40,$40,$78,$40,$40,$00                ;71
0360++ 23BF~                      .db        $00,$38,$44,$40,$4E,$44,$38,$00                ;72
0361++ 23BF~                      .db        $00,$44,$44,$7C,$44,$44,$44,$00                ;73
0362++ 23BF~                      .db        $00,$38,$10,$10,$10,$10,$38,$00                ;74
0363++ 23BF~                      .db        $00,$1C,$08,$08,$08,$48,$30,$00                ;75
0364++ 23BF~                      .db        $00,$44,$48,$50,$68,$44,$44,$00                ;76
0365++ 23BF~                      .db        $00,$40,$40,$40,$40,$40,$7C,$00                ;77
0366++ 23BF~                      .db        $00,$44,$6C,$54,$44,$44,$44,$00                ;78
0367++ 23BF~                      .db        $00,$44,$64,$54,$54,$4C,$44,$00                ;79
0368++ 23BF~                      .db        $00,$38,$44,$44,$44,$44,$38,$00                ;80
0369++ 23BF~                      .db        $00,$78,$44,$44,$78,$40,$40,$00                ;81
0370++ 23BF~                      .db        $00,$38,$44,$44,$54,$4C,$3C,$06                ;82
0371++ 23BF~                      .db        $00,$78,$44,$44,$78,$44,$44,$00                ;83
0372++ 23BF~                      .db        $00,$3C,$40,$38,$04,$44,$38,$00                ;84
0373++ 23BF~                      .db        $00,$7C,$10,$10,$10,$10,$10,$00                ;85
0374++ 23BF~                      .db        $00,$44,$44,$44,$44,$44,$38,$00                ;86
0375++ 23BF~                      .db        $00,$44,$44,$28,$28,$10,$10,$00                ;87
0376++ 23BF~                      .db        $00,$54,$54,$54,$54,$28,$28,$00                ;88
0377++ 23BF~                      .db        $00,$44,$28,$10,$10,$28,$44,$00                ;89
0378++ 23BF~                      .db        $00,$44,$44,$28,$10,$10,$10,$00                ;90
0379++ 23BF~                      .db        $00,$7C,$04,$08,$10,$20,$7C,$00                ;91
0380++ 23BF~                      .db        $00,$38,$20,$20,$20,$20,$38,$00                ;92
0381++ 23BF~                      .db        $00,$44,$28,$7C,$10,$7C,$10,$00                ;93
0382++ 23BF~                      .db        $00,$38,$08,$08,$08,$08,$38,$00                ;94
0383++ 23BF~                      .db        $00,$10,$28,$44,$00,$00,$00,$00                ;95
0384++ 23BF~                      .db        $00,$00,$00,$00,$00,$00,$7C,$00                ;96
0385++ 23BF~                      .db        $00,$30,$30,$10,$00,$00,$00,$00                ;97
0386++ 23BF~                      .db        $00,$00,$38,$04,$3C,$44,$3C,$00                ;98
0387++ 23BF~                      .db        $00,$40,$40,$78,$44,$44,$78,$00                ;99
0388++ 23BF~                      .db        $00,$00,$38,$44,$40,$44,$38,$00                ;100
0389++ 23BF~                      .db        $00,$04,$04,$3C,$44,$44,$3C,$00                ;101
0390++ 23BF~                      .db        $00,$00,$38,$44,$7C,$40,$3C,$00                ;102
0391++ 23BF~                      .db        $00,$08,$10,$38,$10,$10,$10,$00                ;103
0392++ 23BF~                      .db        $00,$00,$3C,$44,$3C,$44,$38,$00                ;104
0393++ 23BF~                      .db        $00,$40,$40,$78,$44,$44,$44,$00                ;105
0394++ 23BF~                      .db        $00,$10,$00,$30,$10,$10,$38,$00                ;106
0395++ 23BF~                      .db        $00,$10,$00,$10,$10,$10,$60,$00                ;107
0396++ 23BF~                      .db        $00,$20,$24,$28,$30,$28,$24,$00                ;108
0397++ 23BF~                      .db        $00,$10,$10,$10,$10,$10,$10,$00                ;109
0398++ 23BF~                      .db        $00,$00,$78,$54,$54,$54,$54,$00                ;110
0399++ 23BF~                      .db        $00,$00,$78,$44,$44,$44,$44,$00                ;111
0400++ 23BF~                      .db        $00,$00,$38,$44,$44,$44,$38,$00                ;112
0401++ 23BF~                      .db        $00,$00,$78,$44,$78,$40,$40,$00                ;113
0402++ 23BF~                      .db        $00,$04,$3C,$44,$3C,$04,$04,$00                ;114
0403++ 23BF~                      .db        $00,$00,$5C,$60,$40,$40,$40,$00                ;115
0404++ 23BF~                      .db        $00,$00,$3C,$40,$38,$04,$78,$00                ;116
0405++ 23BF~                      .db        $00,$20,$78,$20,$20,$20,$18,$00                ;117
0406++ 23BF~                      .db        $00,$00,$48,$48,$48,$48,$34,$00                ;118
0407++ 23BF~                      .db        $00,$00,$44,$44,$44,$28,$10,$00                ;119
0408++ 23BF~                      .db        $00,$00,$54,$54,$54,$54,$28,$00                ;120
0409++ 23BF~                      .db        $00,$00,$44,$28,$10,$28,$44,$00                ;121
0410++ 23BF~                      .db        $00,$00,$44,$28,$10,$10,$20,$00                ;122
0411++ 23BF~                      .db        $00,$00,$7C,$08,$10,$20,$7C,$00                ;123
0412++ 23BF~                      .db        $00,$08,$10,$10,$20,$10,$10,$08                ;124
0413++ 23BF~                      .db        $00,$10,$10,$10,$10,$10,$10,$00                ;125
0414++ 23BF~                      .db        $00,$10,$08,$08,$04,$08,$08,$10                ;126
0415++ 23BF~                      .db        $00,$32,$4C,$00,$00,$00,$00,$00                ;127
0416++ 23BF~                      .db        $00,$00,$00,$00,$00,$00,$00,$00                ;128
0417++ 23BF~                      .db        $00,$18,$3C,$7E,$7E,$18,$3C,$00                ;129
0418++ 23BF~                      .db        $00,$24,$7E,$7E,$7E,$3C,$18,$00                ;130
0419++ 23BF~                      .db        $00,$18,$18,$7E,$7E,$18,$3C,$00                ;131
0420++ 23BF~                      .db        $00,$18,$3C,$7E,$7E,$3C,$18,$00                ;132
0421++ 23BF~                      .db        $00,$3C,$42,$42,$42,$42,$3C,$00                ;133
0422++ 23BF~                      .db        $00,$3C,$7E,$7E,$7E,$7E,$3C,$00                ;134
0423++ 23BF~                      .db        $00,$10,$7C,$20,$78,$54,$28,$3C                ;135
0424++ 23BF~                      .db        $00,$00,$10,$7C,$10,$7C,$5C,$74                ;136
0425++ 23BF~                      .db        $00,$00,$00,$00,$48,$44,$44,$24                ;137
0426++ 23BF~                      .db        $00,$00,$20,$10,$78,$08,$08,$10                ;138
0427++ 23BF~                      .db        $00,$00,$20,$10,$78,$08,$30,$48                ;139
0428++ 23BF~                      .db        $00,$00,$10,$7C,$14,$78,$54,$34                ;140
0429++ 23BF~                      .db        $00,$00,$00,$50,$F8,$54,$48,$20                ;141
0430++ 23BF~                      .db        $00,$00,$00,$50,$7C,$54,$18,$20                ;142
0431++ 23BF~                      .db        $00,$00,$00,$10,$1C,$30,$58,$34                ;143
0432++ 23BF~                      .db        $00,$00,$00,$00,$78,$04,$04,$38                ;144
0433++ 23BF~                      .db        $00,$00,$00,$00,$00,$00,$00,$00                ;145
0434++ 23BF~                      .db        $00,$20,$F8,$20,$7C,$AC,$B4,$74                ;146
0435++ 23BF~                      .db        $00,$00,$88,$88,$84,$84,$A4,$40                ;147
0436++ 23BF~                      .db        $00,$60,$00,$70,$88,$08,$10,$60                ;148
0437++ 23BF~                      .db        $00,$60,$10,$F8,$20,$60,$50,$98                ;149
0438++ 23BF~                      .db        $00,$24,$F4,$20,$78,$A4,$A4,$68                ;150
0439++ 23BF~                      .db        $00,$48,$E4,$54,$50,$90,$10,$60                ;151
0440++ 23BF~                      .db        $00,$40,$F8,$20,$F8,$10,$80,$70                ;152
0441++ 23BF~                      .db        $00,$20,$20,$40,$80,$40,$20,$20                ;153
0442++ 23BF~                      .db        $00,$88,$88,$BC,$88,$88,$88,$50                ;154
0443++ 23BF~                      .db        $00,$00,$F8,$08,$00,$00,$80,$78                ;155
0444++ 23BF~                      .db        $00,$20,$F8,$20,$20,$00,$80,$70                ;156
0445++ 23BF~                      .db        $00,$80,$80,$80,$80,$80,$88,$70                ;157
0446++ 23BF~                      .db        $00,$10,$FC,$30,$50,$30,$10,$60                ;158
0447++ 23BF~                      .db        $00,$48,$FC,$48,$48,$48,$40,$38                ;159
0448++ 23BF~                      .db        $00,$44,$28,$FC,$30,$40,$40,$38                ;160
0449++ 23BF~                      .db        $00,$00,$00,$00,$00,$00,$00,$00                ;161
0450++ 23BF~                      .db        $00,$00,$00,$00,$08,$14,$08,$00                ;162
0451++ 23BF~                      .db        $00,$60,$40,$40,$00,$00,$00,$00                ;163
0452++ 23BF~                      .db        $00,$00,$00,$00,$04,$04,$0C,$00                ;164
0453++ 23BF~                      .db        $00,$00,$00,$00,$10,$08,$08,$00                ;165
0454++ 23BF~                      .db        $00,$00,$00,$30,$30,$00,$00,$00                ;166
0455++ 23BF~                      .db        $00,$00,$00,$7C,$04,$7C,$04,$38                ;167
0456++ 23BF~                      .db        $00,$00,$00,$7C,$04,$14,$10,$20                ;168
0457++ 23BF~                      .db        $00,$00,$00,$08,$18,$70,$10,$10                ;169
0458++ 23BF~                      .db        $00,$00,$00,$10,$7C,$44,$04,$18                ;170
0459++ 23BF~                      .db        $00,$00,$00,$00,$38,$10,$10,$7C                ;171
0460++ 23BF~                      .db        $00,$00,$00,$08,$7C,$18,$28,$48                ;172
0461++ 23BF~                      .db        $00,$00,$00,$20,$7C,$24,$24,$20                ;173
0462++ 23BF~                      .db        $00,$00,$00,$00,$38,$08,$08,$7C                ;174
0463++ 23BF~                      .db        $00,$00,$00,$7C,$04,$7C,$04,$7C                ;175
0464++ 23BF~                      .db        $00,$00,$00,$54,$54,$04,$04,$18                ;176
0465++ 23BF~                      .db        $00,$00,$00,$40,$3C,$00,$00,$00                ;177
0466++ 23BF~                      .db        $00,$7C,$04,$14,$14,$14,$20,$40                ;178
0467++ 23BF~                      .db        $00,$04,$08,$18,$30,$50,$10,$10                ;179
0468++ 23BF~                      .db        $00,$10,$7C,$44,$44,$04,$08,$10                ;180
0469++ 23BF~                      .db        $00,$00,$7C,$10,$10,$10,$10,$7C                ;181
0470++ 23BF~                      .db        $00,$08,$7C,$08,$18,$28,$48,$18                ;182
0471++ 23BF~                      .db        $00,$10,$7C,$14,$24,$24,$44,$08                ;183
0472++ 23BF~                      .db        $00,$10,$7C,$10,$7C,$10,$10,$10                ;184
0473++ 23BF~                      .db        $00,$20,$3C,$24,$44,$08,$08,$30                ;185
0474++ 23BF~                      .db        $00,$20,$3C,$28,$48,$08,$10,$20                ;186
0475++ 23BF~                      .db        $00,$00,$7C,$04,$04,$04,$04,$7C                ;187
0476++ 23BF~                      .db        $00,$28,$7C,$28,$28,$08,$08,$30                ;188
0477++ 23BF~                      .db        $00,$64,$04,$64,$04,$04,$08,$70                ;189
0478++ 23BF~                      .db        $00,$7C,$04,$04,$08,$10,$28,$44                ;190
0479++ 23BF~                      .db        $00,$20,$7C,$24,$20,$20,$20,$1C                ;191
0480++ 23BF~                      .db        $00,$44,$44,$44,$04,$04,$08,$30                ;192
0481++ 23BF~                      .db        $00,$1C,$24,$24,$7C,$04,$08,$10                ;193
0482++ 23BF~                      .db        $00,$04,$78,$10,$7C,$10,$10,$20                ;194
0483++ 23BF~                      .db        $00,$54,$54,$54,$04,$04,$08,$30                ;195
0484++ 23BF~                      .db        $00,$38,$00,$7C,$10,$10,$10,$20                ;196
0485++ 23BF~                      .db        $00,$20,$20,$20,$38,$24,$20,$20                ;197
0486++ 23BF~                      .db        $00,$10,$7C,$10,$10,$10,$10,$20                ;198
0487++ 23BF~                      .db        $00,$00,$38,$00,$00,$00,$00,$7C                ;199
0488++ 23BF~                      .db        $00,$7C,$04,$48,$30,$10,$28,$44                ;200
0489++ 23BF~                      .db        $00,$10,$7C,$08,$38,$54,$54,$10                ;201
0490++ 23BF~                      .db        $00,$08,$08,$08,$08,$10,$10,$60                ;202
0491++ 23BF~                      .db        $00,$08,$08,$48,$44,$44,$44,$44                ;203
0492++ 23BF~                      .db        $00,$40,$78,$40,$40,$40,$40,$3C                ;204
0493++ 23BF~                      .db        $00,$00,$7C,$04,$04,$08,$08,$30                ;205
0494++ 23BF~                      .db        $00,$00,$20,$50,$48,$04,$04,$00                ;206
0495++ 23BF~                      .db        $00,$10,$7C,$10,$10,$54,$54,$10                ;207
0496++ 23BF~                      .db        $00,$00,$7C,$04,$48,$30,$10,$08                ;208
0497++ 23BF~                      .db        $00,$60,$1C,$60,$1C,$00,$60,$1C                ;209
0498++ 23BF~                      .db        $00,$10,$20,$28,$48,$44,$7C,$04                ;210
0499++ 23BF~                      .db        $00,$04,$04,$28,$10,$18,$24,$40                ;211
0500++ 23BF~                      .db        $00,$7C,$20,$20,$7C,$20,$20,$1C                ;212
0501++ 23BF~                      .db        $00,$20,$FC,$24,$24,$10,$10,$10                ;213
0502++ 23BF~                      .db        $00,$78,$08,$08,$08,$08,$08,$7C                ;214
0503++ 23BF~                      .db        $00,$7C,$04,$04,$7C,$04,$04,$7C                ;215
0504++ 23BF~                      .db        $00,$38,$00,$7C,$04,$04,$04,$38                ;216
0505++ 23BF~                      .db        $00,$48,$48,$48,$48,$08,$08,$30                ;217
0506++ 23BF~                      .db        $00,$48,$48,$48,$48,$48,$48,$8C                ;218
0507++ 23BF~                      .db        $00,$40,$40,$40,$40,$44,$48,$70                ;219
0508++ 23BF~                      .db        $00,$7C,$44,$44,$44,$44,$44,$7C                ;220
0509++ 23BF~                      .db        $00,$7C,$44,$44,$04,$04,$04,$38                ;221
0510++ 23BF~                      .db        $00,$64,$04,$04,$04,$08,$08,$70                ;222
0511++ 23BF~                      .db        $00,$00,$50,$28,$00,$00,$00,$00                ;223
0512++ 23BF~                      .db        $00,$20,$50,$20,$00,$00,$00,$00                ;224
0513++ 23BF~                      .db        $00,$20,$78,$20,$5C,$40,$40,$9C                ;225
0514++ 23BF~                      .db        $00,$20,$7C,$20,$78,$84,$04,$18                ;226
0515++ 23BF~                      .db        $00,$00,$38,$C4,$04,$04,$04,$78                ;227
0516++ 23BF~                      .db        $00,$00,$3C,$C8,$10,$20,$20,$18                ;228
0517++ 23BF~                      .db        $00,$84,$48,$30,$20,$40,$40,$3C                ;229
0518++ 23BF~                      .db        $00,$88,$64,$60,$90,$38,$50,$30                ;230
0519++ 23BF~                      .db        $00,$40,$5C,$80,$80,$80,$80,$5C                ;231
0520++ 23BF~                      .db        $00,$80,$44,$78,$D8,$A8,$BC,$58                ;232
0521++ 23BF~                      .db        $00,$48,$D8,$68,$48,$D8,$EC,$58                ;233
0522++ 23BF~                      .db        $00,$00,$38,$54,$94,$A4,$A4,$68                ;234
0523++ 23BF~                      .db        $00,$08,$BC,$88,$88,$B8,$AC,$B4                ;235
0524++ 23BF~                      .db        $00,$00,$6C,$A8,$48,$48,$48,$30                ;236
0525++ 23BF~                      .db        $00,$00,$70,$00,$20,$10,$94,$A4                ;237
0526++ 23BF~                      .db        $00,$00,$00,$30,$48,$88,$84,$04                ;238
0527++ 23BF~                      .db        $00,$00,$9C,$88,$BC,$98,$AC,$58                ;239
0528++ 23BF~                      .db        $00,$20,$FC,$20,$FC,$70,$A8,$64                ;240
0529++ 23BF~                      .db        $00,$00,$E0,$28,$78,$AC,$A8,$50                ;241
0530++ 23BF~                      .db        $00,$28,$F4,$20,$60,$A4,$64,$38                ;242
0531++ 23BF~                      .db        $00,$84,$74,$48,$B4,$94,$AC,$48                ;243
0532++ 23BF~                      .db        $00,$20,$F8,$40,$FC,$40,$40,$38                ;244
0533++ 23BF~                      .db        $00,$90,$5C,$74,$D4,$48,$40,$20                ;245
0534++ 23BF~                      .db        $00,$90,$B8,$D4,$94,$1C,$10,$20                ;246
0535++ 23BF~                      .db        $00,$20,$38,$20,$70,$A8,$A8,$60                ;247
0536++ 23BF~                      .db        $00,$40,$20,$80,$B8,$C8,$08,$30                ;248
0537++ 23BF~                      .db        $00,$90,$88,$88,$88,$08,$10,$20                ;249
0538++ 23BF~                      .db        $00,$78,$10,$30,$C8,$38,$48,$30                ;250
0539++ 23BF~                      .db        $00,$40,$E8,$58,$68,$48,$C8,$4C                ;251
0540++ 23BF~                      .db        $00,$78,$08,$30,$48,$84,$04,$38                ;252
0541++ 23BF~                      .db        $00,$40,$E0,$58,$64,$44,$C4,$58                ;253
0542++ 23BF~                      .db        $00,$10,$10,$20,$30,$50,$68,$CC                ;254
0543++ 23BF~                      .db        $00,$00,$00,$00,$00,$00,$00,$00                ;255
0544++ 23BF~                      .db        $00,$00,$00,$00,$00,$00,$00,$00                ;256
0545++ 23BF                    .ENDIF
0546++ 23BF             
0547++ 23BF             
2421+  23BF             
2422+  23BF                             .include "slot.asm"
0001++ 23BF             CART_SLOT_1_ADDR_HI    .equ     $10
0002++ 23BF             CART_SLOT_1_ADDR_LO    .equ     $11
0003++ 23BF             CART_SLOT_1_ADDR_CONT  .equ     $12
0004++ 23BF             CART_SLOT_1_ADDR_READ  .equ     $13
0005++ 23BF             
0006++ 23BF             
0007++ 23BF             ;-------------------------------------
0008++ 23BF             ; 000Ch RDSLT
0009++ 23BF             ; Reads a value from an address in another slot.
0010++ 23BF             ; Input:   A  = slot ID: E000SSPP
0011++ 23BF             ;          HL = address to read
0012++ 23BF             ; Output:  A  = value read
0013++ 23BF             ;          Interrupts disabled.
0014++ 23BF             ; Changes: F, C, DE
0015++ 23BF             rdslt:
0016++ 23BF C5                          push    bc
0017++ 23C0 E5                          push    hl
0018++ 23C1 F3                          DI
0019++ 23C2 F5                          PUSH	AF
0020++ 23C3 E6 0C       		AND	%00001100	; N8VEM SUPPORTS CART READER IN SLOT 1
0021++ 23C5 FE 04                       CP	%00000100
0022++ 23C7 C2 F5 23                    JP	NZ,RDSLTEXIT	;
0023++ 23CA F1                          POP	AF
0024++ 23CB E6 03       		AND	%00000011	; N8VEM SUPPORTS CART PAGES 1 AND 2
0025++ 23CD FE 01                       CP	%00000001	; SLOT 1?
0026++ 23CF C2 E1 23                    JP	NZ,RDSLTNOTP1	;
0027++ 23D2 7C                          LD	A,H		;
0028++ 23D3 D3 10                       OUT	(CART_SLOT_1_ADDR_HI),A
0029++ 23D5 7D                          LD	A,L		;
0030++ 23D6 D3 11                       OUT	(CART_SLOT_1_ADDR_LO),A
0031++ 23D8 3E 06                       LD	A,%00000110
0032++ 23DA D3 12                       OUT	(CART_SLOT_1_ADDR_CONT),A
0033++ 23DC DB 13                       IN	A,(CART_SLOT_1_ADDR_READ)
0034++ 23DE C3 F8 23                    JP	RDSLTEXIT2
0035++ 23E1             RDSLTNOTP1:                
0036++ 23E1 FE 02                       CP	%00000010	; SLOT 2?
0037++ 23E3 C2 F6 23                    JP	NZ,RDSLTEXIT1	;
0038++ 23E6 7C                          LD	A,H		;
0039++ 23E7 D3 10                       OUT	(CART_SLOT_1_ADDR_HI),A
0040++ 23E9 7D                          LD	A,L		;
0041++ 23EA D3 11                       OUT	(CART_SLOT_1_ADDR_LO),A
0042++ 23EC 3E 05                       LD	A,%00000101
0043++ 23EE D3 12                       OUT	(CART_SLOT_1_ADDR_CONT),A
0044++ 23F0 DB 13                       IN	A,(CART_SLOT_1_ADDR_READ)
0045++ 23F2 C3 F8 23                    JP	RDSLTEXIT2
0046++ 23F5             RDSLTEXIT:
0047++ 23F5 F1          		POP	AF
0048++ 23F6             RDSLTEXIT1:		
0049++ 23F6 3E FF       		LD	A,$FF
0050++ 23F8             RDSLTEXIT2:                
0051++ 23F8             ; TODO: SUPPORT READING SLOTS 0 AND 2 (FROM ALT BANKS ON HC)                                
0052++ 23F8 FB                          EI
0053++ 23F9 E1                          pop     hl              ; HL = address
0054++ 23FA C1                          pop     bc
0055++ 23FB C9                          ret
0056++ 23FC             
0057++ 23FC             rdsft:
0058++ 23FC 04                          inc     b
0059++ 23FD 05                          dec     b
0060++ 23FE C8                          ret     z
0061++ 23FF             rdsft_lp:
0062++ 23FF 07                          rlca
0063++ 2400 07                          rlca
0064++ 2401 10 FC                       djnz    rdsft_lp
0065++ 2403 C9                          ret
0066++ 2404             
0067++ 2404             ;-------------------------------------
0068++ 2404             ; $0014 WRSLT
0069++ 2404             ; Writes a value to an address in another slot.
0070++ 2404             ; Input:   A  = slot ID: E000SSPP
0071++ 2404             ;          HL = address to write
0072++ 2404             ;          E  = value to write
0073++ 2404             ; Output:  Interrupts disabled.
0074++ 2404             ; Changes: AF, BC, D
0075++ 2404             wrslt:
0076++ 2404             		;  WRITING TO A SLOT IS NOT SUPPORTED WITH N8VEM HARDWARE
0077++ 2404 C9          		RET
0078++ 2405             
0079++ 2405             ;-------------------------------------
0080++ 2405             ; $001C CALSLT
0081++ 2405             ; Function : Executes inter-slot call.
0082++ 2405             ; Input    : IY - High byte with input for A in RDSLT
0083++ 2405             ;            IX - The address that will be called
0084++ 2405             ; Remark   : Variables can never be given in alternative registers
0085++ 2405             ;            of the Z-80 or IX and IY
0086++ 2405             
0087++ 2405             calslt:
0088++ 2405             		; EXECUTING CODE FROM CARTS IS NOT SUPPORTED ON THE N8VEM
0089++ 2405             		; TODO: USE BANK SWITCHING TO COPY CODE INTO A RAM BANK AND EXECUTE THERE
0090++ 2405 C9                          ret
0091++ 2406             
0092++ 2406             ;--------------------------------
0093++ 2406             ; 0024h ENASLT
0094++ 2406             ; in .. hl=address, a=slotԍ
0095++ 2406             ; A = FxxxEESS
0096++ 2406             ; RegA ڍ
0097++ 2406             ; F = gXbg̃tO
0098++ 2406             ; E = gXbgԍ
0099++ 2406             ; S = Xbgԍ
0100++ 2406             ; Dest. AF,BC,DE,DI
0101++ 2406             
0102++ 2406             enaslt:
0103++ 2406             		; TODO: USE BANK SWITCHING TO COPY CODE INTO A RAM BANK AND THEN ENABLE
0104++ 2406 C9          		RET
0105++ 2407             
2423+  2407             
2424+  2407             ;---------------------------------
2425+  2407             ; system messages
2426+  2407             ;---------------------------------
2427+  2407             
2428+  2407             str_proginfo:
2429+  2407                             ;       [01234567890123456789012345678]
2430+  2407 4E 38 56 45                 .db     "N8VEM BIOS 0.1     MSX C-BIOS"
2430+  240B 4D 20 42 49 
2430+  240F 4F 53 20 30 
2430+  2413 2E 31 20 20 
2430+  2417 20 20 20 4D 
2430+  241B 53 58 20 43 
2430+  241F 2D 42 49 4F 
2430+  2423 53 
2431+  2424                             ;include "../derived/asm/version.asm"
2432+  2424 0D 0A 0D 0A                 .db      $0D,$0A,$0D,$0A,$0D,$0A,$00
2432+  2428 0D 0A 00 
2433+  242B             
2434+  242B             
2435+  242B             ;-------------------------------------
2436+  242B             ; error messages
2437+  242B             str_error_prompt:
2438+  242B 45 52 52 4F                 .db      "ERROR:",$00
2438+  242F 52 3A 00 
2439+  2432             
2440+  2432             str_no_basic_intr:
2441+  2432 43 41 4C 4C                 .db      "CALLED NON EXISTING BASIC.",$00
2441+  2436 45 44 20 4E 
2441+  243A 4F 4E 20 45 
2441+  243E 58 49 53 54 
2441+  2442 49 4E 47 20 
2441+  2446 42 41 53 49 
2441+  244A 43 2E 00 
2442+  244D             
2443+  244D             str_stack_error:
2444+  244D 53 54 41 43                 .db      "STACK ERROR.",$00
2444+  2451 4B 20 45 52 
2444+  2455 52 4F 52 2E 
2444+  2459 00 
2445+  245A             
2446+  245A             
2447+  245A             ;-------------------------------------
2448+  245A             vdp_bios:
2449+  245A 00 80 70 81                 .db      $00,$80,$70,$81,$00,$82,$01,$84
2449+  245E 00 82 01 84 
2450+  2462 F5 87 00 40                 .db      $F5,$87,$00,$40
2451+  2466             		.include "PS2KEYB.ASM"
0001++ 2466             ;__PS2DRIVER_______________________________________________________________________________________
0002++ 2466             ;
0003++ 2466             ;	PS/2 DRIVER FOR MSX CBIOS 
0004++ 2466             ;
0005++ 2466             ;	ORIGINAL KEYBOARD DRIVERS BY: DR. JAMES MOXHAM
0006++ 2466             ;	REMAINDER WRITTEN BY: DAN WERNER -- 12/4/2010
0007++ 2466             ;__________________________________________________________________________________________________
0008++ 2466             ;
0009++ 2466             
0010++ 2466             
0011++ 2466             ;__KB_INITIALIZE___________________________________________________________________________________
0012++ 2466             ;
0013++ 2466             ; 	INITIALIZE - CLEAR SOME LOCATIONS AND SEND A RESET TO THE KEYBOARD
0014++ 2466             ;__________________________________________________________________________________________________			   	   	
0015++ 2466             KB_INITIALIZE:
0016++ 2466 3E 82       	LD 	A,10000010B		; A=OUT B=IN, C HIGH=OUT, CLOW=OUT
0017++ 2468 D3 F7       	OUT 	(KBPPICONT),A		; PPI CONTROL PORT
0018++ 246A CD B9 24    	CALL 	KB_DATAHIGH		;
0019++ 246D CD C3 24    	CALL 	KB_CLOCKHIGH		;
0020++ 2470 3E 00       	LD 	A,0			;
0021++ 2472 32 19 F4    	LD 	(CAPSLOCK),A		; SET CAPSLOCK OFF TO START
0022++ 2475 32 1A F4    	LD 	(CTRL),A		; CONTROL OFF
0023++ 2478 32 1B F4    	LD 	(NUMLOCK),A		; NUMLOCK OFF
0024++ 247B 32 1C F4    	LD	(BREAKFLAG),A		;
0025++ 247E CD 82 24    	CALL 	KB_RESET		; RESET TO THE KEYBOARD
0026++ 2481 C9          	RET
0027++ 2482             
0028++ 2482             
0029++ 2482             ;__KB_RESET________________________________________________________________________________________
0030++ 2482             ;
0031++ 2482             ; 	RESET THE KEYBOARD
0032++ 2482             ;__________________________________________________________________________________________________			   	   	
0033++ 2482             KB_RESET:
0034++ 2482 CD B9 24    	CALL 	KB_DATAHIGH		;
0035++ 2485 CD C3 24    	CALL 	KB_CLOCKHIGH		;
0036++ 2488 06 FF       	LD 	B,255			;
0037++ 248A 10 FE       SF1:	DJNZ 	SF1			;
0038++ 248C CD C8 24    	CALL 	KB_CLOCKLOW		; STEP 1
0039++ 248F 06 FF       	LD 	B,255			;
0040++ 2491 10 FE       SF2:	DJNZ 	SF2			;
0041++ 2493 CD BE 24    	CALL 	KB_DATALOW		; STEP 2
0042++ 2496 CD C3 24    	CALL 	KB_CLOCKHIGH		; STEP 3
0043++ 2499 CD CD 24    	CALL 	KB_WAITCLOCKLOW		; STEP 4
0044++ 249C 06 09       	LD	B,9			; 8 DATA BITS + 1 PARITY BIT LOW
0045++ 249E C5          SF3:	PUSH 	BC			;
0046++ 249F CD B9 24    	CALL 	KB_DATAHIGH		; STEP 5
0047++ 24A2 CD D7 24    	CALL 	KB_WAITCLOCKHIGH	; STEP 6
0048++ 24A5 CD CD 24    	CALL 	KB_WAITCLOCKLOW		; STEP 7
0049++ 24A8 C1          	POP 	BC			;
0050++ 24A9 10 F3       	DJNZ 	SF3			;
0051++ 24AB CD B9 24    	CALL 	KB_DATAHIGH		; STEP9
0052++ 24AE CD CD 24    	CALL 	KB_WAITCLOCKLOW		; STEP 10 COULD READ THE ACK BIT HERE IF WANT TO
0053++ 24B1 CD D7 24    	CALL 	KB_WAITCLOCKHIGH	; STEP 11
0054++ 24B4 06 FF       	LD 	B,255			;
0055++ 24B6 10 FE       SF4:	DJNZ 	SF4			; FINISH UP DELAY
0056++ 24B8 C9          	RET
0057++ 24B9             
0058++ 24B9             
0059++ 24B9             ;_________________________________________________________________________________________________
0060++ 24B9             ;
0061++ 24B9             ; 	PORT C BIT ROUTINES
0062++ 24B9             ;__________________________________________________________________________________________________			   	   	
0063++ 24B9             KB_DATAHIGH:
0064++ 24B9 3E 79       	LD 	A,01111001B		; SEE THE 8255 DATA SHEET
0065++ 24BB D3 F7       	OUT 	(KBPPICONT),A		; BIT 4
0066++ 24BD C9          	RET
0067++ 24BE             	
0068++ 24BE             KB_DATALOW:				;
0069++ 24BE 3E 78       	LD 	A,01111000B		; SEE THE 8255 DATA SHEET
0070++ 24C0 D3 F7       	OUT 	(KBPPICONT),A		;
0071++ 24C2 C9          	RET
0072++ 24C3             	
0073++ 24C3             KB_CLOCKHIGH:				;
0074++ 24C3 3E 7B       	LD 	A,01111011B		; BIT 5 HIGH
0075++ 24C5 D3 F7       	OUT 	(KBPPICONT),A		;
0076++ 24C7 C9          	RET
0077++ 24C8             	
0078++ 24C8             KB_CLOCKLOW:				;
0079++ 24C8 3E 7A       	LD 	A,01111010B		;
0080++ 24CA D3 F7       	OUT 	(KBPPICONT),A		;
0081++ 24CC C9          	RET				;
0082++ 24CD             
0083++ 24CD             
0084++ 24CD             
0085++ 24CD             ;__KB_WAITCLOCKLOW_________________________________________________________________________________
0086++ 24CD             ;
0087++ 24CD             ; WAITCLOCKLOW SAMPLES DATA BIT 0, AND WAITS TILL
0088++ 24CD             ; IT GOES LOW, THEN RETURNS
0089++ 24CD             ; ALSO TIMES OUT AFTER 0 001 SECONDS
0090++ 24CD             ; USES A, CHANGES B
0091++ 24CD             ;__________________________________________________________________________________________________			   	   	
0092++ 24CD             KB_WAITCLOCKLOW:
0093++ 24CD 06 FF       	LD 	B,255		; FOR TIMEOUT COUNTER
0094++ 24CF DB F5       WL1:	IN 	A,(KBPPIB)	; GET A BYTE FROM PORT B
0095++ 24D1 CB 4F       	BIT 	1,A		; TEST THE CLOCK BIT
0096++ 24D3 C8          	RET 	Z		; EXIT IF IT WENT LOW
0097++ 24D4 10 F9       	DJNZ 	WL1		; LOOP B TIMES
0098++ 24D6 C9          	RET
0099++ 24D7             
0100++ 24D7             	
0101++ 24D7             ;__KB_WAITCLOCKHIGH_________________________________________________________________________________
0102++ 24D7             ;
0103++ 24D7             ; WAITCLOCKHIGH SAMPLES DATA BIT 0, AND WAITS TILL
0104++ 24D7             ; IT GOES HIGH, THEN RETURNS
0105++ 24D7             ; ALSO TIMES OUT AFTER 0 001 SECONDS
0106++ 24D7             ; USES A, CHANGES B
0107++ 24D7             ;__________________________________________________________________________________________________			   	   	
0108++ 24D7             KB_WAITCLOCKHIGH:	
0109++ 24D7 06 FF       	LD 	B,255		; FOR TIMEOUT COUNTER
0110++ 24D9 DB F5       WH1:	IN 	A,(KBPPIB)	; GET A BYTE FROM PORT B
0111++ 24DB CB 4F       	BIT 	1,A		; TEST THE CLOCK BIT
0112++ 24DD C0          	RET 	NZ		; EXIT IF IT WENT HIGH
0113++ 24DE 10 F9       	DJNZ 	WH1		; LOOP B TIMES
0114++ 24E0 C9          	RET
0115++ 24E1             
0116++ 24E1             
0117++ 24E1             
0118++ 24E1             ;__KB_PROCESS______________________________________________________________________________________
0119++ 24E1             ;
0120++ 24E1             ;  
0121++ 24E1             ;__________________________________________________________________________________________________			   	   	
0122++ 24E1             KB_PROCESS:	
0123++ 24E1 CD 2E 26     	CALL	KB_WAITBYTE	; TEST KEYBOARD  TIMES OUT AFTER A BIT
0124++ 24E4 FE 00        	CP	0
0125++ 24E6 C8           	RET	Z
0126++ 24E7 CD EB 24    	CALL 	KB_DECODECHAR	; RETURNS CHAR OR 0 FOR THINGS LIKE KEYUP, SOME RETURN DIRECTLY
0127++ 24EA C9          	RET			; RETURN 
0128++ 24EB             
0129++ 24EB             	
0130++ 24EB             	
0131++ 24EB             ;__KB_DECODECHAR____________________________________________________________________________________
0132++ 24EB             ;
0133++ 24EB             ; DECODE CHARACTER PASS A AND PRINTS OUT THE CHAR
0134++ 24EB             ; ON THE LCD SCREEN
0135++ 24EB             ;__________________________________________________________________________________________________			   	   	
0136++ 24EB             KB_DECODECHAR:
0137++ 24EB FE F0       	CP 	0F0H		; IS A KEY UP (NEED TO DO SPECIAL CODE FOR SHIFT)
0138++ 24ED CA 5F 25    	JP 	Z,DECKEYUP	; IGNORE CHAR UP
0139++ 24F0 FE E0       	CP	0E0H		; TWO BYTE KEYPRESSES
0140++ 24F2 CA 78 25    	JP 	Z,TWOBYTE	;
0141++ 24F5 FE 58       	CP 	058H		; CAPS LOCK SO TOGGLE
0142++ 24F7 CA 0B 26    	JP 	Z,CAPSTOG	;
0143++ 24FA FE 12       	CP	12H		; SHIFT (DOWN, BECAUSE UP WOULD BE TRAPPED BY 0F ABOVE)
0144++ 24FC CA 16 26    	JP 	Z,SHIFTDOWN	;
0145++ 24FF FE 59       	CP	59H		; OTHER SHIFT KEY
0146++ 2501 CA 16 26    	JP 	Z,SHIFTDOWN	;
0147++ 2504 FE 14       	CP	014H		; CONTROL KEY
0148++ 2506 CA EF 25    	JP 	Z,CONTROLDOWN	;
0149++ 2509 FE 5A       	CP	05AH		; ENTER KEY
0150++ 250B CA 59 25    	JP	Z,KBRETURN	;
0151++ 250E FE 66       	CP	066H		; BACKSPACE KEY
0152++ 2510 CA 4D 25    	JP	Z,BACKSPACE	;
0153++ 2513 FE 0D       	CP	0DH		; TAB KEY
0154++ 2515 CA 47 25    	JP 	Z,TABKEY	;
0155++ 2518 FE 76       	CP	076H		; ESCAPE KEY
0156++ 251A CA 53 25    	JP	Z,ESCAPE	;
0157++ 251D FE 7E       	CP	07EH		; BREAK (SCROLL LOCK) KEY
0158++ 251F CA 26 26    	JP	Z,BREAK		;
0159++ 2522 4F          	LD 	C,A		;
0160++ 2523 06 00       	LD 	B,0		; ADD BC TO HL
0161++ 2525 21 71 26    	LD 	HL,NORMALKEYS	; OFFSET TO ADD
0162++ 2528 09          	ADD 	HL,BC		;
0163++ 2529 3A 1A F4    	LD 	A,(CTRL)	;
0164++ 252C FE 00       	CP 	0		; IS CONTROL BEING HELD DOWN?
0165++ 252E CA 38 25    	JP	Z,DC1		; NO SO GO TO TEST CAPS LOCK ON
0166++ 2531 7E          	LD	A,(HL)		; GET THE LETTER, SHOULD BE SMALLS 
0167++ 2532 D6 60       	SUB	96		; A=97 SO SUBTRACT 96 A=1=^A
0168++ 2534 CD A7 17    	call    key_put_into_buf	; STORE ON KB QUEUE
0169++ 2537 C9          	RET			; RETURN 
0170++ 2538 3A 19 F4    DC1:	LD 	A,(CAPSLOCK)	;
0171++ 253B FE 00       	CP 	0		; IS IT 0, IF SO THEN DON'T ADD THE CAPS OFFSET
0172++ 253D 28 03       	JR 	Z,DC2		;
0173++ 253F 0E 80       	LD 	C,080H		; ADD ANOTHER 50H TO SMALLS TO GET CAPS
0174++ 2541 09          	ADD 	HL,BC		;
0175++ 2542 7E          DC2:	LD 	A,(HL)		;
0176++ 2543 CD A7 17    	call    key_put_into_buf	; STORE ON KB QUEUE
0177++ 2546 C9          	RET			;
0178++ 2547             TABKEY:				;
0179++ 2547 3E 09       	LD 	A,9		;
0180++ 2549 CD A7 17    	call    key_put_into_buf	; STORE ON KB QUEUE
0181++ 254C C9          	RET			;TAB
0182++ 254D             BACKSPACE:			;
0183++ 254D 3E 08       	LD	A,8		; BACKSPACE
0184++ 254F CD A7 17    	call    key_put_into_buf	; STORE ON KB QUEUE
0185++ 2552 C9          	RET			;
0186++ 2553             ESCAPE:				;
0187++ 2553 3E 1B       	LD	A,27		;
0188++ 2555 CD A7 17    	call    key_put_into_buf	; STORE ON KB QUEUE
0189++ 2558 C9          	RET			;
0190++ 2559             KBRETURN:				;
0191++ 2559 3E 0D       	LD	A,13		; CARRIAGE RETURN
0192++ 255B CD A7 17    	call    key_put_into_buf	; STORE ON KB QUEUE
0193++ 255E C9          	RET			;
0194++ 255F             DECKEYUP:
0195++ 255F CD 2E 26    	CALL 	KB_WAITBYTE	; IGNORE KEY UP THROW AWAY THE CHARACTER UNLESS A SHIFT 
0196++ 2562 FE 00       	CP	0
0197++ 2564 28 F9       	JR	Z,DECKEYUP
0198++ 2566 FE 12       	CP	012H		; IS IT A SHIFT
0199++ 2568 CA 1E 26    	JP 	Z,SHIFTUP	;
0200++ 256B FE 59       	CP	59H		; OTHER SHIFT KEY
0201++ 256D CA 1E 26    	JP	Z,SHIFTUP	;
0202++ 2570 FE 14       	CP	014H		; CONTROL UP
0203++ 2572 CA F7 25    	JP 	Z,CONTROLUP	; CONTROL UP
0204++ 2575 3E 00       	LD	A,0		; NOTHING CAPTURED SO SEND BACK A ZERO 
0205++ 2577 C9          	RET
0206++ 2578             TWOBYTE:; ALREADY GOT EO SO GET THE NEXT CHARACTER
0207++ 2578 CD 2E 26    	CALL 	KB_WAITBYTE
0208++ 257B FE 00       	CP	0
0209++ 257D 28 F9       	JR	Z,TWOBYTE	
0210++ 257F FE F0       	CP	0F0H		; SEE THE NOTES - KEYUP FOR E0 KEYS IS EO F0 NN NOT F0 EO!!
0211++ 2581 CA BE 25    	JP	Z,TWOBYTEUP	;
0212++ 2584 FE 71       	CP	071H		; DELETE
0213++ 2586 CA 05 26    	JP	Z,DELETEKEY	;
0214++ 2589 FE 5A       	CP	05AH		; RETURN ON NUMBER PAD
0215++ 258B CA FF 25    	JP	Z,RETURNKEY	;
0216++ 258E FE 72       	CP	072H		;
0217++ 2590 CA CE 25    	JP	Z,DOWNARROW	;
0218++ 2593 FE 74       	CP	074H		;
0219++ 2595 CA D4 25    	JP	Z,RIGHTARROW	;
0220++ 2598 FE 6B       	CP	06BH		;
0221++ 259A CA DA 25    	JP	Z,LEFTARROW	;
0222++ 259D FE 75       	CP	075H		;
0223++ 259F CA E0 25    	JP	Z,UPARROW	;
0224++ 25A2 FE 70       	CP	070H		;
0225++ 25A4 CA E6 25    	JP	Z,INSERT	;
0226++ 25A7 FE 7D       	CP	07DH		;
0227++ 25A9 CA EC 25    	JP	Z,PAGEUP	;
0228++ 25AC FE 7A       	CP	07AH		;
0229++ 25AE CA EC 25    	JP	Z,PAGEDOWN	;
0230++ 25B1 FE 6C       	CP	06CH		;
0231++ 25B3 CA C8 25    	JP	Z,HOME		;
0232++ 25B6 FE 69       	CP	069H		;
0233++ 25B8 CA EC 25    	JP	Z,END		;
0234++ 25BB 3E 00       	LD 	A,0		; RETURNS NOTHING
0235++ 25BD C9          	RET
0236++ 25BE             TWOBYTEUP:			;EXPECT A BYTE AND IGNORE IT
0237++ 25BE CD 2E 26    	CALL	KB_WAITBYTE	;
0238++ 25C1 FE 00       	CP	0
0239++ 25C3 28 F9       	JR	Z,TWOBYTEUP
0240++ 25C5 3E 00       	LD	A,0		;
0241++ 25C7 C9          	RET			;
0242++ 25C8             HOME:				;
0243++ 25C8 3E 0B       	LD	A,11		; ESC
0244++ 25CA CD A7 17    	call    key_put_into_buf	; STORE ON KB QUEUE
0245++ 25CD C9          	RET			;
0246++ 25CE             DOWNARROW:			;
0247++ 25CE 3E 1F       	LD	A,31		; ESC
0248++ 25D0 CD A7 17    	call    key_put_into_buf	; STORE ON KB QUEUE
0249++ 25D3 C9          	RET			;
0250++ 25D4             RIGHTARROW:			;
0251++ 25D4 3E 1C       	LD	A,28		; ESC
0252++ 25D6 CD A7 17    	call    key_put_into_buf	; STORE ON KB QUEUE
0253++ 25D9 C9          	RET			;
0254++ 25DA             LEFTARROW:			;
0255++ 25DA 3E 1D       	LD	A,29		; ESC
0256++ 25DC CD A7 17    	call    key_put_into_buf	; STORE ON KB QUEUE
0257++ 25DF C9          	RET			;
0258++ 25E0             UPARROW:			;
0259++ 25E0 3E 1E       	LD	A,30		; ESC
0260++ 25E2 CD A7 17    	call    key_put_into_buf	; STORE ON KB QUEUE
0261++ 25E5 C9          	RET			;	
0262++ 25E6             INSERT:				;
0263++ 25E6 3E 12       	LD	A,18		; ESC
0264++ 25E8 CD A7 17    	call    key_put_into_buf	; STORE ON KB QUEUE
0265++ 25EB C9          	RET			;
0266++ 25EC             PAGEUP:				;
0267++ 25EC             PAGEDOWN:			;
0268++ 25EC             END:				;
0269++ 25EC             				;
0270++ 25EC 3E 00       	LD	A,0		; ESC
0271++ 25EE C9          	RET			;
0272++ 25EF             CONTROLDOWN:			; SAME CODE AS SHIFTDOWN BUT DIFF LOCATION
0273++ 25EF 3E FF       	LD 	A,0FFH		;
0274++ 25F1 32 1A F4    	LD	(CTRL),A	; CONTROL DOWN
0275++ 25F4 3E 00       	LD	A,0		;
0276++ 25F6 C9          	RET			;
0277++ 25F7             CONTROLUP:			; CONTROL KEY UP SEE SHIFT FOR EXPLANATION
0278++ 25F7 3E 00       	LD	A,0		;
0279++ 25F9 32 1A F4    	LD 	(CTRL),A	;
0280++ 25FC 3E 00       	LD 	A,0		;
0281++ 25FE C9          	RET			;
0282++ 25FF             RETURNKEY:			;
0283++ 25FF 3E 0D       	LD 	A,13		;
0284++ 2601 CD A7 17    	call    key_put_into_buf	; STORE ON KB QUEUE
0285++ 2604 C9          	RET			;
0286++ 2605             DELETEKEY:			;
0287++ 2605 3E 08       	LD 	A,08H		; 	DELETE KEY VALUE 
0288++ 2607 CD A7 17    	call    key_put_into_buf	; STORE ON KB QUEUE
0289++ 260A C9          	RET			;
0290++ 260B             CAPSTOG:			;
0291++ 260B 3A 19 F4      	LD 	A,(CAPSLOCK)	;
0292++ 260E EE FF       	XOR 	11111111B	; SWAP ALL THE BITS
0293++ 2610 32 19 F4    	LD 	(CAPSLOCK),A	;
0294++ 2613 3E 00       	LD	A,0		; RETURNS NOTHING
0295++ 2615 C9          	RET			;
0296++ 2616             SHIFTDOWN:			; SHIFT IS SPECIAL - HOLD IT DOWN AND IT AUTOREPEATS
0297++ 2616             				; SO ONCE IT IS DOWN, TURN CAPS ON AND IGNORE ALL FURTHER SHIFTS
0298++ 2616             				; ONLY AN F0+SHIFT TURNS CAPS LOCK OFF AGAIN
0299++ 2616 3E FF       	LD 	A,0FFH		;
0300++ 2618 32 19 F4    	LD 	(CAPSLOCK),A	;
0301++ 261B 3E 00       	LD 	A,0		; RETURNS NOTHING
0302++ 261D C9          	RET			;
0303++ 261E             SHIFTUP:			; SHIFTUP TURNS OFF CAPS LOCK DEFINITELY
0304++ 261E 3E 00       	LD 	A,0		;
0305++ 2620 32 19 F4    	LD 	(CAPSLOCK),A	;
0306++ 2623 3E 00       	LD 	A,0		; RETURNS NOTHING
0307++ 2625 C9          	RET			;
0308++ 2626             BREAK:
0309++ 2626 3E FF       	LD	A,$FF		;
0310++ 2628 32 1C F4    	LD	(BREAKFLAG),A	;
0311++ 262B 3E 00       	LD	A,0
0312++ 262D C9          	RET
0313++ 262E             	
0314++ 262E             ;__KB_WAITBYTE_____________________________________________________________________________________
0315++ 262E             ;
0316++ 262E             ; WAIT FOR A BYTE - TESTS A NUMBER OF TIMES IF THERE IS A KEYBOARD INPUT,
0317++ 262E             ; OVERWRITES ALL REGISTERS, RETURNS BYTE IN A
0318++ 262E             ;__________________________________________________________________________________________________			   	   		
0319++ 262E             KB_WAITBYTE:
0320++ 262E CD C3 24    	CALL	KB_CLOCKHIGH	; TURN ON KEYBOARD
0321++ 2631             	
0322++ 2631 DB F5       WB1:	IN 	A,(KBPPIB)	; GET A BYTE FROM PORT B
0323++ 2633 CB 4F       	BIT 	1,A		; TEST THE CLOCK BIT
0324++ 2635 28 FA       	JR 	Z,WB1		; EXIT IF IT WENT HIGH
0325++ 2637             
0326++ 2637 06 FF       	LD 	B,255		; FOR TIMEOUT COUNTER
0327++ 2639 DB F5       WB2:	IN 	A,(KBPPIB)	; GET A BYTE FROM PORT B
0328++ 263B CB 4F       	BIT 	1,A		; TEST THE CLOCK BIT
0329++ 263D 28 06       	JR 	Z,WB3		; EXIT IF IT WENT LOW
0330++ 263F 10 F8       	DJNZ 	WB2		; LOOP B TIMES		
0331++ 2641 1E 00       	LD	E,0		;		
0332++ 2643 18 03       	JR	WB4
0333++ 2645             WB3:	
0334++ 2645 CD 4D 26    	CALL 	KB_READBITS	; TEST FOR A LOW ON THE CLOCK LINE
0335++ 2648             WB4:
0336++ 2648 CD C8 24    	CALL 	KB_CLOCKLOW	; TURN OFF KEYBOARD
0337++ 264B 7B          	LD	A,E
0338++ 264C C9          	RET
0339++ 264D             
0340++ 264D             ;__KB_READBITS_____________________________________________________________________________________
0341++ 264D             ;
0342++ 264D             ; READBITS READS 11 BITS IN FROM THE KEYBOARD
0343++ 264D             ; FIRST BIT IS A START BIT THEN 8 BITS FOR THE BYTE
0344++ 264D             ; THEN A PARITY BIT AND A STOP BIT
0345++ 264D             ; RETURNS AFTER ONE MACHINE CYCLE IF NOT LOW
0346++ 264D             ; USES A, B,D, E 
0347++ 264D             ; RETURNS A=0 IF NO DATA, A= SCANCODE (OR PART THEREOF)
0348++ 264D             ;__________________________________________________________________________________________________			   	   		
0349++ 264D             KB_READBITS:
0350++ 264D CD D7 24    	CALL 	KB_WAITCLOCKHIGH; IF GETS TO HERE THEN MUST BE LOW SO WAIT TILL HIGH
0351++ 2650 06 08       	LD 	B,8		; SAMPLE 8 TIMES
0352++ 2652 1E 00       	LD 	E,0		; START WITH E=0
0353++ 2654 50          R2:	LD 	D,B		; STORE BECAUSE WAITCLOCKHIGH DESTROYS
0354++ 2655 CD CD 24    	CALL 	KB_WAITCLOCKLOW	; WAIT TILL CLOCK GOES LOW
0355++ 2658 DB F5       	IN 	A,(KBPPIB)	; SAMPLE THE DATA LINE
0356++ 265A 1F          	RRA			; MOVE THE DATA BIT INTO THE CARRY REGISTER
0357++ 265B 7B          	LD 	A,E		; GET THE BYTE WE ARE BUILDING IN E
0358++ 265C 1F          	RRA			; MOVE THE CARRY BIT INTO BIT 7 AND SHIFT RIGHT
0359++ 265D 5F          	LD 	E,A		; STORE IT BACK  AFTER 8 CYCLES 1ST BIT READ WILL BE IN B0
0360++ 265E CD D7 24    	CALL 	KB_WAITCLOCKHIGH; WAIT TILL GOES HIGH
0361++ 2661 42          	LD 	B,D		; RESTORE FOR LOOP
0362++ 2662 10 F0       	DJNZ 	R2		; DO THIS 8 TIMES
0363++ 2664 CD CD 24    	CALL 	KB_WAITCLOCKLOW	; GET THE PARITY BIT
0364++ 2667 CD D7 24    	CALL 	KB_WAITCLOCKHIGH;
0365++ 266A CD CD 24    	CALL 	KB_WAITCLOCKLOW	; GET THE STOP BIT
0366++ 266D CD D7 24    	CALL 	KB_WAITCLOCKHIGH;	
0367++ 2670 C9          	RET
0368++ 2671             	
0369++ 2671             	
0370++ 2671             NORMALKEYS: ; THE TI CHARACTER CODES, OFFSET FROM LABEL BY KEYBOARD SCAN CODE
0371++ 2671 00 00 00 00 		 .DB 000,000,000,000,000,000,000,000,000,000
0371++ 2675 00 00 00 00 
0371++ 2679 00 00 
0372++ 267B 00 00 00 09 		 .DB 000,000,000,009,"`",000,000,000,000,000	; 0D = TABKEY=9
0372++ 267F 60 00 00 00 
0372++ 2683 00 00 
0373++ 2685 00 71 31 00 		 .DB 000,"q","1",000,000,000,"z","s","a","w"
0373++ 2689 00 00 7A 73 
0373++ 268D 61 77 
0374++ 268F 32 00 00 63 		 .DB "2",000,000,"c","x","d","e","4","3",000
0374++ 2693 78 64 65 34 
0374++ 2697 33 00 
0375++ 2699 00 20 76 66 		 .DB 000," ","v","f","t","r","5",000,000,"n"
0375++ 269D 74 72 35 00 
0375++ 26A1 00 6E 
0376++ 26A3 62 68 67 79 		 .DB "b","h","g","y","6",000,000,000,"m","j"
0376++ 26A7 36 00 00 00 
0376++ 26AB 6D 6A 
0377++ 26AD 75 37 38 00 		 .DB "u","7","8",000,000,",","k","i","o","0"
0377++ 26B1 00 2C 6B 69 
0377++ 26B5 6F 30 
0378++ 26B7 39 00 00 2E 		 .DB "9",000,000,".","/","l",";","p","-",000
0378++ 26BB 2F 6C 3B 70 
0378++ 26BF 2D 00 
0379++ 26C1 00 00 27 00 		 .DB 000,000,039,000,"[","=",000,000,000,000	; 39 IS '
0379++ 26C5 5B 3D 00 00 
0379++ 26C9 00 00 
0380++ 26CB 00 5D 00 5C 		 .DB 000,"]",000,092,000,000,000,000,000,000	; 92 IS \
0380++ 26CF 00 00 00 00 
0380++ 26D3 00 00 
0381++ 26D5 00 00 00 00 		 .DB 000,000,000,000,000,"1",000,"4","7",000
0381++ 26D9 00 31 00 34 
0381++ 26DD 37 00 
0382++ 26DF 00 00 30 2E 		 .DB 000,000,"0",".","2","5","6","8",000,000
0382++ 26E3 32 35 36 38 
0382++ 26E7 00 00 
0383++ 26E9 00 2B 33 2D 		 .DB 000,"+","3","-","*","9",000,000		; PAD TO 80H BYTES
0383++ 26ED 2A 39 00 00 
0384++ 26F1 00 00 00 00 		 .DB 000,000,000,000,000,000,000,000,000,000
0384++ 26F5 00 00 00 00 
0384++ 26F9 00 00 
0385++ 26FB 00 00 00 09 		 .DB 000,000,000,009,"~",000,000,000,000,000	; 0D = TABKEY=9
0385++ 26FF 7E 00 00 00 
0385++ 2703 00 00 
0386++ 2705 00 51 21 00 		 .DB 000,"Q","!",000,000,000,"Z","S","A","W"
0386++ 2709 00 00 5A 53 
0386++ 270D 41 57 
0387++ 270F 40 00 00 43 		 .DB "@",000,000,"C","X","D","E","$","#",000
0387++ 2713 58 44 45 24 
0387++ 2717 23 00 
0388++ 2719 00 20 56 46 		 .DB 000," ","V","F","T","R","%",000,000,"N"
0388++ 271D 54 52 25 00 
0388++ 2721 00 4E 
0389++ 2723 42 48 47 59 		 .DB "B","H","G","Y","^",000,000,000,"M","J"
0389++ 2727 5E 00 00 00 
0389++ 272B 4D 4A 
0390++ 272D 55 26 2A 00 		 .DB "U","&","*",000,000,"<","K","I","O",")"
0390++ 2731 00 3C 4B 49 
0390++ 2735 4F 29 
0391++ 2737 28 00 00 3E 		 .DB "(",000,000,">","?","L",":","P","_",000
0391++ 273B 3F 4C 3A 50 
0391++ 273F 5F 00 
0392++ 2741 00 00 22 00 		 .DB 000,000,034,000,"{","+",000,000,000,000	; 34 IS "
0392++ 2745 7B 2B 00 00 
0392++ 2749 00 00 
0393++ 274B 00 7D 00 7C 		 .DB 000,"}",000,"|",000,000,000,000,000,000	; 92 IS \
0393++ 274F 00 00 00 00 
0393++ 2753 00 00 
0394++ 2755 00 00 00 00 		 .DB 000,000,000,000,000,"1",000,"4","7",000
0394++ 2759 00 31 00 34 
0394++ 275D 37 00 
0395++ 275F 00 00 30 2E 		 .DB 000,000,"0",".","2","5","6","8",000,000
0395++ 2763 32 35 36 38 
0395++ 2767 00 00 
0396++ 2769 00 2B 33 2D 		 .DB 000,"+","3","-","*","9",000,000		; PAD TO 80H BYTES
0396++ 276D 2A 39 00 00 
0397++ 2771             
0398++ 2771             		
0399++ 2771             
0400++ 2771             ;__________________________________________________________________________________________________
0401++ 2771             ;
0402++ 2771             ; 	RAM STORAGE AREAS
0403++ 2771             ;__________________________________________________________________________________________________			
0404++ 2771             
0405++ 2771             
0406++ 2771             CAPSLOCK		.EQU	0F419H		; location for caps lock, either 00000000 or 11111111
0407++ 2771             CTRL			.EQU	0F41AH		; location for ctrl on or off 00000000 or 11111111
0408++ 2771             NUMLOCK			.EQU	0F41BH		; location for num lock
0409++ 2771             BREAKFLAG		.EQU	0F41CH		; location for BREAK FLAG
0410++ 2771             
2452+  2771                             .include "ROMMON.asm"
0001++ 2771             ;___ROM_MONITOR_PROGRAM_____________________________________________________________________________________________________________
0002++ 2771             ;
0003++ 2771             ;  ORIGINAL CODE BY:	ANDREW LYNCH (LYNCHAJ@YAHOO COM)	13 FEB 2007
0004++ 2771             ;
0005++ 2771             ;  MODIFIED BY : 	DAN WERNER 03 09.2009
0006++ 2771             ;
0007++ 2771             ;__REFERENCES________________________________________________________________________________________________________________________ 
0008++ 2771             ; THOMAS SCHERRER BASIC HAR.DWARE TEST ASSEMBLER SOURCES FROM THE Z80 INFO PAGE
0009++ 2771             ; INCLUDING ORIGINAL SCHEMATIC CONCEPT
0010++ 2771             ; HTTP://Z80 INFO/Z80SOURC.TXT
0011++ 2771             ; CODE SAMPLES FROM BRUCE JONES PUBLIC DOMAIN ROM MONITOR FOR THE SBC-200C 
0012++ 2771             ; HTTP://WWW RETROTECHNOLOGY.COM/HERBS_STUFF/SD_BRUCE_CODE.ZIP
0013++ 2771             ; INSPIRATION FROM JOEL OWENS "Z-80 SPACE-TIME PRODUCTIONS SINGLE BOARD COMPUTER"
0014++ 2771             ; HTTP://WWW JOELOWENS.ORG/Z80/Z80INDEX.HTML
0015++ 2771             ; GREAT HELP AND TECHNICAL ADVICE FROM ALLISON AT ALPACA_DESIGNERS
0016++ 2771             ; HTTP://GROUPS YAHOO.COM/GROUP/ALPACA_DESIGNERS
0017++ 2771             ; INTEL SDK-85 ROM DEBUG MONITOR
0018++ 2771             ;
0019++ 2771             ;
0020++ 2771             ;
0021++ 2771             ;__CONSTANTS_________________________________________________________________________________________________________________________ 
0022++ 2771             ;	
0023++ 2771             ENDT:		 .EQU	00h		; MARK END OF TEXT
0024++ 2771             CR:		 .EQU	0DH		; ASCII CARRIAGE RETURN CHARACTER
0025++ 2771             LF:		 .EQU	0AH		; ASCII LINE FEED CHARACTER
0026++ 2771             ESC:		 .EQU	1BH		; ASCII ESCAPE CHARACTER
0027++ 2771             BS:		 .EQU	08H		; ASCII BACKSPACE CHARACTER
0028++ 2771             ;
0029++ 2771             ;
0030++ 2771             ;
0031++ 2771             ;__MAIN_PROGRAM_____________________________________________________________________________________________________________________ 
0032++ 2771             ;
0033++ 2771             
0034++ 2771             ;__DOTINYMON___________________________________________________________________________________________________________________ 
0035++ 2771             ;
0036++ 2771             ;	MONITOR STARTUP
0037++ 2771             ;________________________________________________________________________________________________________________________________
0038++ 2771             ;
0039++ 2771             
0040++ 2771             DOTINYMON:				; CALL HERE FOR MONITOR WARM START
0041++ 2771             
0042++ 2771 AF          	XOR	A			;ZERO OUT ACCUMULATOR (ADDED)
0043++ 2772 E5          	PUSH	HL			;PROTECT HL FROM OVERWRITE    
0044++ 2773 21 72 29    	LD	HL,TXT_IDENT		;POINT AT TEXT
0045++ 2776 CD AD 0E    	CALL	prn_text		;SHOW WE'RE HERE
0046++ 2779 21 97 29    	LD	HL,TXT_READY		;POINT AT TEXT
0047++ 277C CD AD 0E    	CALL	prn_text		;SHOW WE'RE HERE
0048++ 277F E1          	POP	HL			;PROTECT HL FROM OVERWRITE
0049++ 2780             
0050++ 2780             ;
0051++ 2780             ;__MONITOR_COMMANDS_________________________________________________________________________________________________________ 
0052++ 2780             ;
0053++ 2780             ; B XX BOOT CPM FROM DRIVE XX
0054++ 2780             ; D XXXXH YYYYH  DUMP MEMORY FROM XXXX TO YYYY
0055++ 2780             ; F XXXXH YYYYH ZZH FILL MEMORY FROM XXXX TO YYYY WITH ZZ
0056++ 2780             ; I INPUT FROM PORT AND SHOW HEX DATA
0057++ 2780             ; M XXXXH YYYYH ZZZZH MOVE MEMORY BLOCK XXXX TO YYYY TO ZZZZ
0058++ 2780             ; O OUTPUT TO PORT HEX DATA
0059++ 2780             ; P XXXXH YYH PROGRAM RAM FROM XXXXH WITH VALUE IN YYH, WILL PROMPT FOR NEXT LINES FOLLOWING UNTIL CR
0060++ 2780             ; R RUN A PROGRAM FROM CURRENT LOCATION
0061++ 2780             
0062++ 2780             
0063++ 2780             
0064++ 2780             ;__COMMAND_PARSE_________________________________________________________________________________________________________________ 
0065++ 2780             ;
0066++ 2780             ;	PROMPT USER FOR COMMANDS, THEN PARSE THEM
0067++ 2780             ;________________________________________________________________________________________________________________________________
0068++ 2780             ;
0069++ 2780             
0070++ 2780             MONITORCMDLOOP:
0071++ 2780 CD 53 28    	CALL	CRLFA			; CR,LF,>
0072++ 2783 CD B3 27    	CALL 	MONGETLN		; GET A LINE OF INPUT FROM THE USER
0073++ 2786 7E                  LD      A,(HL)			; LOAD FIRST CHAR INTO A (THIS SHOULD BE THE COMMAND)
0074++ 2787 23          	INC	HL			; INC POINTER
0075++ 2788             
0076++ 2788 FE 52       	CP	'R'			; IS IT "R" (Y/N)
0077++ 278A CA 5C 28    	JP	Z,MONRUN		; IF YES GO RUN ROUTINE
0078++ 278D FE 50       	CP	'P'			; IS IT "P" (Y/N)
0079++ 278F CA 61 28    	JP	Z,PROGRM		; IF YES GO PROGRAM ROUTINE
0080++ 2792 FE 4F       	CP	'O'			; IS IT AN "O" (Y/N)
0081++ 2794 CA 35 28    	JP	Z,MONPOUT			; PORT OUTPUT
0082++ 2797 FE 49       	CP	'I'			; IS IT AN "I" (Y/N)
0083++ 2799 CA 43 28    	JP	Z,PIN			; PORT INPUT
0084++ 279C FE 44       	CP	'D'			; IS IT A "D" (Y/N)
0085++ 279E CA 92 28    	JP	Z,DUMP			; DUMP MEMORY
0086++ 27A1 FE 4D       	CP	'M'			; IS IT A "M" (Y/N)
0087++ 27A3 CA EE 28    	JP	Z,MOVE			; MOVE MEMORY COMMAND
0088++ 27A6 FE 46       	CP	'F'			; IS IT A "F" (Y/N)
0089++ 27A8 CA 2F 29    	JP	Z,FILL			; FILL MEMORY COMMAND
0090++ 27AB 21 A8 29    	LD	HL,TXT_COMMAND		; POINT AT ERROR TEXT
0091++ 27AE CD AD 0E    	CALL	prn_text		; PRINT COMMAND LABEL
0092++ 27B1             
0093++ 27B1 18 CD       	JR	MONITORCMDLOOP
0094++ 27B3             
0095++ 27B3             
0096++ 27B3             
0097++ 27B3             
0098++ 27B3             
0099++ 27B3             ;__MONGETLN_________________________________________________________________________________________________________________________ 
0100++ 27B3             ;
0101++ 27B3             ;	READ A LINE(80) OF TEXT , HANDLE <BS>, TERM ON <CR> 
0102++ 27B3             ;       EXIT IF TOO MANY CHARS    STORE RESULT IN HL.  CHAR COUNT IN C.
0103++ 27B3             ;________________________________________________________________________________________________________________________________
0104++ 27B3             ;
0105++ 27B3             MONGETLN:
0106++ 27B3 3E 01       	LD	A,1			; ENABLE CURSOR
0107++ 27B5 32 A9 FC    	LD      (CSRSW),A		;
0108++ 27B8 0E 00       	LD	C,00H			; ZERO CHAR COUNTER
0109++ 27BA D5          	PUSH	DE			; STORE DE
0110++ 27BB CD B1 00    	CALL	$00B1			;
0111++ 27BE D1          	POP	DE			; RESTORE DE
0112++ 27BF C9          	RET	
0113++ 27C0             	
0114++ 27C0             
0115++ 27C0             
0116++ 27C0             
0117++ 27C0             
0118++ 27C0             ;__CRLF__________________________________________________________________________________________________________________________ 
0119++ 27C0             ;
0120++ 27C0             ;	SEND CR & LF 
0121++ 27C0             ;________________________________________________________________________________________________________________________________
0122++ 27C0             ;
0123++ 27C0             CRLF:
0124++ 27C0 E5          	PUSH	HL			; PROTECT HL FROM OVERWRITE
0125++ 27C1 21 6B 29    	LD	HL,TCRLF		; LOAD MESSAGE POINTER
0126++ 27C4 CD AD 0E    	CALL	prn_text		; SEBD MESSAGE 
0127++ 27C7 E1          	POP	HL			; PROTECT HL FROM OVERWRITE
0128++ 27C8 C9          	RET				;
0129++ 27C9             
0130++ 27C9             
0131++ 27C9             ;__LDHL__________________________________________________________________________________________________________________________ 
0132++ 27C9             ;
0133++ 27C9             ;	GET ONE WORD OF HEX DATA FROM BUFFER POINTED TO BY HL , RETURN IN HL
0134++ 27C9             ;________________________________________________________________________________________________________________________________
0135++ 27C9             ;
0136++ 27C9             LDHL:
0137++ 27C9 D5          	PUSH	DE			; STORE DE
0138++ 27CA CD D5 27    	CALL	HEXIN			; GET K B. AND MAKE HEX
0139++ 27CD 57          	LD	D,A			; THATS THE HI BYTE
0140++ 27CE CD D5 27    	CALL	HEXIN			; DO HEX AGAIN
0141++ 27D1 6F          	LD	L,A			; THATS THE LOW BYTE
0142++ 27D2 62          	LD	H,D			; MOVE TO HL
0143++ 27D3 D1          	POP	DE			; RESTORE BC
0144++ 27D4 C9          	RET				; GO BACK WITH ADDRESS  
0145++ 27D5             
0146++ 27D5             
0147++ 27D5             ;__HEXIN__________________________________________________________________________________________________________________________ 
0148++ 27D5             ;
0149++ 27D5             ;	GET ONE BYTE OF HEX DATA FROM BUFFER IN HL, RETURN IN A
0150++ 27D5             ;________________________________________________________________________________________________________________________________
0151++ 27D5             ;
0152++ 27D5             HEXIN:
0153++ 27D5 C5          	PUSH	BC			;SAVE BC REGS 
0154++ 27D6 CD E8 27    	CALL	NIBL			;DO A NIBBLE
0155++ 27D9 CB 07       	RLC	A			;MOVE FIRST BYTE UPPER NIBBLE  
0156++ 27DB CB 07       	RLC	A			; 
0157++ 27DD CB 07       	RLC	A			; 
0158++ 27DF CB 07       	RLC	A			; 
0159++ 27E1 47          	LD	B,A			; SAVE ROTATED BYTE
0160++ 27E2 CD E8 27    	CALL	NIBL			; DO NEXT NIBBLE
0161++ 27E5 80          	ADD	A,B			; COMBINE NIBBLES IN ACC 
0162++ 27E6 C1          	POP	BC			; RESTORE BC
0163++ 27E7 C9          	RET				; DONE  
0164++ 27E8             NIBL:
0165++ 27E8 7E          	LD	A,(HL)			; GET K B. DATA
0166++ 27E9 23          	INC	HL			; INC KB POINTER
0167++ 27EA FE 40       	CP	40H			; TEST FOR ALPHA
0168++ 27EC 30 03       	JR	NC,ALPH			;
0169++ 27EE E6 0F       	AND	0FH			; GET THE BITS
0170++ 27F0 C9          	RET				;
0171++ 27F1             ALPH:
0172++ 27F1 E6 0F       	AND	0FH			; GET THE BITS
0173++ 27F3 C6 09       	ADD	A,09H			; MAKE IT HEX A-F
0174++ 27F5 C9          	RET				;
0175++ 27F6             
0176++ 27F6             
0177++ 27F6             
0178++ 27F6             
0179++ 27F6             ;__HXOUT_________________________________________________________________________________________________________________________ 
0180++ 27F6             ;
0181++ 27F6             ;	PRINT THE ACCUMULATOR CONTENTS AS HEX DATA 
0182++ 27F6             ;________________________________________________________________________________________________________________________________
0183++ 27F6             ;
0184++ 27F6             HXOUT:
0185++ 27F6 C5          	PUSH	BC			; SAVE BC
0186++ 27F7 F5          	PUSH	AF			;
0187++ 27F8 47          	LD	B,A			;
0188++ 27F9 CB 07       	RLC	A			; DO HIGH NIBBLE FIRST  
0189++ 27FB CB 07       	RLC	A			;
0190++ 27FD CB 07       	RLC	A			;
0191++ 27FF CB 07       	RLC	A			;
0192++ 2801 E6 0F       	AND	0FH			; ONLY THIS NOW
0193++ 2803 C6 30       	ADD	A,30H			; TRY A NUMBER
0194++ 2805 FE 3A       	CP	3AH			; TEST IT
0195++ 2807 38 02       	JR	C,OUT1			; IF CY SET PRINT 'NUMBER'
0196++ 2809 C6 07       	ADD	A,07H			; MAKE IT AN ALPHA
0197++ 280B             OUT1:
0198++ 280B CD A2 00    	CALL	$00A2			; SCREEN IT
0199++ 280E 78          	LD	A,B			; NEXT NIBBLE
0200++ 280F E6 0F       	AND	0FH			; JUST THIS
0201++ 2811 C6 30       	ADD	A,30H			; TRY A NUMBER
0202++ 2813 FE 3A       	CP	3AH			; TEST IT
0203++ 2815 38 02       	JR	C,OUT2			; PRINT 'NUMBER'
0204++ 2817 C6 07       	ADD	A,07H			; MAKE IT ALPHA
0205++ 2819             OUT2:
0206++ 2819 CD A2 00    	CALL	$00A2			; SCREEN IT
0207++ 281C F1          	POP	AF			;
0208++ 281D C1          	POP	BC			; RESTORE BC
0209++ 281E C9          	RET				;
0210++ 281F             
0211++ 281F             
0212++ 281F             ;__SPACE_________________________________________________________________________________________________________________________ 
0213++ 281F             ;
0214++ 281F             ;	PRINT A SPACE CHARACTER 
0215++ 281F             ;________________________________________________________________________________________________________________________________
0216++ 281F             ;
0217++ 281F             SPACE:
0218++ 281F F5          	PUSH	AF			; STORE AF
0219++ 2820 3E 20       	LD	A,20H			; LOAD A "SPACE"
0220++ 2822 CD A2 00    	CALL	$00A2			; SCREEN IT
0221++ 2825 F1          	POP	AF			; RESTORE AF
0222++ 2826 C9          	RET				; DONE
0223++ 2827             
0224++ 2827             ;__PHL_________________________________________________________________________________________________________________________ 
0225++ 2827             ;
0226++ 2827             ;	PRINT THE HL REG 
0227++ 2827             ;________________________________________________________________________________________________________________________________
0228++ 2827             ;
0229++ 2827             PHL:
0230++ 2827 F5          	PUSH	AF
0231++ 2828 7C          	LD	A,H			; GET HI BYTE
0232++ 2829 CD F6 27    	CALL	HXOUT			; DO HEX OUT ROUTINE
0233++ 282C 7D          	LD	A,L			; GET LOW BYTE
0234++ 282D CD F6 27    	CALL	HXOUT			; HEX IT
0235++ 2830 CD 1F 28    	CALL	SPACE			; 
0236++ 2833 F1          	POP	AF
0237++ 2834 C9          	RET				; DONE  
0238++ 2835             
0239++ 2835             ;__MONPOUT__________________________________________________________________________________________________________________________ 
0240++ 2835             ;
0241++ 2835             ;	OUTPUT TO AN I/O PORT, MONITOR COMMAND "O"
0242++ 2835             ;________________________________________________________________________________________________________________________________
0243++ 2835             ;
0244++ 2835             MONPOUT:
0245++ 2835             POUT1:
0246++ 2835 23          	INC	HL			;
0247++ 2836 CD D5 27    	CALL	HEXIN			; GET PORT
0248++ 2839 4F          	LD	C,A			; SAVE PORT POINTER
0249++ 283A 23          	INC	HL			;
0250++ 283B CD D5 27    	CALL	HEXIN			; GET DATA
0251++ 283E             OUTIT:
0252++ 283E ED 79       	OUT	(C),A			;
0253++ 2840 C3 80 27    	JP	MONITORCMDLOOP		;
0254++ 2843             
0255++ 2843             
0256++ 2843             ;__PIN___________________________________________________________________________________________________________________________ 
0257++ 2843             ;
0258++ 2843             ;	INPUT FROM AN I/O PORT, MONITOR COMMAND "I"
0259++ 2843             ;________________________________________________________________________________________________________________________________
0260++ 2843             ;
0261++ 2843             PIN:
0262++ 2843 23          	INC 	HL			;
0263++ 2844 CD D5 27    	CALL	HEXIN			; GET PORT
0264++ 2847 4F          	LD	C,A			; SAVE PORT POINTER
0265++ 2848 CD C0 27    	CALL	CRLF			;
0266++ 284B ED 78       	IN	A,(C)			; GET DATA
0267++ 284D CD F6 27    	CALL	HXOUT			; SHOW IT
0268++ 2850 C3 80 27    	JP	MONITORCMDLOOP	        ;
0269++ 2853             
0270++ 2853             
0271++ 2853             
0272++ 2853             
0273++ 2853             
0274++ 2853             ;__CRLFA_________________________________________________________________________________________________________________________ 
0275++ 2853             ;
0276++ 2853             ;	PRINT COMMAND PROMPT 
0277++ 2853             ;________________________________________________________________________________________________________________________________
0278++ 2853             ;
0279++ 2853             CRLFA:
0280++ 2853 E5          	PUSH	HL			; PROTECT HL FROM OVERWRITE
0281++ 2854 21 6E 29    	LD	HL,PROMPT		;
0282++ 2857 CD AD 0E    	CALL	prn_text		;
0283++ 285A E1          	POP	HL			; PROTECT HL FROM OVERWRITE
0284++ 285B C9          	RET				; DONE
0285++ 285C             
0286++ 285C             
0287++ 285C             
0288++ 285C             ;__MONRUN___________________________________________________________________________________________________________________________ 
0289++ 285C             ;
0290++ 285C             ;	TRANSFER OUT OF MONITOR, USER OPTION "R"
0291++ 285C             ;________________________________________________________________________________________________________________________________
0292++ 285C             ;
0293++ 285C             MONRUN:
0294++ 285C 23          	INC	HL			; SHOW READY
0295++ 285D CD C9 27    	CALL	LDHL			; GET START ADDRESS
0296++ 2860 E9          	JP	(HL)			;	
0297++ 2861             
0298++ 2861             
0299++ 2861             ;__PROGRM________________________________________________________________________________________________________________________ 
0300++ 2861             ;
0301++ 2861             ;	PROGRAM RAM LOCATIONS, USER OPTION "P"
0302++ 2861             ;________________________________________________________________________________________________________________________________
0303++ 2861             ;
0304++ 2861             PROGRM:
0305++ 2861 23          	INC	HL			; SHOW READY
0306++ 2862 E5          	PUSH	HL			; STORE HL
0307++ 2863 CD C9 27    	CALL	LDHL			; GET START ADDRESS
0308++ 2866 54          	LD	D,H			;
0309++ 2867 5D          	LD	E,L			; DE POINTS TO ADDRESS TO PROGRAM
0310++ 2868 E1          	POP	HL			;
0311++ 2869 23          	INC	HL			;
0312++ 286A 23          	INC	HL			;
0313++ 286B 23          	INC	HL			;
0314++ 286C 23          	INC	HL			;
0315++ 286D 23          	INC	HL			;
0316++ 286E             PROGRMLP:
0317++ 286E CD D5 27    	CALL	HEXIN			; GET NEXT HEX NUMBER
0318++ 2871 12          	LD	(DE),A			; STORE IT
0319++ 2872 13          	INC	DE			; NEXT ADDRESS;
0320++ 2873 CD 53 28    	CALL	CRLFA			; CR,LF,>
0321++ 2876 3E 50       	LD      A,'P'			;
0322++ 2878 CD A2 00    	CALL	$00A2			;
0323++ 287B CD 1F 28    	CALL  	SPACE			;
0324++ 287E 62          	LD	H,D			;
0325++ 287F 6B          	LD	L,E			;
0326++ 2880 CD 27 28    	CALL	PHL			;
0327++ 2883 CD B3 27    	CALL 	MONGETLN		; GET A LINE OF INPUT FROM THE USER
0328++ 2886 7E                  LD      A,(HL)			; LOAD FIRST CHAR INTO A 
0329++ 2887 FE 00       	CP	00H			; END OF LINE?
0330++ 2889 CA 8F 28    	JP	Z,PROGRMEXIT		; YES, EXIT
0331++ 288C C3 6E 28    	JP	PROGRMLP		; NO, LOOP
0332++ 288F             PROGRMEXIT:
0333++ 288F C3 80 27    	JP	MONITORCMDLOOP	
0334++ 2892             
0335++ 2892             
0336++ 2892             
0337++ 2892             
0338++ 2892             
0339++ 2892             
0340++ 2892             
0341++ 2892             ;__DUMP__________________________________________________________________________________________________________________________ 
0342++ 2892             ;
0343++ 2892             ;	PRINT A MEMORY DUMP, USER OPTION "D"
0344++ 2892             ;________________________________________________________________________________________________________________________________
0345++ 2892             ;
0346++ 2892             DUMP:
0347++ 2892 23          	INC	HL			; SHOW READY
0348++ 2893 E5          	PUSH	HL			; STORE HL
0349++ 2894 CD C9 27    	CALL	LDHL			; GET START ADDRESS
0350++ 2897 54          	LD	D,H			;
0351++ 2898 5D          	LD	E,L			;
0352++ 2899 E1          	POP	HL			;
0353++ 289A D5          	PUSH	DE			; SAVE START
0354++ 289B 23          	INC	HL			;
0355++ 289C 23          	INC	HL			;
0356++ 289D 23          	INC	HL			;
0357++ 289E 23          	INC	HL			;
0358++ 289F 23          	INC	HL			;
0359++ 28A0 CD C9 27    	CALL	LDHL			; GET END ADDRESS
0360++ 28A3 23          	INC	HL			; ADD ONE MORE FOR LATER COMPARE
0361++ 28A4 EB          	EX	DE,HL			; PUT END ADDRESS IN DE
0362++ 28A5 E1          	POP	HL			; GET BACK START
0363++ 28A6             GDATA:	
0364++ 28A6 CD C0 27    	CALL	CRLF			;	
0365++ 28A9             BLKRD:
0366++ 28A9 CD 27 28    	CALL	PHL			; PRINT START LOCATION
0367++ 28AC 0E 08       	LD	C,8			; SET FOR 16 LOCS
0368++ 28AE E5          	PUSH	HL			; SAVE STARTING HL
0369++ 28AF             NXTONE:
0370++ 28AF D9          	EXX				;
0371++ 28B0 4B          	LD	C,E			;
0372++ 28B1 ED 78       	IN	A,(C)			;
0373++ 28B3 D9          	EXX				;
0374++ 28B4 E6 7F       	AND	7FH			;
0375++ 28B6 FE 1B       	CP	ESC			;
0376++ 28B8 CA 80 27    	JP	Z,MONITORCMDLOOP	;
0377++ 28BB FE 13       	CP	19			;
0378++ 28BD 28 F0       	JR	Z,NXTONE		;
0379++ 28BF 7E          	LD 	A,(HL)			; GET BYTE
0380++ 28C0 CD F6 27    	CALL	HXOUT			; PRINT IT
0381++ 28C3 CD 1F 28    	CALL	SPACE			;
0382++ 28C6             UPDH:	
0383++ 28C6 23          	INC	HL			; POINT NEXT
0384++ 28C7 0D          	DEC	C			; DEC  LOC COUNT
0385++ 28C8 20 E5       	JR	NZ,NXTONE		; IF LINE NOT DONE
0386++ 28CA             					; NOW PRINT 'DECODED' DATA TO RIGHT OF DUMP
0387++ 28CA             PCRLF:
0388++ 28CA CD 1F 28    	CALL	SPACE			; SPACE IT
0389++ 28CD 0E 08       	LD	C,8			; SET FOR 16 CHARS
0390++ 28CF E1          	POP	HL			; GET BACK START
0391++ 28D0             PCRLF0:
0392++ 28D0 7E          	LD	A,(HL)			; GET BYTE
0393++ 28D1 E6 60       	AND	060H			; SEE IF A 'DOT'
0394++ 28D3 7E          	LD	A,(HL)			; O K. TO GET
0395++ 28D4 20 02       	JR	NZ,PDOT			;
0396++ 28D6 3E 2E       	LD	A,2EH			; LOAD A DOT	
0397++ 28D8             PDOT:
0398++ 28D8 CD A2 00    	CALL	$00A2			; PRINT IT
0399++ 28DB 23          	INC	HL			; 
0400++ 28DC 7A          	LD	A,D			;
0401++ 28DD BC          	CP	H			;
0402++ 28DE 20 05       	JR	NZ,UPDH1		;
0403++ 28E0 7B          	LD	A,E			;
0404++ 28E1 BD          	CP	L			;
0405++ 28E2 CA 80 27    	JP	Z,MONITORCMDLOOP	;
0406++ 28E5             ;
0407++ 28E5             ;IF BLOCK NOT DUMPED, DO NEXT CHARACTER OR LINE
0408++ 28E5             UPDH1:
0409++ 28E5 0D          	DEC	C			; DEC  CHAR COUNT
0410++ 28E6 20 E8       	JR	NZ,PCRLF0		; DO NEXT
0411++ 28E8             CONTD:
0412++ 28E8 CD C0 27    	CALL	CRLF			;
0413++ 28EB C3 A9 28    	JP	BLKRD			;
0414++ 28EE             
0415++ 28EE             
0416++ 28EE             
0417++ 28EE             
0418++ 28EE             ;__MOVE__________________________________________________________________________________________________________________________ 
0419++ 28EE             ;
0420++ 28EE             ;	MOVE MEMORY, USER OPTION "M"
0421++ 28EE             ;________________________________________________________________________________________________________________________________
0422++ 28EE             ;
0423++ 28EE             MOVE:
0424++ 28EE 0E 03       	LD	C,03
0425++ 28F0             					; START GETNM REPLACEMENT
0426++ 28F0             					; GET SOURCE STARTING MEMORY LOCATION
0427++ 28F0 23          	INC	HL			; SHOW EXAMINE READY
0428++ 28F1 E5          	PUSH	HL			;
0429++ 28F2 CD C9 27    	CALL	LDHL			; LOAD IN HL REGS 
0430++ 28F5 54          	LD	D,H			;
0431++ 28F6 5D          	LD	E,L			;
0432++ 28F7 E1          	POP	HL			;
0433++ 28F8 D5          	PUSH	DE			; PUSH MEMORY ADDRESS ON STACK
0434++ 28F9 23          	INC	HL			;
0435++ 28FA 23          	INC	HL			;
0436++ 28FB 23          	INC	HL			;
0437++ 28FC 23          	INC	HL			;
0438++ 28FD 23          	INC 	HL			; PRINT SPACE SEPARATOR
0439++ 28FE E5          	PUSH	HL			;
0440++ 28FF CD C9 27    	CALL	LDHL			; LOAD IN HL REGS 
0441++ 2902 54          	LD	D,H			;
0442++ 2903 5D          	LD	E,L			;
0443++ 2904 E1          	POP	HL			;
0444++ 2905 D5          	PUSH	DE			; PUSH MEMORY ADDRESS ON STACK
0445++ 2906 23          	INC	HL			;
0446++ 2907 23          	INC	HL			;
0447++ 2908 23          	INC	HL			;
0448++ 2909 23          	INC	HL			;
0449++ 290A 23          	INC	HL			; PRINT SPACE SEPARATOR
0450++ 290B CD C9 27    	CALL	LDHL			; LOAD IN HL REGS 
0451++ 290E E5          	PUSH	HL			; PUSH MEMORY ADDRESS ON STACK
0452++ 290F             					; END GETNM REPLACEMENT
0453++ 290F D1          	POP	DE			; DEST
0454++ 2910 C1          	POP	BC			; SOURCE END
0455++ 2911 E1          	POP	HL			; SOURCE
0456++ 2912 E5          	PUSH    HL			;
0457++ 2913 7D          	LD	A,L			;
0458++ 2914 2F          	CPL				;
0459++ 2915 6F          	LD	L,A			;
0460++ 2916 7C          	LD	A,H			;
0461++ 2917 2F          	CPL				;
0462++ 2918 67          	LD	H,A			;
0463++ 2919 23          	INC	HL			;
0464++ 291A 09          	ADD	HL,BC			;
0465++ 291B 4D          	LD	C,L			;
0466++ 291C 44          	LD	B,H			;
0467++ 291D E1          	POP     HL        		;
0468++ 291E CD 24 29    	CALL    MOVE_LOOP		;
0469++ 2921 C3 80 27    	JP	MONITORCMDLOOP			; EXIT MOVE COMMAND ROUTINE
0470++ 2924             MOVE_LOOP:
0471++ 2924 7E          	LD	A,(HL)			; FETCH
0472++ 2925 12          	LD	(DE),A			; DEPOSIT
0473++ 2926 23          	INC     HL			; BUMP  SOURCE
0474++ 2927 13          	INC     DE			; BUMP DEST
0475++ 2928 0B          	DEC     BC			; DEC COUNT
0476++ 2929 79          	LD	A,C			;
0477++ 292A B0          	OR	B       		;
0478++ 292B C2 24 29    	JP	NZ,MOVE_LOOP		; TIL COUNT=0
0479++ 292E C9          	RET				;
0480++ 292F                            
0481++ 292F             ;__FILL__________________________________________________________________________________________________________________________ 
0482++ 292F             ;
0483++ 292F             ;	FILL MEMORY, USER OPTION "M"
0484++ 292F             ;________________________________________________________________________________________________________________________________
0485++ 292F             ;
0486++ 292F             FILL:
0487++ 292F 0E 03       	LD	C,03			;
0488++ 2931             					; START GETNM REPLACEMENT
0489++ 2931             					; GET FILL STARTING MEMORY LOCATION
0490++ 2931 23          	INC	HL			; SHOW EXAMINE READY
0491++ 2932 E5          	PUSH	HL			;
0492++ 2933 CD C9 27    	CALL	LDHL			; LOAD IN HL REGS 
0493++ 2936 54          	LD	D,H			;
0494++ 2937 5D          	LD	E,L			;
0495++ 2938 E1          	POP	HL			;
0496++ 2939 D5          	PUSH	DE			; PUSH MEMORY ADDRESS ON STACK
0497++ 293A 23          	INC	HL			;
0498++ 293B 23          	INC	HL			;
0499++ 293C 23          	INC	HL			;
0500++ 293D 23          	INC	HL			;
0501++ 293E 23          	INC	HL			; PRINT SPACE SEPARATOR
0502++ 293F             					; GET FILL ENDING MEMORY LOCATION
0503++ 293F E5          	PUSH	HL			;
0504++ 2940 CD C9 27    	CALL	LDHL			; LOAD IN HL REGS 
0505++ 2943 54          	LD	D,H			;
0506++ 2944 5D          	LD	E,L			;
0507++ 2945 E1          	POP	HL			;
0508++ 2946 D5          	PUSH	DE			; PUSH MEMORY ADDRESS ON STACK
0509++ 2947 23          	INC	HL			;
0510++ 2948 23          	INC	HL			;
0511++ 2949 23          	INC	HL			;
0512++ 294A 23          	INC	HL			;
0513++ 294B 23          	INC	HL			; PRINT SPACE SEPARATOR
0514++ 294C             					; GET TARGET STARTING MEMORY LOCATION
0515++ 294C CD D5 27    	CALL	HEXIN			; GET K B. AND MAKE HEX
0516++ 294F 4F          	LD	C,A			; PUT FILL VALUE IN F SO IT IS SAVED FOR LATER
0517++ 2950 C5          	PUSH	BC			; PUSH FILL VALUE BYTE ON STACK
0518++ 2951             					; END GETNM REPLACEMENT
0519++ 2951 C1          	POP	BC			; BYTE
0520++ 2952 D1          	POP	DE			; END
0521++ 2953 E1          	POP	HL			; START
0522++ 2954 71          	LD	(HL),C			;
0523++ 2955             FILL_LOOP:
0524++ 2955 71          	LD	(HL),C			;
0525++ 2956 23          	INC     HL			;
0526++ 2957 7B          	LD	A,E			;
0527++ 2958 95          	SUB     L			;
0528++ 2959 47          	LD	B,A			;
0529++ 295A 7A          	LD	A,D			;
0530++ 295B 94          	SUB     H			;
0531++ 295C B0          	OR	B			;
0532++ 295D C2 55 29    	JP	NZ,FILL_LOOP		;
0533++ 2960 C3 80 27    	JP	MONITORCMDLOOP		;
0534++ 2963             
0535++ 2963             
0536++ 2963             ;
0537++ 2963             ;__FILL_MEM_______________________________________________________________________________________________________________________ 
0538++ 2963             ;
0539++ 2963             ;	FUNCTION	: FILL MEMORY WITH A VALUE
0540++ 2963             ;	INPUT		: HL = START ADDRESS BLOCK
0541++ 2963             ;			: BC = LENGTH OF BLOCK
0542++ 2963             ;			: A = VALUE TO FILL WITH
0543++ 2963             ;	USES		: DE, BC
0544++ 2963             ;	OUTPUT		:
0545++ 2963             ;	CALLS		: 
0546++ 2963             ;	TESTED		: 13 FEB 2007
0547++ 2963             ;_________________________________________________________________________________________________________________________________
0548++ 2963             ;
0549++ 2963             FILL_MEM:
0550++ 2963 5D          	LD	E,L			;
0551++ 2964 54          	LD	D,H			;
0552++ 2965 13          	INC	DE			;
0553++ 2966 77          	LD	(HL),A			; INITIALISE FIRST BYTE OF BLOCK WITH DATA BYTE IN A
0554++ 2967 0B          	DEC	BC			;
0555++ 2968 ED B0       	LDIR				; FILL MEMORY
0556++ 296A C9          	RET				; RETURN TO CALLER
0557++ 296B             
0558++ 296B             
0559++ 296B             
0560++ 296B             ;
0561++ 296B             ;__TEXT_STRINGS_________________________________________________________________________________________________________________ 
0562++ 296B             ;
0563++ 296B             ;	SYSTEM TEXT STRINGS
0564++ 296B             ;_____________________________________________________________________________________________________________________________
0565++ 296B             ;
0566++ 296B             TCRLF:
0567++ 296B 0D 0A 00    	.DB  	CR,LF,ENDT
0568++ 296E             
0569++ 296E             PROMPT:
0570++ 296E 0D 0A 3E 00 	.DB  	CR,LF,'>',ENDT
0571++ 2972             
0572++ 2972             TXT_IDENT:
0573++ 2972 4E 38 56 45 	.TEXT   "N8VEM HOME COMPUTER  MSX BIOS V0.1"
0573++ 2976 4D 20 48 4F 
0573++ 297A 4D 45 20 43 
0573++ 297E 4F 4D 50 55 
0573++ 2982 54 45 52 20 
0573++ 2986 20 4D 53 58 
0573++ 298A 20 42 49 4F 
0573++ 298E 53 20 56 30 
0573++ 2992 2E 31 
0574++ 2994 0D 0A 00    	.DB   CR,LF,ENDT
0575++ 2997             TXT_READY:	
0576++ 2997 4D 4F 4E 49 	.TEXT   "MONITOR READY "
0576++ 299B 54 4F 52 20 
0576++ 299F 52 45 41 44 
0576++ 29A3 59 20 
0577++ 29A5 0D 0A 00    	.DB   CR,LF,ENDT
0578++ 29A8             
0579++ 29A8             TXT_COMMAND:
0580++ 29A8 0D 0A       	.DB   CR,LF
0581++ 29AA 55 4E 4B 4E 	.TEXT   "UNKNOWN COMMAND."
0581++ 29AE 4F 57 4E 20 
0581++ 29B2 43 4F 4D 4D 
0581++ 29B6 41 4E 44 2E 
0582++ 29BA 00          	.DB   ENDT
0583++ 29BB             
0584++ 29BB             
0585++ 29BB             
0586++ 29BB              
0587++ 29BB              
2453+  29BB                             .include "BASIC.asm"
0001++ 29BB             ;**************************************************************
0002++ 29BB             ;*                       MICRO-BASIC                          *
0003++ 29BB             ;*------------------------------------------------------------*
0004++ 29BB             ;*   A SMALL INTEGER BASIC INTERPRETER FOR THE 8080/8085/Z80  *
0005++ 29BB             ;*                                D.F. DUNFIELD  JAN 25/1983  *
0006++ 29BB             ;*                                WWW.DUNFIELD.COM            *
0007++ 29BB             ;*                                                            *
0008++ 29BB             ;*   MODIFIED FOR THE N8VEM HOME COMPUTER 11/21/2010          *
0009++ 29BB             ;*   BY Dan Werner                                            *
0010++ 29BB             ;*                                                            *
0011++ 29BB             ;*------------------------------------------------------------*
0012++ 29BB             ;*                      BASIC COMMANDS                        *
0013++ 29BB             ;*                                                            *
0014++ 29BB             ;*  CLEAR,    DATA,     DIM,      END,      EXIT,     FOR,    *
0015++ 29BB             ;*  GOSUB,    GOSUB(N), GOTO,     GOTO(N),  IF/THEN,  INPUT,  *
0016++ 29BB             ;*  LET,      LIF/THEN, LIST,     LOAD,     NEW,      NEXT,   *
0017++ 29BB             ;*  ORDER,    PLOT,     PRINT,    READ,     REM,      RETURN, *
0018++ 29BB             ;*  RUN,      SAVE,     SIZE,     STOP,     USR,      <EDIT>  *
0019++ 29BB             ;*------------------------------------------------------------*
0020++ 29BB             ;*                     BASIC OPERATORS                        *
0021++ 29BB             ;*                                                            *
0022++ 29BB             ;* NUMERIC:     + - * % / \ & | ; ( ) < = > == -= <= >=       *
0023++ 29BB             ;* CHARACTER:   + = == -=                                     *
0024++ 29BB             ;* OTHER:       : # $ @ ? [ ] ( )                             *
0025++ 29BB             ;*------------------------------------------------------------*
0026++ 29BB             ;*                      BASIC VARIABLES                       *
0027++ 29BB             ;*                                                            *
0028++ 29BB             ;*     A - Z ......... 16 BIT SIMPLE INTEGER VARIABLES.       *
0029++ 29BB             ;*     A$ - Z$ ....... SIMPLE CHARACTER VARIABLES. < 36 CHARS *
0030++ 29BB             ;*     A[N] - Z[N] ... 16 BIT INTEGER ARRAYS.                 *
0031++ 29BB             ;*     @[N] .......... PSEUDO MEMORY REFERENCE ARRAY.         *
0032++ 29BB             ;*     @[N]$ ......... NUMERIC TO CHARACTER CONVERSION.(CHR$) *
0033++ 29BB             ;*     ? ............. PSEUDO RANDOM NUMBER GENERATOR.        *
0034++ 29BB             ;*------------------------------------------------------------*
0035++ 29BB             ;*                        MEMORY MAP                          *
0036++ 29BB             ;*                                                            *
0037++ 29BB             ;*    		    3K BASIC INTERPRETER 		      *
0038++ 29BB             ;*    4000-41FF     0.5K POINTERS, STACKS, BUFFERS.           *
0039++ 29BB             ;*    4200-45FF     1K VARIABLES AND POINTERS.                *
0040++ 29BB             ;*    4600-FFFF     PROGRAM AND ARRAY STORAGE.                *
0041++ 29BB             ;**************************************************************
0042++ 29BB             ;*
0043++ 29BB             ;**************************************************************
0044++ 29BB             ;*                   CONSTANTS AND .EQUATES
0045++ 29BB             ;**************************************************************
0046++ 29BB             ;*
0047++ 29BB             ;* MONITOR ROUTINES
0048++ 29BB             ;*
0049++ 29BB             OUT	.EQU	$00A2		;OUTPUT ROUTINE ADDRESS
0050++ 29BB             EXIT	.EQU	DOTINYMON	;TERMINATION RETURN ADDRESS
0051++ 29BB             GETR	.EQU	$00E4		;ROUTINE TO LOAD INTEL HEX FORMAT
0052++ 29BB             TDUMP	.EQU	$00ED		;ROUTINE TO DUMP IN INTEL HEX FORMAT
0053++ 29BB             TON	.EQU	$00E1		;ROUTINE TO START TAPE
0054++ 29BB             TOFF	.EQU	$00E7		;ROUTINE TO STOP TAPE
0055++ 29BB             NL	.EQU	CRLF		;ROUTINE TO PRINT A <LF>, <CR> ON TERMINAL
0056++ 29BB             PMSG	.EQU	prn_text	;DISPLAY'S MSG(HL) UP TO ZERO OR <CR>
0057++ 29BB             
0058++ 29BB             ;* MEMORY ALLOCATION
0059++ 29BB             BUFF	.EQU	$4000		;START OF RAM, INPUT BUFFER
0060++ 29BB             IOCON	.EQU	BUFF+$FF	;INPUT/OUTPUT CONFIGURATION
0061++ 29BB             USROUT	.EQU	IOCON-2		;USER SUPPLIED OUTPUT DEVICE VECTOR
0062++ 29BB             CURSOR	.EQU	USROUT-2	;CURSOR POSITION
0063++ 29BB             LSTCHR	.EQU	CURSOR-2	;CHARACTER UNDER CURSOR
0064++ 29BB             STACK	.EQU	LSTCHR-2	;MACHINE STACK
0065++ 29BB             TB	.EQU	BUFF+50		;TEMPORARY TEXT BUFFER
0066++ 29BB             XBF	.EQU	TB+50		;EXTRA TEXT BUFFER
0067++ 29BB             EDBUF	.EQU	BUFF+256	;EDIT BUFFER
0068++ 29BB             CS	.EQU	EDBUF+$FA	;CONTROL STACK SPACE
0069++ 29BB             CSP	.EQU	CS+1		;CONTROL STACK POINTER
0070++ 29BB             ARYLOC	.EQU	CSP+2		;LOCATION OF ARRAYS
0071++ 29BB             SEED	.EQU	ARYLOC+1	;RANDOM NUMBER SEED
0072++ 29BB             VARS	.EQU	SEED+2		;VARIABLE SPACE
0073++ 29BB             RFLAG	.EQU	VARS+52		;PROGRAM RUNNING FLAG
0074++ 29BB             IFLAG	.EQU	RFLAG+1		;INPUTTING FLAG
0075++ 29BB             P	.EQU	IFLAG+1		;POINTER TO END OF EXPRESSION
0076++ 29BB             EFLAG	.EQU	P+1		;ASSIGNMENT FLAG
0077++ 29BB             DATA	.EQU	EFLAG+1		;READ/DATA POINTER
0078++ 29BB             LAST	.EQU	DATA+2		;LAST FREE ARRAY SPACE
0079++ 29BB             TEMPBAS	.EQU	LAST+2		;TEMPORARY STORAGE
0080++ 29BB             TEXT	.EQU	VARS+1024	;PROGRAM AND ARRAY STORAGE
0081++ 29BB             DELETE	.EQU	$7F		;DELETE CHARACTER
0082++ 29BB             VARSEND	.EQU	VARS+$0400
0083++ 29BB             ;*
0084++ 29BB             ;********************************************************************
0085++ 29BB             ;* START OF MAIN PROGRAM, FIRST INITIALIZE, INSURING WE DON'T THINK *
0086++ 29BB             ;* WE HAVE A VALID PROGRAM, ALSO CLEAR OUT HIS VARIABLES AND ARRAYS *
0087++ 29BB             ;********************************************************************
0088++ 29BB             ;*
0089++ 29BB             STARTBASIC:
0090++ 29BB             BASIC:
0091++ 29BB 3E 01       	LD	A,1		; ENABLE CURSOR
0092++ 29BD 32 A9 FC    	LD      (CSRSW),A	;
0093++ 29C0 21 72 29    	LD	HL,TXT_IDENT	;POINT AT TEXT
0094++ 29C3 CD AD 0E    	CALL	prn_text	;SHOW WE'RE HERE
0095++ 29C6 21 D5 34    	LD	HL,TXT_BASICID	;POINT AT TEXT
0096++ 29C9 CD AD 0E    	CALL	prn_text	;SHOW WE'RE HERE
0097++ 29CC 3E FF       NEW:	LD	A,$FF		;INDICATES END OF PROGRAM
0098++ 29CE 32 00 46    	LD	(TEXT),A	;INITIALIZE TO NO PROGRAM
0099++ 29D1 CD BC 2B    RESV:	CALL	CLEAR		;CLEAR OUT HIS VARIABLES
0100++ 29D4             ;* RESET FLAGS, AND PROMPT WITH 'READY', SO HE WILL KNOW WE ARE LISTENING
0101++ 29D4 21 00 00    INIT:	LD	HL,0		;GET DOUBLE BYTE ZERO
0102++ 29D7 22 34 42    	LD	(RFLAG),HL	;INDICATE NOT RUNNING, AND NOT INPUT
0103++ 29DA 22 36 42    	LD	(P),HL		;INDICATE NO ASSIGNMENT DONE
0104++ 29DD 21 B7 34    	LD	HL,RDY		;ADDRESS OF 'READY' MESSAGE
0105++ 29E0 CD AD 0E    	CALL	PMSG		;TELL HIM WE ARE READY
0106++ 29E3             ;* GET A LINE FROM CONSOLE, AND SEE WHAT HE WANTS
0107++ 29E3 31 F7 40    TOP:	LD	SP,STACK	;FIX UP STACK IN CASE WE ABORTED SOMETHING
0108++ 29E6 CD 74 2A    	CALL	GLINE		;LET HIM GIVE US A LINE
0109++ 29E9 FE 0D       	CP	$0D		;DID HE ONLY PRESS RETURN
0110++ 29EB CA E3 29    	JP	Z,TOP		;NOT GOOD ENOUGH, MAKE HIM TRY AGAIN
0111++ 29EE CD 6A 2A    	CALL	NUM		;DID HIS LINE START WITH A NUMBER
0112++ 29F1 D2 B0 2A    	JP	NC,EDIT		;IF SO, HE IS WRITEING A PROGRAM!!!
0113++ 29F4             ;* LOOK UP COMMAND AND EXECUTE
0114++ 29F4 01 D4 29    	LD	BC,INIT		;ADDRESS TO RETURN TO
0115++ 29F7 C5          	PUSH	BC		;SAVE SO WE CAN RETURN
0116++ 29F8 21 DA 33    	LD	HL,KTAB-1	;POINT TO COMMAND TABLE
0117++ 29FB             ;*
0118++ 29FB             ;* LOCATES COMMAND POINTED TO BY D-E IN THE COMMAND TABLE POINTED TO BY H-L
0119++ 29FB             ;* AND CHAINS TO THE COMMAND PROCESSING CODE FOR THAT COMMAND
0120++ 29FB             ;*
0121++ 29FB CD EF 2F    CMD:	CALL	PARSE1		;ADVANCE TO NEXT CHARACTER
0122++ 29FE D5          TLP0:	PUSH	DE		;SAVE POINTER TO START OF COMMAND
0123++ 29FF 23          CMDL:	INC	HL		;ADVANCE IN TABLE
0124++ 2A00 1A          	LD	A,(DE)		;GET DATA FROM COMMAND
0125++ 2A01 BE          	CP	(HL)		;COMPARE WITH TABLE CONTENTS
0126++ 2A02 13          	INC	DE		;ADVANCE IN COMMAND
0127++ 2A03 CA FF 29    	JP	Z,CMDL		;IF SAME, KEEP TESTING
0128++ 2A06             ;* DIDN'T MATCH, SEE IF IT'S END OF WORD (HIGH BIT SET)
0129++ 2A06 F6 80       	OR	$80		;ARE WE AT END?
0130++ 2A08 BE          	CP	(HL)		;AND IS IT THIS ONE?
0131++ 2A09 CA 1C 2A    	JP	Z,GOTCMD	;IF SO, WE HAVE IT
0132++ 2A0C             ;* WASN'T THAT ENTRY, KEEP LOOKING
0133++ 2A0C 97          	SUB	A		;SEE IT THIS IS END OF TABLE
0134++ 2A0D BE          	CP	(HL)		;ARE WE AT END?
0135++ 2A0E CA 1B 2A    	JP	Z,GOTDEF	;IF SO, WE WILL SAY WE FOUND
0136++ 2A11 D1          	POP	DE		;RESTORE POINTER TO COMMAND
0137++ 2A12 B6          CMD1:	OR	(HL)		;TEST FOR AT END OF TABLE ENTRY
0138++ 2A13 23          	INC	HL		;POINT TO NEXT
0139++ 2A14 F2 12 2A    	JP	P,CMD1		;IF NO, KEEP LOOKING
0140++ 2A17 23          	INC	HL		;SKIP FIRST ADDRESS BYTE
0141++ 2A18 C3 FE 29    	JP	TLP0		;TEST THIS ENTRY
0142++ 2A1B             ;* WE HIT THE END OF THE TABLE, ASSUME THE DEFAULT ADDRESS (LET)
0143++ 2A1B 1B          GOTDEF:	DEC	DE		;BACKUP TO START OF WORD
0144++ 2A1C             ;* WE MATCHED ALL THE WAY TO THE END OF A COMMAND WORD, GET IT'S ADDRESS
0145++ 2A1C 23          GOTCMD:	INC	HL		;POINT TO ADDRESS BYTE
0146++ 2A1D 4E          	LD	C,(HL)		;SAVE TEMPORARY
0147++ 2A1E 23          	INC	HL		;POINT TO NEXT ADDRESS BYTE
0148++ 2A1F 66          	LD	H,(HL)		;GET LOW ADDRESS
0149++ 2A20 69          	LD	L,C		;GET HIGH ADDRESS
0150++ 2A21 E3          	EX	(SP),HL		;PLACE CODE ADDRESS ON STACK, REMOVE TRASH
0151++ 2A22 C3 EF 2F    	JP	PARSE1		;SKIP TO NEXT NON-BLANK, AND CHAIN TO CODE
0152++ 2A25             ;*
0153++ 2A25             ;****************************************************************
0154++ 2A25             ;*              ERROR CHECKING AND HANDLING CODE
0155++ 2A25             ;****************************************************************
0156++ 2A25             ;*
0157++ 2A25             ;* VCHAR....TESTS FOR A VALID VARIABLE, SYNTAX ERROR IF NOT
0158++ 2A25             ;*
0159++ 2A25 CD E7 2F    VCHAR:	CALL	CHAR		;TEST VARIABLE
0160++ 2A28 D0          	RET	NC		;IF OK, GO BACK
0161++ 2A29             ;*
0162++ 2A29             ;* SYNTAX ERROR... HE'S NOT MAKEING ANY SENSE AT ALL
0163++ 2A29             ;* ISSUE NASTY MESSAGE TO STRAIGHTEN HIM OUT
0164++ 2A29             ;*
0165++ 2A29 21 A1 34    SYNT:	LD	HL,SYN		;GET NASTY 'SYNTAX' MESSAGE
0166++ 2A2C 1B          	DEC	DE		;BACK UP IN SOURCE SO WE DONT SAY WRONG LINE
0167++ 2A2D             ;*
0168++ 2A2D             ;* ERROR STUFF... SOMETHING HAS GONE WRONG... TELL HIM THE BAD NEWS AND
0169++ 2A2D             ;* QUIT ANYTHING THAT WE MAY HAVE STARTED, SO THAT THINGS CAN'T GET WORSE
0170++ 2A2D             ;* ALSO, IF WE WERE RUNNING, GIVE HIM THE LINE NUMBER AS A CLUE
0171++ 2A2D             ;*
0172++ 2A2D 3E 3F       ERR:	LD	A,'?'		;PRECEDE ERROR MESSAGE BY '?'
0173++ 2A2F CD A2 00    	CALL	OUT		;DISPLAY ON TERMINAL
0174++ 2A32 3A 35 42    	LD	A,(IFLAG)	;WERE WE TRYING TO 'INPUT' SOMETHING
0175++ 2A35 A7          	AND	A		;IF WE WERE, THEN ..
0176++ 2A36 C2 0B 2E    	JP	NZ,INERR	;SPECIAL MESSAGE + HANDLEING
0177++ 2A39             ;* NOW THAT WE HAVE FIGURED OUT WHAT'S GOING ON, LET HIM IN ON IT
0178++ 2A39 CD AD 0E    	CALL	PMSG		;PRINT ERROR MESSAGE
0179++ 2A3C 21 C5 34    	LD	HL,EM		;FOLLOWED BY..
0180++ 2A3F             ;* PRINT MESSAGE FOLLOWED BY LINE NUMBER (ALSO USED BY 'STOP IN LINE XXXX')
0181++ 2A3F CD AD 0E    PERR:	CALL	PMSG		;THE ' ERROR ' PART
0182++ 2A42 3A 34 42    	LD	A,(RFLAG)	;WERE WE RUNNING..
0183++ 2A45 A7          	AND	A		;IF NOT,
0184++ 2A46 CA 61 2A    	JP	Z,INLF		;THEN THATS ALL WE HAVE TO DO
0185++ 2A49             ;* DISPLAY LINE NUMBER OF RUNNING PROGRAM
0186++ 2A49 21 97 34    	LD	HL,INL		;ADDRESS OF 'IN LINE ' MESSAGE
0187++ 2A4C CD AD 0E    	CALL	PMSG		;DISPLAY FOR HIM
0188++ 2A4F             ;* FIND START OF OUR LINE, AND DISPLAY LINE NUMBER
0189++ 2A4F 1B          FSOL:	DEC	DE		;BACK UP IN SOURCE
0190++ 2A50 7A          	LD	A,D		;GET HIGH BYTE OF ADDRESS
0191++ 2A51 FE 46       	CP	TEXT & $FF00/ $100		;TEST FOR BEYOND BEGINNING
0192++ 2A53 DA 5C 2A    	JP	C,STLIN		;AT START OF LINE
0193++ 2A56 1A          	LD	A,(DE)		;GET CHARACTER FROM BUFER
0194++ 2A57 FE 0D       	CP	$0D		;TEST FOR CARRIAGE RETURN
0195++ 2A59 C2 4F 2A    	JP	NZ,FSOL		;IF NOT, KEEP LOOKING
0196++ 2A5C 13          STLIN:	INC	DE		;ADVANCE IN SOURCE
0197++ 2A5D EB          	EX	DE,HL		;SWAP TO H-L FOR PNUM
0198++ 2A5E CD 52 2B    	CALL	PNUM		;PRINT AND BUFFER LINE NUMBER
0199++ 2A61             ;* WAIT FOR CONSOLE INPUT, ON A NEW LINE
0200++ 2A61 CD C0 27    INLF:	CALL	NL		;ADVANCE A LINE ON HIS TERMINAL
0201++ 2A64 CD E7 2B    	CALL	RESET		;RESET DATA POINTER AND CONTROL-STACK
0202++ 2A67 C3 D4 29    	JP	INIT		;GET NEXT COMMAND
0203++ 2A6A             ;*
0204++ 2A6A             ;* SUBROUTINE TEST FOR VALID ASCII DIGIT (0-9), RETURNS WITH C=1 IF NOT
0205++ 2A6A             ;*
0206++ 2A6A FE 30       NUM:	CP	'0'		;TEST FOR < '0'
0207++ 2A6C D8          	RET	C		;IF SO, BAD DIGIT
0208++ 2A6D FE 3A       	CP	$3A		;TEST FOR >'9'
0209++ 2A6F 3F          	CCF			;INVERT LOGIC, C=1 IF BAD
0210++ 2A70 C9          	RET
0211++ 2A71             ;*
0212++ 2A71             ;****************************************************************
0213++ 2A71             ;*                    TEXT EDITING ROUTINES
0214++ 2A71             ;****************************************************************
0215++ 2A71             ;*
0216++ 2A71             ;* SUBROUTINE TO GET AND EDIT COMMAND LINE FROM TERMINAL
0217++ 2A71             ;*
0218++ 2A71 CD C0 27    BADLN:	CALL	NL		;ADVANCE TO NEW LINE
0219++ 2A74             GLINE:
0220++ 2A74 CD B3 27    	CALL	MONGETLN
0221++ 2A77 CD C0 27    	CALL	NL	
0222++ 2A7A E5          	PUSH	HL
0223++ 2A7B D1          	POP	DE
0224++ 2A7C D5          	PUSH	DE		;SAVE BUFFER ADDRESS
0225++ 2A7D DD 21 00 40 	LD	IX,BUFF
0226++ 2A81 1A          MOVL:	LD	A,(DE)		;GET CHARACTER FROM NEW LINE
0227++ 2A82 77          	LD	(HL),A		;SAVE IN OLD LINE BUFFER
0228++ 2A83 DD 77 00    	LD	(IX),A
0229++ 2A86 23          	INC	HL		;POINT TO NEXT
0230++ 2A87 13          	INC	DE		;POINT TO NEXT
0231++ 2A88 DD 23       	INC	IX
0232++ 2A8A             ;	CP	$0D		;TEST FOR END OF LINE
0233++ 2A8A FE 00       	CP	$00		;TEST FOR END OF LINE
0234++ 2A8C C2 81 2A    	JP	NZ,MOVL		;IF NOT, KEEP MOVEING
0235++ 2A8F 2B          	DEC	HL
0236++ 2A90 DD 2B       	DEC	IX	
0237++ 2A92 3E 0D       	LD	A,$0D
0238++ 2A94 77          	LD	(HL),A
0239++ 2A95 DD 77 00    	LD	(IX),A
0240++ 2A98 23          	INC	HL
0241++ 2A99 D1          	POP	DE		;RESTORE BUFFER ADDRESS
0242++ 2A9A 1A          	LD	A,(DE)		;AND FIRST CHARACTER FROM IT
0243++ 2A9B C9          	RET
0244++ 2A9C             ;*
0245++ 2A9C             ;* GET A PACKED-DECIMAL LINE NUMBER FROM THE COMMAND BUFFER
0246++ 2A9C             ;*
0247++ 2A9C 21 00 00    GETLN:	LD	HL,0		;START WITH ZERO
0248++ 2A9F 1A          ELOOP:	LD	A,(DE)		;GET DIGIT FROM COMMAND BUFFER
0249++ 2AA0 CD 6A 2A    	CALL	NUM		;TEST FOR ASCII DIGIT
0250++ 2AA3 D8          	RET	C		;IF NOT, STOP (WE HAVE IT)
0251++ 2AA4 13          	INC	DE		;ADVANCE TO NEXT BUFFER POSITION
0252++ 2AA5 29          	ADD	HL,HL		;MAKE ROOM FOR DIGIT IN BOTTOM..
0253++ 2AA6 29          	ADD	HL,HL		;OF THE RESULT, BY ..
0254++ 2AA7 29          	ADD	HL,HL		;ROTATING IT..
0255++ 2AA8 29          	ADD	HL,HL		;LEFT BY FOUR BITS
0256++ 2AA9 E6 0F       	AND	$0F		;CONVERT DIGIT TO BINARY
0257++ 2AAB B5          	OR	L		;INSERT INTO LOWER DIGITS OF RESULT
0258++ 2AAC 6F          	LD	L,A		;AND REPLACE BYTE IN RESULT WITH NEW VALUE
0259++ 2AAD C3 9F 2A    	JP	ELOOP		;GET NEXT DIGIT
0260++ 2AB0             ;*
0261++ 2AB0             ;* LINE EDITOR, EDITS PROGRAM SOURCE BY LINE NUMBER IN COMMAND BUFFER
0262++ 2AB0             ;*
0263++ 2AB0             EDIT:
0264++ 2AB0 CD 20 2B    	CALL	LINEF		;LOCATE LINE NUMBER IN SOURCE
0265++ 2AB3 E5          	PUSH	HL		;SAVE POINTER INTO TEXT
0266++ 2AB4 C2 C8 2A    	JP	NZ,INS		;IF NEW LINE, DON'T TRY TO DELETE
0267++ 2AB7             ;* DELETE LINE POINTED TO BY H-L
0268++ 2AB7 54          DEL:	LD	D,H		;COPY POINTER INTO
0269++ 2AB8 5D          	LD	E,L		;THE D-E PAIR FOR BACKWARDS COPY
0270++ 2AB9 3E 0D       	LD	A,$0D		;WE ARE LOOKING FOR A CARRIAGE RETURN
0271++ 2ABB             ;* FIND START OF NEXT LINE
0272++ 2ABB BE          DELNX:	CP	(HL)		;TEST FOR END OF LINE TO DELETE
0273++ 2ABC 23          	INC	HL		;POINT TO NEXT CHARACTER IN SOURCE
0274++ 2ABD C2 BB 2A    	JP	NZ,DELNX	;IF NOT END OF LINE, KEEP LOOKING
0275++ 2AC0             ;* COPY REST OF PROGRAM BACK OVER DELETED LINE
0276++ 2AC0 7E          DELLP:	LD	A,(HL)		;GET CHARACTER FROM NEXT LINE
0277++ 2AC1 12          	LD	(DE),A		;SAVE OVER DELETED LINE
0278++ 2AC2 13          	INC	DE		;POINT TO NEXT IN NEW LINE
0279++ 2AC3 23          	INC	HL		;POINT TO NEXT IN OLD LINE
0280++ 2AC4 3C          	INC	A		;TEST FOR END OF FILE
0281++ 2AC5 C2 C0 2A    	JP	NZ,DELLP	;IF NOT, KEEP DELETEING
0282++ 2AC8             ;* INSERT LINE INTO TEXT
0283++ 2AC8             INS:
0284++ 2AC8 01 02 00    	LD	BC,2		;SET LENGTH TO 2 (PACKED DECIMAL NUMBERS ARE 2)
0285++ 2ACB 11 00 40    	LD	DE,BUFF		;POINT TO BUFFER (CONTAINING NEW LINE)
0286++ 2ACE             ;* CALCULATE LENGTH OF LINE
0287++ 2ACE CD 9C 2A    	CALL	GETLN		;REMOVE NUMBERS AS THEY ARE NOT STORED AS TEXT
0288++ 2AD1 0C          ILP:	INC	C		;INCREMENT LENGTH
0289++ 2AD2 1A          	LD	A,(DE)		;GET CHARACTER FROM NEW LINE (IN BUFFER)
0290++ 2AD3 13          	INC	DE		;POINT TO NEXT CHARACTER FROM NEW LINE
0291++ 2AD4 FE 0D       	CP	$0D		;TEST FOR END OF LINE
0292++ 2AD6 C2 D1 2A    	JP	NZ,ILP		;IF NOT, KEEP COUNTING
0293++ 2AD9 79          	LD	A,C		;GET LENGTH
0294++ 2ADA E1          	POP	HL		;RESTORE POSITION IN TEXT
0295++ 2ADB FE 03       	CP	3		;TEST FOR NULL LINE
0296++ 2ADD CA E3 29    	JP	Z,TOP		;IS SO, DON'T INSERT
0297++ 2AE0             ;* INSERT NEW LINE INTO TEXT
0298++ 2AE0 54          INLN:	LD	D,H		;SET D-E TO POINT TO
0299++ 2AE1 5D          	LD	E,L		;THE LINE POSITION
0300++ 2AE2 CD 97 2F    	CALL	GETEOF		;GET END OF FILE ADDRESS
0301++ 2AE5 23          	INC	HL		;ADVANCE TO FREE BYTE
0302++ 2AE6 C5          	PUSH	BC		;SAVE LENGTH
0303++ 2AE7 E5          	PUSH	HL		;STACK END OF FILE ADDRESS
0304++ 2AE8 09          	ADD	HL,BC		;ADD LENGTH
0305++ 2AE9 C1          	POP	BC		;GET END OF FILE ADDRESS
0306++ 2AEA 23          	INC	HL		;ADVANCE BECAUSE WE DECREMENT
0307++ 2AEB 2B          IL01:	DEC	HL		;REDUCE POINTER INTO NEW POSITION
0308++ 2AEC 0B          	DEC	BC		;REDUCE POINTER TO OLD POSITION
0309++ 2AED 0A          	LD	A,(BC)		;GET BYTE OF OLD DATA
0310++ 2AEE 77          	LD	(HL),A		;SAVE IN NEW POSITION
0311++ 2AEF 79          	LD	A,C		;GET LOW ADDRESS
0312++ 2AF0 BB          	CP	E		;TEST AGAINST WHERE WE ARE GOING
0313++ 2AF1 C2 EB 2A    	JP	NZ,IL01		;IF NOT, KEEP COPYING
0314++ 2AF4 78          	LD	A,B		;GET HIGH ADDRESS
0315++ 2AF5 BA          	CP	D		;TEST AGAINST DESTINATION
0316++ 2AF6 C2 EB 2A    	JP	NZ,IL01		;IF NOT SAME, KEEP COPYING
0317++ 2AF9 11 00 40    	LD	DE,BUFF		;GET ADDRESS OF NEW LINE
0318++ 2AFC CD 9C 2A    	CALL	GETLN		;OBTAIN NUMBERS
0319++ 2AFF 7C          	LD	A,H		;GET HIGH 2 DIGITS
0320++ 2B00 02          	LD	(BC),A		;SAVE IN NEW LINE
0321++ 2B01 03          	INC	BC		;POINT TO NEXT CHARACTER OF NEW LINE
0322++ 2B02 7D          	LD	A,L		;GET LOW DIGITS
0323++ 2B03 02          	LD	(BC),A		;SAVE IN NEW LINE
0324++ 2B04 03          	INC	BC		;ADVANCE TO NEXT CHARACTER IN NEW LINE
0325++ 2B05 E1          	POP	HL		;RESTORE LENGTH
0326++ 2B06 7D          	LD	A,L		;GET LENGTH
0327++ 2B07 C6 10       	ADD	A,$10		;ADD OFFSET TO MAKE UNIQUE
0328++ 2B09 02          	LD	(BC),A		;SAVE IN NEW LINE
0329++ 2B0A 03          	INC	BC		;POINT TO NEXT CHARACTER
0330++ 2B0B 1A          IL02:	LD	A,(DE)		;GET CHARACTER FROM NEW LINE IN BUFFER
0331++ 2B0C 02          	LD	(BC),A		;SAVE IN TEXT
0332++ 2B0D 03          	INC	BC		;POINT TO NEXT POSITION IN TEXT
0333++ 2B0E 13          	INC	DE		;ADVANCE IN BUFFER
0334++ 2B0F FE 0D       	CP	$0D		;TEST FOR END OF LINE
0335++ 2B11 C2 0B 2B    	JP	NZ,IL02		;IF NOT, KEEP LOOKING
0336++ 2B14             ;* WE ARE INSERTING OR REPLACEING A LINE, SINCE WE DON'T KNOW HOW MUCH
0337++ 2B14             ;* MEMORY IT WILL R.EQUIRE, WE MUST CLEAR THE ARRAYS, AS THEY FOLLOW THE
0338++ 2B14             ;* PROGRAM. WE DO NOT HAVE TO DO THIS WHEN DELETING LINES
0339++ 2B14 CD D5 2B    	CALL	CLRARY		;CLEAR ARRAYS AND RETURN
0340++ 2B17 C3 E3 29    	JP	TOP		;GO BACK FOR NEXT COMMAND
0341++ 2B1A             ;*
0342++ 2B1A             ;* LOCATE LINE IN TEXT, SYNTAX ERROR IF NOT LINE NUMBER
0343++ 2B1A             ;*
0344++ 2B1A CD 6A 2A    FNDLIN:	CALL	NUM		;IS IT A VALID NUMBER
0345++ 2B1D DA 29 2A    	JP	C,SYNT		;IF NOT, IT'S A INVALID
0346++ 2B20             ;*
0347++ 2B20             ;* FINDS LINE IN PROGRAM TEXT. RETURNS WITH Z FLAG SET IF LINE EXISTS
0348++ 2B20             ;* H-L POINTS TO START OF LINE. B-C CONTAINS LINE NUMBER OF ACTUAL
0349++ 2B20             ;* LINE FOUND. (IF LINE NOT FOUND, POINTS TO FIRST GREATER LINE NUMBER)
0350++ 2B20             ;*
0351++ 2B20 CD 9C 2A    LINEF:	CALL	GETLN		;GET LINE NUMBER FROM COMMAND BUFFER
0352++ 2B23 EB          	EX	DE,HL		;SWAP TO D-E
0353++ 2B24 21 00 46    	LD	HL,TEXT		;START AT TOP OF PROGRAM
0354++ 2B27 7E          TRY:	LD	A,(HL)		;GET FIRST CHARACTER FROM PROGRAM LINE
0355++ 2B28 FE FF       	CP	$FF		;TEST FOR END OF FILE
0356++ 2B2A CA 4F 2B    	JP	Z,EOF		;IF SO, WE DIDN'T FIND
0357++ 2B2D 23          	INC	HL		;ADVANCE POINTER TO LOW DIGITS
0358++ 2B2E BA          	CP	D		;TEST FOR HIGH DIGITS CORRECT
0359++ 2B2F DA 3A 2B    	JP	C,NEXTL		;IF LESS, FIND NEXT LINE
0360++ 2B32 C2 47 2B    	JP	NZ,NOTFND	;IF GREATER, LINE WASN'T FOUND
0361++ 2B35 7E          	LD	A,(HL)		;GET LOW DIGITS
0362++ 2B36 BB          	CP	E		;TEST LOW DIGITS
0363++ 2B37 D2 47 2B    	JP	NC,NOTFND	;IF LESS, LINE IS HERE OR DOSN'T EXIST
0364++ 2B3A             ;* ADVANCE TO NEXT LINE IN SOURCE
0365++ 2B3A 23          NEXTL:	INC	HL		;POINT TO LINE LENGTH
0366++ 2B3B 7E          	LD	A,(HL)		;GET LENGTH
0367++ 2B3C D6 11       	SUB	$11		;SUBTRACT OFFSET USED TO MAKE IT UNIQUE
0368++ 2B3E 85          	ADD	A,L		;ADD TO POINTER
0369++ 2B3F 6F          	LD	L,A		;AND REPLACE IN POINTER
0370++ 2B40 D2 27 2B    	JP	NC,TRY		;IF NO CARRY, THATS IT
0371++ 2B43 24          	INC	H		;BUMP HIGH ADDRESS
0372++ 2B44 C3 27 2B    	JP	TRY		;AND;TEST THIS LINE
0373++ 2B47             ;* LINE IS HERE OR BEFORE
0374++ 2B47 2B          NOTFND:	DEC	HL		;BACK UP TO DIGIT
0375++ 2B48 4F          	LD	C,A		;PLACE LOW ORDER DIGIT IN C
0376++ 2B49 46          	LD	B,(HL)		;PLACE HIGH ORDER DIGIT IN B
0377++ 2B4A BB          	CP	E		;TEST FOR LINE FOUND
0378++ 2B4B C0          	RET	NZ		;IF NOT SAME, RETURN INDICATING SO
0379++ 2B4C 78          	LD	A,B		;GET HIGH DIGIT
0380++ 2B4D BA          	CP	D		;INDICATE IF NUMBERS SAME
0381++ 2B4E C9          	RET
0382++ 2B4F             ;* LINE WAS GREATER THAN ALL LINES IN PROGRAM, INDICATE EOF REACHED
0383++ 2B4F 47          EOF:	LD	B,A		;RETURN HIGH LINE NUMBER
0384++ 2B50 A7          	AND	A		;INDICATE LINE DOSN'T EXIST
0385++ 2B51 C9          	RET
0386++ 2B52             ;*
0387++ 2B52             ;* PRINTS PACKED-DECIMAL LINE NUMBER ON TERMINAL, AS WELL AS PLACEING
0388++ 2B52             ;* IT AT THE START OF THE EDIT BUFFER
0389++ 2B52             ;*
0390++ 2B52             PNUM:
0391++ 2B52 D5          	PUSH	DE		;
0392++ 2B53 16 30       	LD	D,'0'		;
0393++ 2B55 CD 5D 2B    	CALL	HPOUT		;PRINT FIRST TWO DIGITS
0394++ 2B58 CD 5D 2B    	CALL 	HPOUT		;
0395++ 2B5B D1          	POP	DE
0396++ 2B5C C9          	RET
0397++ 2B5D             	
0398++ 2B5D 7E          HPOUT:	LD	A,(HL)		;GET CONTENTS OF MEMORY
0399++ 2B5E 23          	INC	HL		;AND POINT TO NEXT
0400++ 2B5F F5          	PUSH	AF		;SAVE FOR LATER
0401++ 2B60 0F          	RRCA			;ROTATE
0402++ 2B61 0F          	RRCA			;UPPER DIGIT
0403++ 2B62 0F          	RRCA			;INTO
0404++ 2B63 0F          	RRCA			;LOWER DIGIT
0405++ 2B64 CD 6C 2B    	CALL	POUT		;DISPLAY UPPER DIGIT
0406++ 2B67 F1          	POP	AF		;GET LOWER DIGIT BACK
0407++ 2B68 CD 6C 2B    	CALL	POUT
0408++ 2B6B C9          	RET
0409++ 2B6C             	
0410++ 2B6C             ;* DISPLAYS ONE DIGIT
0411++ 2B6C E6 0F       POUT:	AND	$0F		;REMOVE UPPER GARBAGE
0412++ 2B6E F6 30       	OR	$30		;CONVERT TO ASCII DIGIT
0413++ 2B70 BA          	CP	D		;
0414++ 2B71 C8          	RET	Z		;
0415++ 2B72 CD A2 00    	CALL	OUT		;DISPLAY DIGIT ON TERMINAL AND RETURN
0416++ 2B75 AF          	XOR	A		;
0417++ 2B76 57          	LD	D,A
0418++ 2B77 C9          	RET
0419++ 2B78             	
0420++ 2B78             
0421++ 2B78             	
0422++ 2B78             ;*
0423++ 2B78             ;******************************************************************
0424++ 2B78             ;*                   BASIC COMMAND HANDLERS
0425++ 2B78             ;******************************************************************
0426++ 2B78             ;*
0427++ 2B78             ;* IT'S A 'LIST' COMMAND, LETS GIVE HIM A PEEK AT THE SOURCE
0428++ 2B78             ;* ALSO PLACE LAST LINE LISTED IN BUFFER, INCASE HE WANTS TO EDIT IT
0429++ 2B78             ;*
0430++ 2B78 D5          LIST:	PUSH	DE		;SAVE PROGRAM POINTER
0431++ 2B79 21 00 46    	LD	HL,TEXT		;START AT THE BEGINNING OF THE PROGRAM
0432++ 2B7C 06 FF       	LD	B,255		;SET ENDING LINE BEYOND END OF TEXT
0433++ 2B7E 1A          	LD	A,(DE)		;GET CHARACTER OF OPERAND
0434++ 2B7F CD 6A 2A    	CALL	NUM		;TEST FOR A NUMBER
0435++ 2B82 DA 96 2B    	JP	C,GO		;IF NOT, LIST WHOLE THING
0436++ 2B85 CD 9C 2A    	CALL	GETLN		;GET LINE NUMBER
0437++ 2B88 E5          	PUSH	HL		;SAVE ON STACK
0438++ 2B89 13          	INC	DE		;POINT TO NEXT CHARACTER
0439++ 2B8A FE 2C       	CP	','		;TEST FOR ENDING NUMBER
0440++ 2B8C CC 20 2B    	CALL	Z,LINEF		;IF SO, GET ENDING NUMBER
0441++ 2B8F 23          	INC	HL		;ADVANCE PAST BEGINNING OF LINE
0442++ 2B90 D1          	POP	DE		;GET STARTING LINE NUMBER BACK
0443++ 2B91 E5          	PUSH	HL		;SAVE ENDING LINE
0444++ 2B92 CD 24 2B    	CALL	LINEF+4		;FIND STARTING LINE ADDRESS
0445++ 2B95 C1          	POP	BC		;GET ENDING ADDRESS BACK
0446++ 2B96             ;* LIST TEXT FROM STARTING LINE IN H-L TO ENDING LINE IN B-C
0447++ 2B96 7E          GO:	LD	A,(HL)		;GET CHARACTER FROM START OF LINE
0448++ 2B97 3C          	INC	A		;TEST FOR END OF FILE
0449++ 2B98 CA BA 2B    	JP	Z,LIRET		;IF SO, STOP LISTING
0450++ 2B9B CD 52 2B    	CALL	PNUM		;DISPLAY LINE NUMBER AND BUFFER IT
0451++ 2B9E 23          	INC	HL		;SKIP LENGTH BYTE, AS IT DOSN'T LOOK PRETTY
0452++ 2B9F 7E          PRINS:	LD	A,(HL)		;GET CHARACTER FROM LINE
0453++ 2BA0 12          	LD	(DE),A		;PLACE INTO BUFFER
0454++ 2BA1 13          	INC	DE		;ADVANCE IN BUFFER
0455++ 2BA2 CD A2 00    	CALL	OUT		;DISPLAY ON TERMINAL
0456++ 2BA5 23          	INC	HL		;ADVANCE POINTER IN PROGRAM
0457++ 2BA6 FE 0D       	CP	$0D		;TEST FOR END OF LINE
0458++ 2BA8 C2 9F 2B    	JP	NZ,PRINS	;IF NOT, KEEP PRINTING
0459++ 2BAB CD C0 27    	CALL	NL		;NEW LINE ON TERMINAL
0460++ 2BAE CD 53 31    	CALL	COMP		;TEST FOR LAST LINE LISTED
0461++ 2BB1 D2 BA 2B    	JP	NC,LIRET	;IF SO, STOP LISTING
0462++ 2BB4 CD 71 14    	CALL	breakx		;TEST FOR ABORT FROM TERMINAL
0463++ 2BB7 D2 96 2B    	JP	NC,GO		;KEEP LISTING IF NOT
0464++ 2BBA D1          LIRET:	POP	DE		;RESTORE PROGRAM POINTER
0465++ 2BBB C9          	RET
0466++ 2BBC             ;*
0467++ 2BBC             ;* CLEARS VARIABLES AND ARRAYS. (INITIALIZES THEM) AND INITIALIZES EDIT BUFFER
0468++ 2BBC             ;*
0469++ 2BBC 21 00 42    CLEAR:	LD	HL,VARS		;POINT TO VARIABLE SPACE
0470++ 2BBF 0E 34       	LD	C,52		;26 VARIABLE TIMES 2 BYTES/VARIABLE
0471++ 2BC1 36 00       CVLP:	LD	(HL),0		;CLEAR INTEGER VARAIBLES TO ZERO
0472++ 2BC3 23          	INC	HL		;ADVANCE TO NEXT BYTE OF VARIABLE SPACE
0473++ 2BC4 0D          	DEC	C		;REDUCE COUNT OF VARAIABLES LEFT
0474++ 2BC5 C2 C1 2B    	JP	NZ,CVLP		;KEEP GOING TILL ALL INTEGERS ARE ZERO'ED
0475++ 2BC8 3E 46       	LD	A,VARSEND & $FF00/$100	;ADDRESS OF END OF VARIABLE TABLE
0476++ 2BCA 01 0A 00    	LD	BC,10		;SKIP AHEAD 10 BYTES
0477++ 2BCD 09          	ADD	HL,BC		;SO THAT WE DON'T CLOBBER OUR FLAGS
0478++ 2BCE 36 FF       CVL1:	LD	(HL),255	;$FF IS NULL CHARACTER FOR CHAR. VARS
0479++ 2BD0 23          	INC	HL		;POINT TO NEXT BYTE IN CHAR. VAR. SPACE
0480++ 2BD1 BC          	CP	H		;TEST FOR COMPLETE (ALL SET TO NULL STRINGS)
0481++ 2BD2 C2 CE 2B    	JP	NZ,CVL1		;KEEP GOING TILL WE DO THEM ALL
0482++ 2BD5             ;* INITIALIZE ARRAYS, RESET ARRAY SPACE TO FIRST PAGE FOLLOWING PROGRAM
0483++ 2BD5 CD 97 2F    CLRARY:	CALL	GETEOF		;GET ADDRESS OF FIRST FREE PAGE+SET POINTER
0484++ 2BD8 32 FD 41    	LD	(ARYLOC),A	;STASH IN ARRAY TABLE POINTER
0485++ 2BDB 67          	LD	H,A		;PLACE IN H, SO WE CAN REFERENCE INDERECT
0486++ 2BDC 2E 34       	LD	L,52		;START AT END OF TABLE
0487++ 2BDE 22 3A 42    	LD	(LAST),HL	;INDICATE FREE SPACE FOR NEXT ARRAY
0488++ 2BE1 97          	SUB	A		;GET A ZERO
0489++ 2BE2 2D          CALS:	DEC	L		;BACK UP IN TABLE
0490++ 2BE3 77          	LD	(HL),A		;INITIALIZE TO INDICATE NO ARRAY
0491++ 2BE4 C2 E2 2B    	JP	NZ,CALS		;KEEP GOING TILL TABLE IS CLEARED
0492++ 2BE7             ;* RESET CONTROL STACK AND DATA POINTER
0493++ 2BE7 21 FA 41    RESET:	LD	HL,CS		;GET USER STACK POINTER
0494++ 2BEA 22 FB 41    	LD	(CSP),HL	;INITIALZE USER STACK POINTER
0495++ 2BED 21 00 00    	LD	HL,0		;GET A ZERO (NO DATA POINTER)
0496++ 2BF0 22 38 42    	LD	(DATA),HL	;INSURE NO DATA PRESENT
0497++ 2BF3 C9          	RET
0498++ 2BF4             ;*
0499++ 2BF4             ;* ** WE'VE GOTTEN A 'RUN' COMMAND, LETS START THE PROGRAM ROLLING **
0500++ 2BF4             ;*
0501++ 2BF4 3A 00 46    RUN:	LD	A,(TEXT)	;GET FIRST CHARACTER OF PROGRAM
0502++ 2BF7 21 8C 34    	LD	HL,NP		;AND ADDRESS OF 'NO PROGRAM' MESSAGE
0503++ 2BFA 3C          	INC	A		;TEST FOR EXISTANCE OF PROGRAM
0504++ 2BFB CA 2D 2A    	JP	Z,ERR		;IF NOT, POINT OUT HIS MISTAKE
0505++ 2BFE CD BC 2B    	CALL	CLEAR		;CLEAR VARIABLES AND ARRAYS
0506++ 2C01 11 00 46    	LD	DE,TEXT		;START INTERPRETING AT THE BEGINNING
0507++ 2C04 3E FF       RGON:	LD	A,255		;INDICATE THAT WE ARE RUNNING
0508++ 2C06 32 34 42    	LD	(RFLAG),A	;BY SETTING THIS FLAG
0509++ 2C09 13          RNEWL:	INC	DE		;SKIP PACKED DECIMAL LINE
0510++ 2C0A 13          	INC	DE		;NUMBERS, AND THE LENGTH BYTE,
0511++ 2C0B 13          	INC	DE		;AS THE COMMAND FINDER WON'T LIKE IT
0512++ 2C0C             ;* MAIN 'RUN' INTERPRETING LOOP
0513++ 2C0C 31 F7 40    RLOOP:	LD	SP,STACK	;REPAIR ANY DAMAGE
0514++ 2C0F CD 71 14    	CALL	breakx		;TEST FOR 'MAGIC' CONTROL-C CHARACTER
0515++ 2C12 DA 34 2C    	JP	C,STOP		;IF SO, FAKE A 'STOP' COMMAND
0516++ 2C15 21 AB 33    	LD	HL,PTAB-1	;POINT TO PROGRAM COMMAND TABLE
0517++ 2C18 CD FB 29    	CALL	CMD		;RUN PROGRAM CODE
0518++ 2C1B             ;* ADVANCE TO NEXT STATEMENT
0519++ 2C1B 1A          RNEXT:	LD	A,(DE)		;GET CHARACTER FROM SOURCE
0520++ 2C1C FE 22       	CP	$22		;TEST FOR A QUOTE
0521++ 2C1E CC 16 30    	CALL	Z,SKPQUO	;IF SO, SEARCH FOR NEXT ONE
0522++ 2C21 13          	INC	DE		;ADVANCE TO NEXT CHARACTER
0523++ 2C22 FE 3A       	CP	':'		;TEST FOR COLON (NEW STATEMENT)
0524++ 2C24 CA 0C 2C    	JP	Z,RLOOP		;IF SO, EXECUTE NEXT COMMAND
0525++ 2C27 FE 0D       	CP	$0D		;TEST FOR CARRIAGE RETURN
0526++ 2C29 C2 1B 2C    	JP	NZ,RNEXT	;IF NOT, KEEP LOOKING
0527++ 2C2C 1A          	LD	A,(DE)		;GET FIRST CHAR OF NEW LINE
0528++ 2C2D 3C          	INC	A		;TEST FOR $FF (END OF FILE)
0529++ 2C2E CA D4 29    	JP	Z,INIT		;IF SO, GO BACK TO COMMAND MODE
0530++ 2C31 C3 09 2C    	JP	RNEWL		;EXECUTE THIS LINE
0531++ 2C34             ;*
0532++ 2C34             ;* EITHER WE HAVE GOTTEN A 'STOP' COMMAND, OR THE OPERATOR PRESSED
0533++ 2C34             ;* CONTROL-C, EITHER WAY, PRINT THE MESSAGE AND EXIT
0534++ 2C34             ;*
0535++ 2C34 21 C0 34    STOP:	LD	HL,STMSG	;ADDRESS OF 'STOP' MESSAGE
0536++ 2C37 C3 3F 2A    	JP	PERR		;TREAT IT LIKE AN ERROR
0537++ 2C3A             ;* IT'S A 'THEN', FOLLOWING AN 'IF', LOOK FOR LINE NUMBER OR A STATEMENT
0538++ 2C3A CD 6A 2A    THEN:	CALL	NUM		;IS IT A NUMBER?
0539++ 2C3D D2 4B 2C    	JP	NC,GOTO		;IF SO, ITS A NUMBER TO 'GOTO'
0540++ 2C40 C3 0C 2C    	JP	RLOOP		;IF NOT, ITS A STATEMENT TO EXECUTE
0541++ 2C43             ;*
0542++ 2C43             ;* IT'S A 'GOSUB' SAVE RETURN ADDRESS, AND PRETEND IT'S 'GOTO'
0543++ 2C43             ;*
0544++ 2C43 CD C5 2C    GOSUB:	CALL	PUSHD		;SAVE SOURCE POSITION
0545++ 2C46 97          	SUB	A		;INDICATE GOSUB ENTRY
0546++ 2C47 CD B1 2C    	CALL	PUSHS		;SAVE ON USER STACK
0547++ 2C4A 1A          	LD	A,(DE)		;RESTORE OPERAND CHARACTER
0548++ 2C4B             ;*
0549++ 2C4B             ;* IT'S A 'GOTO' MAKE THE BIG JUMP
0550++ 2C4B             ;*
0551++ 2C4B FE 28       GOTO:	CP	'('		;TEST FOR COMPUTED GOTO
0552++ 2C4D C2 66 2C    	JP	NZ,NOON		;IF NO, NOT AN 'ON' STATEMENT
0553++ 2C50 CD 23 30    	CALL	EXPR		;GET VALUE OF INTERNAL EXPRESSION
0554++ 2C53 CD FB 2F    GLPO:	CALL	SKIP		;SKIP TO NEXT EXPRESSION
0555++ 2C56 FE 2C       	CP	','		;IF THERE IS NO MORE COMMA'S
0556++ 2C58 C2 29 2A    	JP	NZ,SYNT		;THEN WE RAN OUT OF OPERANDS
0557++ 2C5B 13          GLPD:	INC	DE		;SKIP THE COMMA
0558++ 2C5C 2D          	DEC	L		;REDUCE OUR COUNT
0559++ 2C5D F2 53 2C    	JP	P,GLPO		;IF IT'S STILL POSITIVE, KEEP SKIPPING
0560++ 2C60 1A          	LD	A,(DE)		;GET CHARACTER FROM SOURCE
0561++ 2C61 FE 20       	CP	' '		;TEST FOR BLANKS
0562++ 2C63 CA 5B 2C    	JP	Z,GLPD		;AND KEEP GOING TILL WE SKIP THEM
0563++ 2C66 D5          NOON:	PUSH	DE		;SAVE POSITION (IN CASE WE FAIL)
0564++ 2C67 CD 1A 2B    	CALL	FNDLIN		;FIND THE LINE HE WANTS
0565++ 2C6A D1          	POP	DE		;RESTORE OUR POSITION
0566++ 2C6B EB          	EX	DE,HL		;SWAP NEW POS INTO D-E
0567++ 2C6C CA 04 2C    	JP	Z,RGON		;IF SUCESS, GOTO NEW LINE
0568++ 2C6F EB          	EX	DE,HL		;SWAP BACK
0569++ 2C70             ;*
0570++ 2C70             ;* OH OH, LOOKS LIKE HE'S TRIED TO GOTO, GOSUB OR ORDER TO A LINE HE FORGOT
0571++ 2C70             ;* TO TYPE IN, TELL HIM ABOUT IT AND LET HIM TRY TO FIGURE IT OUT
0572++ 2C70             ;*
0573++ 2C70 21 80 34    BADLIN:	LD	HL,LIN		;ADDRESS OF 'LINE NUMBER' MESSAGE
0574++ 2C73 C3 2D 2A    	JP	ERR		;HANDLE LIKE ANY ERROR
0575++ 2C76             ;*
0576++ 2C76             ;* IT'S A 'RETURN', HOPE SOMEBODY DID A 'GOSUB' SOMEWHERE
0577++ 2C76             ;*
0578++ 2C76 CD BC 2C    RETURN:	CALL	POPS		;GET TYPE OF STACK ENTRY
0579++ 2C79 A7          	AND	A		;TEST FOR 'GOSUB' ENTRY
0580++ 2C7A CA CF 2C    	JP	Z,POPD		;IF SO, GET ADDRESS BACK AND RETURN
0581++ 2C7D             ;*
0582++ 2C7D             ;* HE SCREWED UP THE FOR/NEXT, GOSUB/RETURN NESTING
0583++ 2C7D             ;* LET HIM IN ON IT AND DIE WHILE WE CAN
0584++ 2C7D             ;*
0585++ 2C7D 21 78 34    NSTERR:	LD	HL,CSTK		;ADDRESS OF 'NESTING' MESSAGE
0586++ 2C80 C3 2D 2A    	JP	ERR		;HANDLE LIKE ANY ERROR
0587++ 2C83             ;*
0588++ 2C83             ;* IT'S A 'FOR' COMMAND, LETS THROW THIS THING FOR A LOOP
0589++ 2C83             ;*
0590++ 2C83 CD 25 2A    FOR:	CALL	VCHAR		;INSURE IT'S A VARIABLE
0591++ 2C86 F5          	PUSH	AF		;SAVE IT (IT'S THE LOOP INDEX VARIABLE)
0592++ 2C87 1B          	DEC	DE		;BACK UP POINT JUST BEFORE EXPRESSION
0593++ 2C88 7B          	LD	A,E		;GET LOW ADDRESS
0594++ 2C89 32 36 42    	LD	(P),A		;AND PLACE IN POSITION FLAG
0595++ 2C8C 1A          FINTO:	LD	A,(DE)		;GET CHARACTER FROM SOURCE
0596++ 2C8D FE 0D       	CP	$0D		;TEST FOR END OF LINE
0597++ 2C8F CA 29 2A    	JP	Z,SYNT		;IF SO, HE'S GOOFED
0598++ 2C92 13          	INC	DE		;SKIP TO NEXT
0599++ 2C93 FE 54       	CP	'T'		;TEST FOR A 'T'
0600++ 2C95 C2 8C 2C    	JP	NZ,FINTO	;IF NOT, WE ARN'T THERE YET
0601++ 2C98 1A          	LD	A,(DE)		;GET NEXT CHARACTER
0602++ 2C99 FE 4F       	CP	'O'		;IS IT 'TO'
0603++ 2C9B C2 8C 2C    	JP	NZ,FINTO	;NO, MUST BE VARIABLE 'T'
0604++ 2C9E D5          	PUSH	DE		;SAVE OUR POSITION
0605++ 2C9F 1B          	DEC	DE		;BACKUP TO THE 'T'
0606++ 2CA0 CD 2C 30    	CALL	DOEXP		;EVALUATE EXPRESSION
0607++ 2CA3 D1          	POP	DE		;RESTORE OUT POSITION
0608++ 2CA4 13          	INC	DE		;SKIP 'O'
0609++ 2CA5 CD 23 30    	CALL	EXPR		;GET LIMIT EXPRESSION
0610++ 2CA8 CD C5 2C    	CALL	PUSHD		;SAVE OUR POSITION ON STACK
0611++ 2CAB EB          	EX	DE,HL		;GET LIMIT VALUE
0612++ 2CAC CD C5 2C    	CALL	PUSHD		;SAVE ON STACK
0613++ 2CAF EB          	EX	DE,HL		;GET POSITION BACK
0614++ 2CB0 F1          	POP	AF		;GET INDEX VARIABLE NAME
0615++ 2CB1             ;*
0616++ 2CB1             ;* SAVES A SINGLE BYTE ENTRY ON THE USER (CONTROL) STACK
0617++ 2CB1             ;*
0618++ 2CB1 E5          PUSHS:	PUSH	HL		;SAVE H-L
0619++ 2CB2 2A FB 41    	LD	HL,(CSP)	;GET STACK POINTER
0620++ 2CB5 77          	LD	(HL),A		;SAVE BYTE ON STACK
0621++ 2CB6 2B          PSH1:	DEC	HL		;REDUCE POINTER
0622++ 2CB7 22 FB 41    PSH2:	LD	(CSP),HL	;RESAVE STACK POINTER
0623++ 2CBA E1          	POP	HL		;RESTORE H-L
0624++ 2CBB C9          	RET
0625++ 2CBC             ;*
0626++ 2CBC             ;* POP A SINGLE BYTE ENTRY FROM THE USER (CONTROL) STACK
0627++ 2CBC             ;*
0628++ 2CBC E5          POPS:	PUSH	HL		;SAVE H-L
0629++ 2CBD 2A FB 41    	LD	HL,(CSP)	;GET STACK POINTER
0630++ 2CC0 23          	INC	HL		;ADVANCE TO NEXT ENTRY
0631++ 2CC1 7E          	LD	A,(HL)		;GET BYTE BACK
0632++ 2CC2 C3 B7 2C    	JP	PSH2		;SAVE POINTER AND CONTINUE
0633++ 2CC5             ;*
0634++ 2CC5             ;* PUSHES A DOUBLE BYTE ENTRY ON THE USER (CONTROL) STACK
0635++ 2CC5             ;*
0636++ 2CC5 E5          PUSHD:	PUSH	HL		;SAVE H-L
0637++ 2CC6 2A FB 41    	LD	HL,(CSP)	;GET STACK POINTER
0638++ 2CC9 72          	LD	(HL),D		;SAVE HIGH BYTE
0639++ 2CCA 2B          	DEC	HL		;BACK UP
0640++ 2CCB 73          	LD	(HL),E		;SAVE LOW BYTE
0641++ 2CCC C3 B6 2C    	JP	PSH1		;SAVE POINTER AND CONTINUE
0642++ 2CCF             ;*
0643++ 2CCF             ;* POPS A DOUBLE BYTE ENTRY FROM THE USER STACK
0644++ 2CCF             ;*
0645++ 2CCF E5          POPD:	PUSH	HL		;SAVE H-L
0646++ 2CD0 2A FB 41    	LD	HL,(CSP)	;GET STACK POINTER
0647++ 2CD3 23          	INC	HL		;ADVANCE TO LAST ENTRY
0648++ 2CD4 5E          	LD	E,(HL)		;GET LOW BYTE
0649++ 2CD5 23          	INC	HL		;ADVANCE TO HIGH BYTE
0650++ 2CD6 56          	LD	D,(HL)		;GET HIGH BYTE
0651++ 2CD7 C3 B7 2C    	JP	PSH2		;SAVE AND CONTINUE
0652++ 2CDA             ;*
0653++ 2CDA             ;* LET COMMAND, EVALUATE EXPRESSION
0654++ 2CDA             ;*
0655++ 2CDA CD 23 30    LET:	CALL	EXPR		;EVALUATE EXPRESSION
0656++ 2CDD 3A 37 42    	LD	A,(EFLAG)	;DID HE MAKE AN ASSIGNMENT?
0657++ 2CE0 A7          	AND	A		;IF NOT..
0658++ 2CE1 CA 29 2A    	JP	Z,SYNT		;HE'S MADE ANOTHER MISTAKE
0659++ 2CE4 97          	SUB	A		;RESET THE FLAG
0660++ 2CE5 32 37 42    	LD	(EFLAG),A	;SO WE KNOW WHEN HE SCREW'S UP AGAIN
0661++ 2CE8 C9          	RET
0662++ 2CE9             ;*
0663++ 2CE9             ;* IT'S A NEXT COMMAND,;TEST INDEX AGAINST LIMIT, AND LOOP IF NEEDED
0664++ 2CE9             ;*
0665++ 2CE9 CD 25 2A    NEXT:	CALL	VCHAR		;TEST FOR VALID VARIABLE
0666++ 2CEC 47          	LD	B,A		;STASH IN B FOR SAFEKEEPING
0667++ 2CED 2A FB 41    	LD	HL,(CSP)	;SAVE CONTROL STACK POINTER..
0668++ 2CF0 22 3C 42    	LD	(TEMPBAS),HL	;IN CASE WE NEED TO LOOP AGAIN
0669++ 2CF3 CD BC 2C    	CALL	POPS		;GET VARIABLE NAME FROM STACK
0670++ 2CF6 B8          	CP	B		;TEST FOR WHAT HE GAVE US
0671++ 2CF7 C2 7D 2C    	JP	NZ,NSTERR	;IF NOT, HE'S SCREWED UP THE NESTING
0672++ 2CFA CD D3 2E    	CALL	LOOK		;GET VARIABLE VALUE
0673++ 2CFD D5          	PUSH	DE		;SAVE POSITION
0674++ 2CFE CD CF 2C    	CALL	POPD		;GET LIMIT FROM STACK
0675++ 2D01 42          	LD	B,D		;GET LIMIT
0676++ 2D02 4B          	LD	C,E		;INTO B-C SO WE CAN 'COMP'
0677++ 2D03 CD 53 31    	CALL	COMP		;TEST IF INDEX >= LIMIT
0678++ 2D06 D2 19 2D    	JP	NC,NOMORE	;IF SO, DON'T LOOP ANYMORE
0679++ 2D09 D1          	POP	DE		;GET POSITION BACK
0680++ 2D0A 23          	INC	HL		;INCREMENT LOOP INDEX
0681++ 2D0B 1A          	LD	A,(DE)		;GET VARIABLE NAME BACK
0682++ 2D0C CD C1 2E    	CALL	STOR		;SAVE IT AWAY
0683++ 2D0F CD CF 2C    	CALL	POPD		;GET NEW POSITION
0684++ 2D12 2A 3C 42    	LD	HL,(TEMPBAS)	;GET CONTROL-STACK POINTER
0685++ 2D15 22 FB 41    	LD	(CSP),HL	;AND REPLACE IT (LEAVING STACK UNCHANGED)
0686++ 2D18 C9          	RET
0687++ 2D19             ;* WE HAVE HIT THE END OF A FOR NEXT LOOP
0688++ 2D19 CD CF 2C    NOMORE:	CALL	POPD		;CLEAN UP CONTROL STACK
0689++ 2D1C D1          	POP	DE		;GET PROGRAM COUNTER BACK
0690++ 2D1D             ;*
0691++ 2D1D             ;* REMARK, DO NOTHING, BUT RETURN, ALLOWING 'RNEXT' TO SKIP THE COMMAND
0692++ 2D1D             ;*
0693++ 2D1D C9          REM:	RET
0694++ 2D1E             ;*
0695++ 2D1E             ;* IT'S AN 'IF' STATEMENT. FIND OUT 'IF' WE DO IT OR NOT
0696++ 2D1E             ;*
0697++ 2D1E 1B          IF:	DEC	DE		;BACK UP IN SOURCE
0698++ 2D1F 7B          	LD	A,E		;GET LOW ADDRESS
0699++ 2D20 32 36 42    	LD	(P),A		;SAVE IN POSITION POINTER
0700++ 2D23 1A          FTHEN:	LD	A,(DE)		;GET CHARACTER FROM SOURCE
0701++ 2D24 FE 0D       	CP	$0D		;IF IT'S A CARRIAGE RETURN..
0702++ 2D26 CA 29 2A    	JP	Z,SYNT		;THEN HE DIDN'T TYPE IN A 'THEN'
0703++ 2D29 13          	INC	DE		;ADVANCE TO NEXT CHARACTER
0704++ 2D2A FE 54       	CP	'T'		;IS IT A 'T'?
0705++ 2D2C C2 23 2D    	JP	NZ,FTHEN	;IF NOT, IT AINT THE START OF 'THEN'
0706++ 2D2F 1A          	LD	A,(DE)		;GET NEXT CHARACTER
0707++ 2D30 FE 48       	CP	'H'		;TEST FOR NEXT CHARACTER OF 'THEN'
0708++ 2D32 C2 23 2D    	JP	NZ,FTHEN	;NO, MUST BE VARIABLE 'T' (OR HE CAN'T SPELL)
0709++ 2D35 1B          	DEC	DE		;BACK UP TO 'T'
0710++ 2D36 D5          	PUSH	DE		;SAVE POSITION IN SOURCE
0711++ 2D37 CD 2C 30    	CALL	DOEXP		;EVALUATE CONDITION EXPRESSION
0712++ 2D3A D1          	POP	DE		;GET POSITION BACK
0713++ 2D3B 7C          	LD	A,H		;GET RESULT AND;TEST.
0714++ 2D3C B5          	OR	L		;IT FOR ZERO (FALSE)
0715++ 2D3D C8          	RET	Z		;IF SO, SKIP THIS STATEMENT
0716++ 2D3E C3 0C 2C    	JP	RLOOP		;EXECUTE THE 'THEN'
0717++ 2D41             ;*
0718++ 2D41             ;* LONG IF, CONTROLS REMAINDER OF ENTIRE LINE
0719++ 2D41             ;*
0720++ 2D41 CD 1E 2D    LIF:	CALL	IF		;CALCULATE AND PROCESS IF TRUE
0721++ 2D44 13          LNXT:	INC	DE		;ADVANCE IN SOURCE
0722++ 2D45 1A          	LD	A,(DE)		;GET CHARACTER FROM SOURCE
0723++ 2D46 FE 0D       	CP	$0D		;TEST FOR END OF LINE
0724++ 2D48 C2 44 2D    	JP	NZ,LNXT		;KEEP LOOKING
0725++ 2D4B C9          	RET
0726++ 2D4C             ;*
0727++ 2D4C             ;* IT A 'PLOT' COMMAND, (HE'S PLOTTING AGAINST US)
0728++ 2D4C             ;*
0729++ 2D4C             PLOT:	
0730++ 2D4C CD 17 12    	CALL	chput_remove_cursor	;
0731++ 2D4F CD 23 30    	CALL	EXPR		;GET X COORDINATE
0732++ 2D52 DA 29 2A    	JP	C,SYNT		;IF CHARACTER, IT'S NO GOOD
0733++ 2D55 E5          	PUSH	HL		;SAVE X COORDINATE
0734++ 2D56 13          	INC	DE		;ADVANCE PAST ','
0735++ 2D57 CD 23 30    	CALL	EXPR		;GET Y COORDINATE	
0736++ 2D5A C1          	POP	BC		;GET X POSITION IN B-C
0737++ 2D5B 79          	LD	A,C
0738++ 2D5C 67          	LD	H,A
0739++ 2D5D CD A0 14    	CALL	posit		;POSITION THE CURSOR
0740++ 2D60             ;* LOOK FOR END OF LINE, OR OTHER OPERANDS
0741++ 2D60 CD FB 2F    	CALL	SKIP		;GET NEXT SEPERATOR
0742++ 2D63 FE 2C       	CP	','		;TEST FOR COMMA
0743++ 2D65 C0          	RET	NZ		;WE ARE DONE
0744++ 2D66 13          	INC	DE		;SKIP ','
0745++ 2D67             ;*
0746++ 2D67             ;* PRINT STATEMENT, LET'S OUTPUT SOMETHING SO HE WON'T GET UPSET
0747++ 2D67             ;* WHILE STAREING AT THE TUBE WONDERING IF WE DIED
0748++ 2D67             ;*
0749++ 2D67 CD 23 30    PRINT:	CALL	EXPR		;GET EXPRESSION TO PRINT
0750++ 2D6A D5          	PUSH	DE		;SAVE BASIC'S PROGRAM COUNTER
0751++ 2D6B D4 8C 2D    	CALL	NC,DECPRT	;IF NUMERIC, OUTPUT DECIMAL NUMBER
0752++ 2D6E D1          	POP	DE		;RESTORE BASIC'S PROGRAM COUNTER
0753++ 2D6F DC 7F 2D    	CALL	C,PV1		;IF CHARACTER, DISPLAY CHARACTER VALUE
0754++ 2D72 1A          	LD	A,(DE)		;GET CHARACTER FROM SOURCE
0755++ 2D73 FE 2C       	CP	','		;TEST FOR COMMA
0756++ 2D75 C2 C0 27    	JP	NZ,NL		;IF NOT, IT'S THE END
0757++ 2D78 CD EE 2F    	CALL	PARSE		;ADVANCE TO NEXT NON-BLANK
0758++ 2D7B C2 67 2D    	JP	NZ,PRINT	;PRINT NEXT EXPRESSION
0759++ 2D7E C9          	RET
0760++ 2D7F             ;* PRINT CHARACTER EXPRESSIONS
0761++ 2D7F 21 64 40    PV1:	LD	HL,XBF		;EXPRESSION IS IN EXTRA BUFFER
0762++ 2D82 7E          PZ:	LD	A,(HL)		;GET CHARACTER FROM EXPRESSION
0763++ 2D83 23          	INC	HL		;POINT TO NEXT
0764++ 2D84 A7          	AND	A		;TEST FOR END OF EXPRESSION
0765++ 2D85 F8          	RET	M		;IF SO, END IT NOW
0766++ 2D86 CD A2 00    	CALL	OUT		;PRINT CHARACTER
0767++ 2D89 C3 82 2D    	JP	PZ		;KEEP GOING TILL END
0768++ 2D8C             ;* RECURSIVE ROUTINE OUTPUTS NUMBER IN DECIMAL
0769++ 2D8C FE 28       DECPRT:	CP	'('		;TEST FOR SPECIAL CASE
0770++ 2D8E C4 1F 28    	CALL	NZ,SPACE	;IF NOT, PRECEDE WITH SPACE
0771++ 2D91 01 0A 00    DECP1:	LD	BC,10		;DIVIDE BY 10
0772++ 2D94 CD 17 31    	CALL	DODIV		;PERFORM DIVISION
0773++ 2D97 3E 30       	LD	A,$30		;TO CONVERT TO ASCII
0774++ 2D99 85          	ADD	A,L		;GET DIGIT
0775++ 2D9A F5          	PUSH	AF		;SAVE FOR OUTPUT
0776++ 2D9B EB          	EX	DE,HL		;SWAP, REMAINDER IS NOW IN HL
0777++ 2D9C 7C          	LD	A,H		;GET HIGH BYTE
0778++ 2D9D B5          	OR	L		;TEST FOR ZERO, (FINISHED)
0779++ 2D9E C4 91 2D    	CALL	NZ,DECP1	;IF NOT, GET NEXT VALUE
0780++ 2DA1 F1          	POP	AF		;GET DIGIT OFF STACK
0781++ 2DA2 C3 A2 00    	JP	OUT		;DISPLAY AND RETURN
0782++ 2DA5             ;*
0783++ 2DA5             ;* IT'S AN 'INPUT', LETS GIVE HIM A CHANCE TO DO SOME TYPING.. BUT
0784++ 2DA5             ;* KEEP AN EYE ON HIM, IN CASE HE TRY'S TO PUT SOMETHING OVER ON US
0785++ 2DA5             ;*
0786++ 2DA5 CD 68 33    INPUT:	CALL	CLBF		;CLEAR EXTRA TEXT BUFFER
0787++ 2DA8 3E 3F       	LD	A,'?'		;GET A QUESTION MARK.
0788++ 2DAA 32 64 40    	LD	(XBF),A		;TO USE AS THE DEFAULT PROMPT
0789++ 2DAD 1A          	LD	A,(DE)		;GET FIRST CHAR OF OPERAND
0790++ 2DAE FE 22       	CP	$22		;TEST FOR USER SUPPLIED PROMPT
0791++ 2DB0 C2 B9 2D    	JP	NZ,INP1		;IF NOT, DON'T CHANGE EXISTING ONE
0792++ 2DB3 CD 23 30    	CALL	EXPR		;EVALUATE USER SUPPLIED PROMPT
0793++ 2DB6 CD EE 2F    	CALL	PARSE		;SKIP TO NEXT NON-BLANK
0794++ 2DB9 CD 25 2A    INP1:	CALL	VCHAR		;TEST FOR VALID VARIABLE NAME
0795++ 2DBC D5          	PUSH	DE		;SAVE SOURCE POSITION
0796++ 2DBD 13          	INC	DE		;ADVANCE TO NEXT CHARACTER
0797++ 2DBE F5          	PUSH	AF		;SAVE VARIABLE NAME
0798++ 2DBF 1A          	LD	A,(DE)		;GET NEXT CHARACTER
0799++ 2DC0 FE 24       	CP	'$'		;TEST FOR CHARACTER INPUT
0800++ 2DC2 CA E6 2D    	JP	Z,GCHR		;IF SO, GET CHARACTER DATA
0801++ 2DC5 21 00 00    	LD	HL,0		;START WITH A ZERO
0802++ 2DC8 39          	ADD	HL,SP		;AND GET STACK POINTER. IN CASE WE BLOW UP
0803++ 2DC9 22 3C 42    	LD	(TEMPBAS),HL	;SAVE SO WE CAN GET IT BACK LATER
0804++ 2DCC CD 7F 2D    RETRY:	CALL	PV1		;DISPLAY USER PROMPT
0805++ 2DCF 97          	SUB	A		;GET A ZERO
0806++ 2DD0 32 35 42    	LD	(IFLAG),A	;AND CLEAR THE INPUT FLAG (IN CASE HE CTRL-C'S)
0807++ 2DD3 CD 74 2A    	CALL	GLINE		;GET A LINE FROM THE TERMINAL
0808++ 2DD6 32 35 42    	LD	(IFLAG),A	;SET IFLAG. (SO GET ERROR, WE CAN COME BACK)
0809++ 2DD9 CD 23 30    	CALL	EXPR		;EVALUATE EXPRESSION
0810++ 2DDC F1          	POP	AF		;RESTORE VARAIABLE NAME
0811++ 2DDD CD C1 2E    	CALL	STOR		;STASH VALUE IN VARIABLE
0812++ 2DE0 D1          	POP	DE		;RESTORE SOURCE POSITION
0813++ 2DE1 97          	SUB	A		;GET A ZERO
0814++ 2DE2 32 35 42    	LD	(IFLAG),A	;AND CLEAR IFLAG
0815++ 2DE5 C9          	RET
0816++ 2DE6             ;* CHARACTER INPUT
0817++ 2DE6 CD 7F 2D    GCHR:	CALL	PV1		;DISPLAY USER PROMPT
0818++ 2DE9 CD 74 2A    	CALL	GLINE		;GET A LINE OF INPUT
0819++ 2DEC F1          	POP	AF		;GET VARIABLE BACK
0820++ 2DED CD 8F 2E    	CALL	LTA		;GET THE TEXT VARIABLE'S ADDRESS
0821++ 2DF0 06 23       	LD	B,35		;LENGTH IS 35
0822++ 2DF2 1A          Z1:	LD	A,(DE)		;GET CHARACTER FROM INPUT BUFFER
0823++ 2DF3 FE 0D       	CP	$0D		;TEST FOR END OF BUFFER
0824++ 2DF5 CA 02 2E    	JP	Z,Z2		;IF SO, END THE LINE
0825++ 2DF8 05          	DEC	B		;TEST FOR END OF VARIABLE SPACE
0826++ 2DF9 CA 02 2E    	JP	Z,Z2		;IF SO, END THE LINE
0827++ 2DFC 77          	LD	(HL),A		;SAVE IN VARIABLE SPACE
0828++ 2DFD 23          	INC	HL		;NEXT CHARACTER IN VARIABLE
0829++ 2DFE 13          	INC	DE		;NEXT CHARACTER IN INPUT BUFFER
0830++ 2DFF C3 F2 2D    	JP	Z1		;COPY NEXT CHARACTER
0831++ 2E02 D1          Z2:	POP	DE		;RESTORE SOURCE POSITION
0832++ 2E03 36 FF       Z3:	LD	(HL),$FF	;PAD BUFFER WITH NULL CHARACTERS
0833++ 2E05 23          	INC	HL		;NEXT POSITION IN VARIABLE
0834++ 2E06 05          	DEC	B		;REDUCE COUNT TILL END
0835++ 2E07 F2 03 2E    	JP	P,Z3		;KEEP GOING TILL VARIABLE IS FILLED
0836++ 2E0A C9          	RET
0837++ 2E0B             ;*
0838++ 2E0B             ;* LOOK'S LIKE HE CAN'T EVEN ENTER A SIMPLE NUMBER, CLEAN UP ANY STACK
0839++ 2E0B             ;* HE MAY HAVE USED, AND LET HIM TAKE ANOTHER BLIND STAB AT THE KEYBOARD
0840++ 2E0B             ;*
0841++ 2E0B 21 65 34    INERR:	LD	HL,IERMS	;GET NASTY MESSAGE
0842++ 2E0E CD AD 0E    	CALL	PMSG		;GIVE HIM THE BAD NEWS
0843++ 2E11 2A 3C 42    	LD	HL,(TEMPBAS)	;GET HIS OLD STACK BACK
0844++ 2E14 F9          	LD	SP,HL		;RESET HIS STACK
0845++ 2E15 C3 CC 2D    	JP	RETRY		;LET HIM TRY AGAIN
0846++ 2E18             ;*
0847++ 2E18             ;* DIMENSION, HE WANTS SOME ARRAY SPACE.. I SUPPOSE WE SHOULD GIVE IT TO HIM
0848++ 2E18             ;*
0849++ 2E18 7B          DIM:	LD	A,E		;GET ADDRESS OF OUR POSITION
0850++ 2E19 32 36 42    	LD	(P),A		;SAVE IN POSITION POINTER
0851++ 2E1C 1A          DIM0:	LD	A,(DE)		;GET CHARACTER FROM SOURCE
0852++ 2E1D 13          	INC	DE		;ADVANCE TO NEXT
0853++ 2E1E FE 0D       	CP	$0D		;TEST FOR END OF LINE
0854++ 2E20 CA 29 2A    	JP	Z,SYNT		;IF SO, TELL HIM TO STRAIGHTEN UP
0855++ 2E23 FE 29       	CP	')'		;TEST FOR START OF ARRAY DIMENSION
0856++ 2E25 C2 1C 2E    	JP	NZ,DIM0		;IF NOT, KEEP LOOKING
0857++ 2E28 1B          	DEC	DE		;BACK UP FOR EXPRESSION
0858++ 2E29 D5          	PUSH	DE		;SAVE BASIC PROGRAM COUNTER
0859++ 2E2A CD 2C 30    	CALL	DOEXP		;EVALUATE ARRAY SIZE
0860++ 2E2D 23          	INC	HL		;ADD ONE ENTRY (ZERO ENTRY DOES EXIST)
0861++ 2E2E 29          	ADD	HL,HL		;DOUBLE BECAUSE THEY ARE 16 BIT'S
0862++ 2E2F 1B          	DEC	DE		;BACK UP TO NAME
0863++ 2E30 44          	LD	B,H		;COPY SIZE NEEDED
0864++ 2E31 4D          	LD	C,L		;INTO B AND C
0865++ 2E32 2A 3A 42    	LD	HL,(LAST)	;GET FREE ADDRESS
0866++ 2E35 E5          	PUSH	HL		;SAVE FOR TABLE
0867++ 2E36 36 00       DLOOP:	LD	(HL),0		;ZERO ARRAY BYTE
0868++ 2E38 23          	INC	HL		;ADVANCE TO NEXT
0869++ 2E39 0B          	DEC	BC		;REDUCE COUNT
0870++ 2E3A 78          	LD	A,B		;GET HIGH BYTE OF REMAINING TO DO
0871++ 2E3B B1          	OR	C		;TEST FOR NONE LEFT
0872++ 2E3C C2 36 2E    	JP	NZ,DLOOP	;IF NOT, KEEP ZEROING
0873++ 2E3F 22 3A 42    	LD	(LAST),HL	;SAVE NEXT FREE SPACE INDICATOR
0874++ 2E42 E1          	POP	HL		;GET ADDRESS OF ARRAY BACK
0875++ 2E43 1A          	LD	A,(DE)		;GET ARRAY NAME
0876++ 2E44 CD 57 2E    	CALL	TABENT		;GET TABLE ENTRY
0877++ 2E47 7C          	LD	A,H		;GET HIGH ADDRESS
0878++ 2E48 02          	LD	(BC),A		;PLACE IN TABLE
0879++ 2E49 03          	INC	BC		;ADVANCE IN TABLE
0880++ 2E4A 7D          	LD	A,L		;GET LOW ADDRESS
0881++ 2E4B 02          	LD	(BC),A		;PLACE IN TABLE
0882++ 2E4C D1          	POP	DE		;GET SOURCE POSITION BACK
0883++ 2E4D CD EE 2F    	CALL	PARSE		;ADVANCE TO NEXT NON-BLANK
0884++ 2E50 C8          	RET	Z
0885++ 2E51 FE 2C       	CP	','		;TEST FOR ANOTHER OPERAND
0886++ 2E53 CA 18 2E    	JP	Z,DIM		;IF SO, KEEP GOING
0887++ 2E56 97          	SUB	A		;CAUSE A SYNTAX ERROR BECAUSE WE ARE BAD
0888++ 2E57             ;*
0889++ 2E57             ;* LOCATES TABLE POSITION OF AN ARRAY
0890++ 2E57             ;*
0891++ 2E57 CD 25 2A    TABENT:	CALL	VCHAR		;INSURE IT'S OK
0892++ 2E5A D6 41       	SUB	'A'		;CONVERT TO BINARY
0893++ 2E5C 87          	ADD	A,A		;X 2 FOR TWO BYTE ENTRIES
0894++ 2E5D 4F          	LD	C,A		;SAVE IN C
0895++ 2E5E 3A FD 41    	LD	A,(ARYLOC)	;GET ARRAY PAGE
0896++ 2E61 47          	LD	B,A		;SAVE IN HIGH ZBYTE
0897++ 2E62 C9          	RET
0898++ 2E63             ;* LOOKS UP AN ARRAY VALUE
0899++ 2E63 CD 2C 30    ALOOK:	CALL	DOEXP		;CALCULATE INDEX VALUE
0900++ 2E66 1B          	DEC	DE		;BACK UP PAST '['
0901++ 2E67 1A          	LD	A,(DE)		;GET VARIABLE NAME
0902++ 2E68 CD 78 2E    	CALL	LOOKT		;FIND ADDRESS OF ENTRY
0903++ 2E6B 46          	LD	B,(HL)		;GET HIGH BYTE OF ENTRY
0904++ 2E6C 23          	INC	HL		;ADVANCE TO LOW BYTE
0905++ 2E6D 4E          	LD	C,(HL)		;GET LOW BYTE OF ARRAY ENTRY
0906++ 2E6E 60          	LD	H,B		;TRANSFER RESULT TO .
0907++ 2E6F 69          	LD	L,C		;H AND L WHERE THEY ARE EXPECTED
0908++ 2E70 1A          	LD	A,(DE)		;GET VARIABLE NAME BACK
0909++ 2E71 FE 40       	CP	'@'		;TEST FOR MAGIC 'PEEK' ARRAY
0910++ 2E73 C0          	RET	NZ		;IF NOT, WE ARE OK
0911++ 2E74 6C          	LD	L,H		;SET VALUE TO THAT OF FIRST BYTE
0912++ 2E75 26 00       	LD	H,0		;AND ELIMINATE HIGH BYTE
0913++ 2E77 C9          	RET
0914++ 2E78             ;*
0915++ 2E78             ;* LOCATES ADDRESS OF AN ARRAY ENTRY IN THE ARRAY TABLE. INDEX IN HL
0916++ 2E78             ;*
0917++ 2E78 FE 40       LOOKT:	CP	'@'		;TEST FOR SPECIAL CASE
0918++ 2E7A C8          	RET	Z		;IF SO, PEEK AT ADDRESS
0919++ 2E7B CD 57 2E    	CALL	TABENT		;LOCATE TABLE ENTRY
0920++ 2E7E D5          	PUSH	DE		;SAVE BASIC PROGRAM COUNTER
0921++ 2E7F 0A          	LD	A,(BC)		;GET FIRST BYTE
0922++ 2E80 57          	LD	D,A		;COPY TO HIGH BYTE
0923++ 2E81 03          	INC	BC		;ADVANCE TO NEXT
0924++ 2E82 0A          	LD	A,(BC)		;GET LOW BYTE
0925++ 2E83 5F          	LD	E,A		;COPY TO D
0926++ 2E84 29          	ADD	HL,HL		;X TWO FOR TWO BYTE ENTRIES
0927++ 2E85 19          	ADD	HL,DE		;ADD IN OFFSET FOR START OF ARRAY
0928++ 2E86 B2          	OR	D		;TEST FOR ADDRESS OF ZERO, = NOT DIMENSIONED
0929++ 2E87 D1          	POP	DE		;RESTORE PROGRAM COUNTER
0930++ 2E88 C0          	RET	NZ		;NOT A DIMENSION ERROR, GO BACK
0931++ 2E89             ;*
0932++ 2E89             ;* EITHER HE'S TRIED TO INDEX A NON-ARRAY VARIABLE, TRIED TO INDEX A CHARACTER
0933++ 2E89             ;* VARIABLE WITH A VALUE GREATER THEN 34, OR HE'S PLOTTED OUTSIDE OF THE SCREEN
0934++ 2E89             ;* NO MATTER WHAT HE'S DONE, GIVE HIM A NASTY MESSAGE SO HE WON'T DO IT AGAIN
0935++ 2E89             ;*
0936++ 2E89 21 AD 34    DIMERR:	LD	HL,OVM		;ADDRESS OF NASTY MESSAGE
0937++ 2E8C C3 2D 2A    	JP	ERR		;GIVE IT TO HIM
0938++ 2E8F             ;* LOCATES THE ADDRESS OF A CHARACTER (TEXT) VARIABLE
0939++ 2E8F D6 41       LTA:	SUB	$41		;REDUCE TO SIMPLE BINARY
0940++ 2E91 FE 1A       	CP	26		;TEST FOR VALID VARIABLE
0941++ 2E93 D2 29 2A    	JP	NC,SYNT		;IF NOT, GET MAD
0942++ 2E96 21 19 42    	LD	HL,VARS+25	;START OF CHARACTER VARIABLES (-37)
0943++ 2E99 01 25 00    	LD	BC,37		;LENGTH OF CHARACTER VARIABLES
0944++ 2E9C 09          V1:	ADD	HL,BC		;OFFSET INTO TABLE
0945++ 2E9D 3D          	DEC	A		;REDUCE VARIABLES WE HAVE TO GO
0946++ 2E9E F2 9C 2E    	JP	P,V1		;IF NOT FINISHED, KEEP OFFSETING
0947++ 2EA1 C9          	RET
0948++ 2EA2             ;*
0949++ 2EA2             ;* IT'S A 'USR' COMMAND, FIND OUT WHAT HE WANT'S, PASS CONTROL  TO
0950++ 2EA2             ;* HIS MACHINE LANGUAGE ROUTINE, AND GOD HELP HIM IF HE SCREW'S UP
0951++ 2EA2             ;* BECAUSE WE CAN'T DO ANYTHING FOR HIM UNTIL HE RETURNS
0952++ 2EA2             ;*
0953++ 2EA2 21 B7 2E    USR:	LD	HL,URET		;GET ON STACK (SO HE CAN 'RET' TO IT)
0954++ 2EA5 E5          	PUSH	HL		;SAVE IN MACHINE STACK
0955++ 2EA6 CD 23 30    	CALL	EXPR		;EVALUATE ADDRESS
0956++ 2EA9 E5          	PUSH	HL		;SAVE ON STACK (SO WE CAN 'RET' TO IT)
0957++ 2EAA 1A          	LD	A,(DE)		;GET NEXT CHARACTER
0958++ 2EAB FE 2C       	CP	','		;TEST FOR MORE PARAMETERS
0959++ 2EAD C2 B4 2E    	JP	NZ,CSAV		;IF NOT, DONT EVALUATE
0960++ 2EB0 13          	INC	DE		;SKIP THE ','
0961++ 2EB1 CD 23 30    	CALL	EXPR		;EVALUATE PARAMETER TO PASS
0962++ 2EB4             ;* WHEN 'PUSHD' RETURNS, IT WILL EFFECT A JUMP TO HIS CODE
0963++ 2EB4 C3 C5 2C    CSAV:	JP	PUSHD		;SAVE PROGRAM POSITION
0964++ 2EB7             ;* IF WE GET HERE, HE MADE IT BACK IN ONE PIECE
0965++ 2EB7 CD CF 2C    URET:	CALL	POPD		;GET PROGRAM COUNTER BACK
0966++ 2EBA 1A          	LD	A,(DE)		;GET CHARACTER FROM SOURCE
0967++ 2EBB FE 2C       	CP	','		;TEST FOR VARIABLE TO RECEIVE H-L
0968++ 2EBD C0          	RET	NZ		;IF NOT, WE ARE DONE
0969++ 2EBE CD EE 2F    	CALL	PARSE		;KEEP LOOKING
0970++ 2EC1             ;*
0971++ 2EC1             ;* STORES H-L INTO A INTEGER VARIABLE PASSED IN A
0972++ 2EC1             ;*
0973++ 2EC1 01 00 42    STOR:	LD	BC,VARS		;GET ADDRESS OF VARIABLE TABLE
0974++ 2EC4 D6 41       	SUB	$41		;CONVERT TO BINARY
0975++ 2EC6 FE 1A       	CP	26		;TEST FOR VALID VARIABLE NAME
0976++ 2EC8 D2 29 2A    	JP	NC,SYNT		;IF NOT, IT'S INVALID
0977++ 2ECB 87          	ADD	A,A		;DOUBLE BECAUSE THEY ARE 16 BIT ENTRIES
0978++ 2ECC 4F          	LD	C,A		;PLACE IN C, MAKING COMPLETE ADDRESS
0979++ 2ECD 7D          	LD	A,L		;GET HIGH VALUE TO SAVE
0980++ 2ECE 02          	LD	(BC),A		;SAVE IN VARIABLE
0981++ 2ECF 03          	INC	BC		;NEXT BYTE OF VARIABLE
0982++ 2ED0 7C          	LD	A,H		;GET LOW BYTE
0983++ 2ED1 02          	LD	(BC),A		;SAVE IN VARIABLE
0984++ 2ED2 C9          	RET
0985++ 2ED3             ;*
0986++ 2ED3             ;* RETERIVES CONTENTS OF A VARIABLE
0987++ 2ED3             ;*
0988++ 2ED3 01 00 42    LOOK:	LD	BC,VARS		;ADDRESS OF VARIABLES
0989++ 2ED6 D6 41       	SUB	$41		;CONVERT NAME TO BINARY
0990++ 2ED8 87          	ADD	A,A		;DOUBLE FOR 16 BIT ENTRIES
0991++ 2ED9 4F          	LD	C,A		;MAKE COMPLETE ADDRESS
0992++ 2EDA 0A          	LD	A,(BC)		;GET HIGH BYTE
0993++ 2EDB 6F          	LD	L,A		;PLACE IN H
0994++ 2EDC 03          	INC	BC		;NEXT BYTE OF VARIABLE
0995++ 2EDD 0A          	LD	A,(BC)		;GET LOW BYTE
0996++ 2EDE 67          	LD	H,A		;PLACE IN L
0997++ 2EDF C9          	RET
0998++ 2EE0             ;*
0999++ 2EE0             ;* IT'S AN 'ORDER', (HE THINKS HE KNOWS WHERE THERE IS SOME DATA)
1000++ 2EE0             ;*
1001++ 2EE0 D5          ORDER:	PUSH	DE		;SAVE OUR SOURCE POSITION
1002++ 2EE1 CD 1A 2B    	CALL	FNDLIN		;GET ADDRESS OF THE LINE HE WANTS
1003++ 2EE4 D1          	POP	DE		;RESTORE OUR POSITION
1004++ 2EE5 D5          	PUSH	DE		;AND RESAVE OUR POSITION
1005++ 2EE6 C2 70 2C    	JP	NZ,BADLIN	;IF IT DOSN'T EXIST, THEN FORGET IT
1006++ 2EE9 23          	INC	HL		;SKIP FIRST TWO DIGITS OF LINE NUMBER
1007++ 2EEA 23          	INC	HL		;SKIP LAST TWO DIGITS OF LINE NUMBER
1008++ 2EEB 23          	INC	HL		;SKIP LENGTH BYTE
1009++ 2EEC EB          	EX	DE,HL		;MOVE TO D-E
1010++ 2EED CD 70 2F    	CALL	VERDAT		;GET STATEMENT FROM LINE
1011++ 2EF0 22 38 42    	LD	(DATA),HL	;SAVE DATA POINTER
1012++ 2EF3 D1          	POP	DE		;RESTORE OUR LINE, (SO WE CAN TELL HIM)
1013++ 2EF4 C8          	RET	Z
1014++ 2EF5             ;*
1015++ 2EF5             ;* DATA ERROR... ATTEMPT TO READ FROM A LINE WITHOUT 'DATA' OR
1016++ 2EF5             ;* ATTEMPT TO READ THE WRONG DATA TYPE. LET HIM IN ON IT
1017++ 2EF5             ;*
1018++ 2EF5 21 A8 34    DERR:	LD	HL,DTXT		;ADDRESS OF 'DATA' MESSAGE
1019++ 2EF8 C3 2C 2A    	JP	SYNT+3		;DISPLAY IT
1020++ 2EFB             ;*
1021++ 2EFB             ;* IT'S A READ. (HE WANTS TO KNOW WHATS IN THAT DATA WE FOUND)
1022++ 2EFB             ;*
1023++ 2EFB CD 25 2A    READ:	CALL	VCHAR		;IS IT A VALID VARIABLE
1024++ 2EFE F5          	PUSH	AF		;SAVE VARIABLE NAME
1025++ 2EFF 13          	INC	DE		;ADVANCE TO NEXT CHARACTER
1026++ 2F00 1A          	LD	A,(DE)		;GET NEXT CHARACTER
1027++ 2F01 FE 24       	CP	'$'		;IS IT A CHARACTER VARIABLE?
1028++ 2F03 CA 13 2F    	JP	Z,CDAT		;IF SO, LOOK FOR CHARACTER DATA
1029++ 2F06             ;* NUMERIC DATA, FOR NUMERIC VARIABLE
1030++ 2F06 CD 39 2F    	CALL	GETDAT		;GET NUMERIC DATA
1031++ 2F09 DA F5 2E    	JP	C,DERR		;IF CHARACTER, IT A DATA TYPE ERROR
1032++ 2F0C F1          	POP	AF		;GET VARIABLE NAME BACK
1033++ 2F0D CD C1 2E    	CALL	STOR		;STASH VALUE IN IT
1034++ 2F10 C3 2D 2F    	JP	MORDAT		;SEE IF HE WANT'S MORE DATA
1035++ 2F13             ;* CHARACTER DATA, FOR CHARACTER VARIABLE
1036++ 2F13 13          CDAT:	INC	DE		;SKIP DOLLAR SIGN
1037++ 2F14 CD 39 2F    	CALL	GETDAT		;GET DATA
1038++ 2F17 D2 F5 2E    	JP	NC,DERR		;IF NUMERIC, IT'S BAD
1039++ 2F1A F1          	POP	AF		;GET VARIABLE NAME BACK
1040++ 2F1B CD 8F 2E    	CALL	LTA		;FIND IT'S ADDRESS
1041++ 2F1E 01 64 40    	LD	BC,XBF		;DATA IS IN EXTRA BUFFER
1042++ 2F21 D5          	PUSH	DE		;SAVE SOURCE POSITION
1043++ 2F22 1E 23       	LD	E,35		;MOVE 35 CHARACTERS
1044++ 2F24 0A          SL1:	LD	A,(BC)		;GET CHARACTER FROM BUFFER. (DATA)
1045++ 2F25 77          	LD	(HL),A		;STASH IT IN THE VARIABLE
1046++ 2F26 03          	INC	BC		;SKIP TO THE NEXT CHARACTER IN THE BUFFER
1047++ 2F27 23          	INC	HL		;SKIP TO THE NEXT POSITION IN VARIABLE
1048++ 2F28 1D          	DEC	E		;REDUCE COUNT OF HOW MANY TO MOVE
1049++ 2F29 C2 24 2F    	JP	NZ,SL1		;IF NOT FINISHED, KEEP COPYING
1050++ 2F2C D1          	POP	DE		;RESTORE SOURCE POSITION
1051++ 2F2D             ;* LOOK FOR MORE VARIABLES (OPERANDS) IN THE 'READ' STATEMENT
1052++ 2F2D CD EF 2F    MORDAT:	CALL	PARSE1		;FIND NEXT NON-BLANK
1053++ 2F30 FE 2C       	CP	','		;IF COMMA..
1054++ 2F32 C0          	RET	NZ		;IF NOT, WE HAVE ALL THERE IS
1055++ 2F33 CD EE 2F    	CALL	PARSE		;SKIP COMMA AND FIND VARIABLE NAME
1056++ 2F36 C3 FB 2E    	JP	READ		;GET MORE DATA FOR FOLLOWING VARIABLE
1057++ 2F39             ;* GETS DATA FROM THE DATA STATEMENTS, POINTED TO BY THE CURRENT READ POINTER
1058++ 2F39 2A 38 42    GETDAT:	LD	HL,(DATA)	;GET DATA POINTER
1059++ 2F3C 7C          	LD	A,H		;SEE IF IT IS ZERO.
1060++ 2F3D B5          	OR	L		;WHICH INDICATES THAT IT WASN'T INITIALIZED
1061++ 2F3E CA F5 2E    	JP	Z,DERR		;IF SO, IT'S A DATA ERROR
1062++ 2F41 D5          	PUSH	DE		;SAVE SOURCE POSIITION
1063++ 2F42 EB          	EX	DE,HL		;SWAP DATA POINTER TO D-E
1064++ 2F43 CD 23 30    	CALL	EXPR		;EVALUATE THE DATA EXPRESSION
1065++ 2F46 F5          	PUSH	AF		;SAVE THE CONDITION FLAGS
1066++ 2F47 1A          ENDAT:	LD	A,(DE)		;GET NEXT CHARACTER FROM THE SOURCE
1067++ 2F48 FE 2C       	CP	','		;TEST FOR MORE DATA
1068++ 2F4A CA 67 2F    	JP	Z,COMA		;IF SO, WE ARE OK
1069++ 2F4D FE 3A       	CP	':'		;TEST FOR END OF STATEMENT
1070++ 2F4F CA 5A 2F    	JP	Z,DAT1		;GO TO NEXT DATA STATEMENT
1071++ 2F52 13          	INC	DE		;ADVANCE ONE CHARACTER
1072++ 2F53 FE 0D       	CP	$0D		;CARRIAGE RETURN?
1073++ 2F55 C2 47 2F    	JP	NZ,ENDAT	;KEEP LOOKING IF NOT
1074++ 2F58             ;* HIT THE END OF A LINE, SKIP TO NEXT DATA STATEMENT
1075++ 2F58 13          	INC	DE		;SKIP FIRST TWO DIGITS
1076++ 2F59 13          	INC	DE		;SKIP SECOND TWO DIGITS
1077++ 2F5A 13          DAT1:	INC	DE		;SKIP LENGTH (OR ':' IF STMT)
1078++ 2F5B E5          	PUSH	HL		;SAVE H-L REG
1079++ 2F5C CD 70 2F    	CALL	VERDAT		;CHECK FOR DATA STATEMENT
1080++ 2F5F EB          	EX	DE,HL		;SWAP POINTER BACK TO D-E
1081++ 2F60 E1          	POP	HL		;RESTORE REGISTERS
1082++ 2F61 CA 68 2F    	JP	Z,GDEND		;RETURN, WITH NEW DATA POINTER
1083++ 2F64 11 FF FF    	LD	DE,$FFFF	;INDICATE NO MORE DATA STATEMENTS
1084++ 2F67 13          COMA:	INC	DE		;SKIP THE COMMA
1085++ 2F68 EB          GDEND:	EX	DE,HL		;SWAP DATA POINTER BACK TO H-L
1086++ 2F69 22 38 42    	LD	(DATA),HL	;SAVE IN POINTER
1087++ 2F6C EB          	EX	DE,HL		;SWAP VALUE BACK TO H-L
1088++ 2F6D F1          	POP	AF		;GET FLAGS BACK
1089++ 2F6E D1          	POP	DE		;GET SOURCE POSITION BACK
1090++ 2F6F C9          	RET
1091++ 2F70             ;*
1092++ 2F70             ;* VERIFY THAT COMMAND WAS 'DATA'
1093++ 2F70             ;*
1094++ 2F70 CD EF 2F    VERDAT:	CALL	PARSE1		;SKIP TO COMMAND
1095++ 2F73 EB          	EX	DE,HL		;SWAP TO H-L
1096++ 2F74 11 D0 33    	LD	DE,DATCMD	;POINT TO DATA COMMAND
1097++ 2F77 7B          VER1:	LD	A,E		;GET LOW ADDRESS
1098++ 2F78 FE D4       	CP	((DATCMD+4) &$FF);ARE WE AT END
1099++ 2F7A C8          	RET	Z
1100++ 2F7B 1A          	LD	A,(DE)		;GET CHR FROM TABLE
1101++ 2F7C 13          	INC	DE		;ADVANCE TO NEXT
1102++ 2F7D E6 7F       	AND	$7F		;INSURE IT'S CORRECT
1103++ 2F7F BE          	CP	(HL)		;DUZ IT MATCH?
1104++ 2F80 23          	INC	HL		;NEXT IN DATA COMMAND
1105++ 2F81 CA 77 2F    	JP	Z,VER1		;OK,;TEST NEXT
1106++ 2F84 C9          	RET
1107++ 2F85             ;*
1108++ 2F85             ;* HE WANT'S TO KNOW HOW BIG IT IS... LETS FIGURE IT OUT AND LET HIM IN ON IT
1109++ 2F85             ;*
1110++ 2F85 D5          SIZE:	PUSH	DE		;SAVE PROGRAM POINTER
1111++ 2F86 CD 97 2F    	CALL	GETEOF		;FIND THE END OF THE FILE
1112++ 2F89 01 00 BA    	LD	BC,0-TEXT	;GET THE (NEGATIVE) FILE START ADDRESS
1113++ 2F8C 09          	ADD	HL,BC		;SUBTRACT FILE START FROM FILE END
1114++ 2F8D CD 8C 2D    	CALL	DECPRT		;DISPLAY VALUE IN DECIMAL
1115++ 2F90 21 CC 34    	LD	HL,SIMSG	;GET ' BYTES' MESSAGE
1116++ 2F93 D1          	POP	DE		;RESTORE PROGRAM POINTER
1117++ 2F94 C3 AD 0E    	JP	PMSG		;TELL HIM WHAT IT IS
1118++ 2F97             ;* FINDS THE END OF THE FILE, HL=LAST BYTE OF PGM., A=FIRST FREE PAGE
1119++ 2F97 21 00 46    GETEOF:	LD	HL,TEXT		;START AT THE BEGINING
1120++ 2F9A 3E FF       	LD	A,255		;LOOKING FOR AN FF
1121++ 2F9C BE          GLPX:	CP	(HL)		;IS THIS IT?
1122++ 2F9D 23          	INC	HL		;ADVANCE TO NEXT
1123++ 2F9E C2 9C 2F    	JP	NZ,GLPX		;IF NOT IT, KEEP LOOKING
1124++ 2FA1 2B          	DEC	HL		;POINT BACK TO $FF
1125++ 2FA2 7C          	LD	A,H		;GET HIGH VALUE
1126++ 2FA3 3C          	INC	A		;ADVANCE TO NEXT PAGE
1127++ 2FA4 C9          	RET
1128++ 2FA5             ;*
1129++ 2FA5             ;* HE'S TRYING TO 'LOAD' SOMETHING, I WONDER IF HE HAS SOMETHING SAVED..
1130++ 2FA5             ;*
1131++ 2FA5 CD E1 00    LOAD:	CALL	TON		;TURN ON TAPE AND WAIT
1132++ 2FA8 CD E4 00    LOD1:	CALL	GETR		;GET A RECORD
1133++ 2FAB DA A8 2F    	JP	C,LOD1		;KEEP GOING TILL WE HAVE IT ALL
1134++ 2FAE CD E7 00    	CALL	TOFF		;SHUT TAPE OFF
1135++ 2FB1 C3 D1 29    	JP	RESV		;CLEAR VARIABLES AND GET A NEW COMMAND
1136++ 2FB4             ;*
1137++ 2FB4             ;* HE'S TRYING TO 'SAVE' SOMETHING..
1138++ 2FB4             ;*
1139++ 2FB4 D5          SAVE:	PUSH	DE		;SAVE PROGRAM POINTER
1140++ 2FB5 11 00 46    	LD	DE,TEXT		;GET ADDRESS OF TEXT
1141++ 2FB8 1A          	LD	A,(DE)		;GET FIRST BYTE
1142++ 2FB9 3C          	INC	A		;TEST FOR NO PROGRAM
1143++ 2FBA CA F4 2B    	JP	Z,RUN		;IF SO, RUN WILL ABORT WITH ERROR
1144++ 2FBD CD 97 2F    	CALL	GETEOF		;GET ENDING ADDRESS
1145++ 2FC0 CD ED 00    	CALL	TDUMP		;DUMP PROGRAM AND RETURN
1146++ 2FC3 D1          	POP	DE		;RESTORE PROGRAM POINTER
1147++ 2FC4 C9          	RET
1148++ 2FC5             ;*
1149++ 2FC5             ;*****************************************************************
1150++ 2FC5             ;*                 EXPRESSION EVALUATION CODE
1151++ 2FC5             ;*****************************************************************
1152++ 2FC5             ;*
1153++ 2FC5             ;* EVALUATES 16 BIT DECIMAL NUMBERS
1154++ 2FC5             ;*
1155++ 2FC5 01 01 00    EVAL:	LD	BC,1		;MULTIPLIER IS ONE
1156++ 2FC8 60          	LD	H,B		;INITIALIZE
1157++ 2FC9 68          	LD	L,B		;STARTING RESULT TO ZERO
1158++ 2FCA 1A          ETOP:	LD	A,(DE)		;GET DIGIT FROM SOURCE
1159++ 2FCB CD 6A 2A    	CALL	NUM		;TEST FOR INVALID DIGIT
1160++ 2FCE D8          	RET	C		;IF SO, WE ARE FINISHED
1161++ 2FCF E6 0F       	AND	$0F		;CONVERT TO BINARY
1162++ 2FD1             ;* ADD DIGIT TIMES MULTIPLIER IN B-C TO H-L
1163++ 2FD1 3D          ZLOOP:	DEC	A		;REDUCE BY ONE
1164++ 2FD2 FA D9 2F    	JP	M,ESP1		;EXIT WHEN EXAUSTED
1165++ 2FD5 09          	ADD	HL,BC		;ADD MULTIPLIER
1166++ 2FD6 C3 D1 2F    	JP	ZLOOP		;CONTINUE TILL DONE
1167++ 2FD9             ;* MULTIPLY MULTIPLIER (BC) BY 10
1168++ 2FD9 E5          ESP1:	PUSH	HL		;SAVE H-L
1169++ 2FDA 60          	LD	H,B		;GET B-C INTO
1170++ 2FDB 69          	LD	L,C		;H-L SO WE CAN USE 'DAD'
1171++ 2FDC 09          	ADD	HL,BC		;BC=BC*2
1172++ 2FDD 29          	ADD	HL,HL		;BC=BC*4
1173++ 2FDE 09          	ADD	HL,BC		;BC=BC*5
1174++ 2FDF 29          	ADD	HL,HL		;BC=BC*10
1175++ 2FE0 44          	LD	B,H		;SAVE BACK INTO
1176++ 2FE1 4D          	LD	C,L		;B-C REGISTER PAIR
1177++ 2FE2 E1          	POP	HL		;RESTORE H-L
1178++ 2FE3 1B          	DEC	DE		;REDUCE POINTER IN SOURCE
1179++ 2FE4 C3 CA 2F    	JP	ETOP		;EVALUATE NEXT CHARACTER
1180++ 2FE7             ;*
1181++ 2FE7             ;* SUBROUTINE;TESTS FOR VALID ASCII CHARACTERS
1182++ 2FE7             ;*
1183++ 2FE7 FE 41       CHAR:	CP	'A'		;TEST FOR < 'A'
1184++ 2FE9 D8          	RET	C		;RETURN SAYING IT'S BAD
1185++ 2FEA FE 5B       	CP	'['		;TEST FOR >'Z'
1186++ 2FEC 3F          	CCF			;INVERT LOGIC
1187++ 2FED C9          	RET
1188++ 2FEE             ;*
1189++ 2FEE             ;* PARSES FORWARD, SEARCHING FOR FIRST NON-BLANK CHARACTER
1190++ 2FEE             ;*
1191++ 2FEE 13          PARSE:	INC	DE		;ADVANCE IN SOURCE
1192++ 2FEF 1A          PARSE1:	LD	A,(DE)		;GET CHARACTER FROM SOURCE
1193++ 2FF0 FE 20       	CP	' '		;TEST FOR SPACE
1194++ 2FF2 CA EE 2F    	JP	Z,PARSE		;KEEP LOOKING
1195++ 2FF5 FE 3A       	CP	':'		;TEST FOR END OF STATEMENT
1196++ 2FF7 C8          	RET	Z		;IF SO, RETURN WITH Z SET
1197++ 2FF8 FE 0D       	CP	$0D		;TEST FOR END OF LINE
1198++ 2FFA C9          	RET
1199++ 2FFB             ;*
1200++ 2FFB             ;* SKIPS TO NEXT EXPRESSION OR COMMAND
1201++ 2FFB             ;*
1202++ 2FFB CD EF 2F    SKIP:	CALL	PARSE1		;ADVANCE TO NEXT NON-BLANK
1203++ 2FFE 1B          	DEC	DE		;BACK UP TO POSITION
1204++ 2FFF 7B          	LD	A,E		;GET LOW ORDER ADDRESS
1205++ 3000 32 36 42    	LD	(P),A		;SAVE IN POSITION BYTE
1206++ 3003             ;* LOOK FOR DELIMITER
1207++ 3003 13          SKIP1:	INC	DE		;ADVANCE TO NEXT
1208++ 3004 1A          	LD	A,(DE)		;GET CHARACTER
1209++ 3005 FE 3A       	CP	':'		;TEST FOR DELIMITER
1210++ 3007 C8          	RET	Z		;IF SO, RETURN
1211++ 3008 FE 2C       	CP	','		;TEST FOR DELIMITER
1212++ 300A C8          	RET	Z		;IF SO, RETURN
1213++ 300B FE 0D       	CP	$0D		;TEST FOR DELIMITER
1214++ 300D C8          	RET	Z		;IF SO, RETURN
1215++ 300E FE 22       	CP	$22		;TEST FOR QUOTE
1216++ 3010 CC 16 30    	CALL	Z,SKPQUO	;IF SO, ADVANCE TO NEXT QUOTE
1217++ 3013 C3 03 30    	JP	SKIP1		;KEEP LOOKING
1218++ 3016             ;* FIND NEXT QUOTE IN SOURCE
1219++ 3016 13          SKPQUO:	INC	DE		;ADVANCE TO NEXT CHARACTER IN SOURCE
1220++ 3017 1A          	LD	A,(DE)		;GET THE CHARACTER
1221++ 3018 FE 22       	CP	$22		;IS IT A QUOTE?
1222++ 301A C8          	RET	Z		;IF SO, WE FOUND IT
1223++ 301B FE 0D       	CP	$0D		;IF IT A CARRIAGE RETUEN
1224++ 301D C2 16 30    	JP	NZ,SKPQUO	;IF NOT, OK
1225++ 3020 C3 29 2A    	JP	SYNT		;UNMATCHED QUOTES WHILE PARSING
1226++ 3023             ;*
1227++ 3023             ;* EVALUATES AN EXPRESSION POINTED TO BY D-E. RETURN WITH CARRY SET
1228++ 3023             ;* INDICATES THAT EXPRESSION WAS A CHARACTER EXPRESSION
1229++ 3023             ;*
1230++ 3023 CD FB 2F    EXPR:	CALL	SKIP		;ADVANCE TO END OF EXPRESSION
1231++ 3026 D5          	PUSH	DE		;SAVE POINTER TO END
1232++ 3027 CD 2C 30    	CALL	DOEXP		;EVALUATE
1233++ 302A D1          	POP	DE		;RESTORE POINTER TO END OF EXPRESSION
1234++ 302B C9          	RET
1235++ 302C             ;* CALCULATES EXPRESSION BACKWARDS (LIKE APL)
1236++ 302C 1B          DOEXP:	DEC	DE		;BACK UP IN SOURCE
1237++ 302D CD 65 32    	CALL	FE		;GET CHARACTER FROM SOURCE
1238++ 3030 FE 24       	CP	'$'		;TEST FOR CHARACTER VARIABLE
1239++ 3032 CA 91 32    	JP	Z,CEXP		;IF SO, ITS A CHARACTER EXPRESSION
1240++ 3035 FE 22       	CP	$22		;TEST FOR QUOTE
1241++ 3037 CA 91 32    	JP	Z,CEXP		;IF SO, IT'S A CHARACTER EXRESSION
1242++ 303A 13          	INC	DE		;ADVANCE
1243++ 303B 3E 59       	LD	A,$59		;NULL OPERATOR TO START
1244++ 303D E5          EGO1:	PUSH	HL		;SAVE OLD VALUE
1245++ 303E F5          	PUSH	AF		;SAVE OPERATOR
1246++ 303F 1B          	DEC	DE		;BACK UP TO VALUE
1247++ 3040 CD 65 32    	CALL	FE		;GET CHARACTER FROM SOURCE
1248++ 3043 FE 29       	CP	')'		;TEST FOR BRACKET
1249++ 3045 CA A7 30    	JP	Z,BRKTS		;IF SO, RECURSE
1250++ 3048 FE 5D       	CP	']'		;TEST FOR ARRAY LOOKUP
1251++ 304A CA AD 30    	JP	Z,ARYL		;IF SO, LOOK UP ARRAY VALUE
1252++ 304D CD E7 2F    	CALL	CHAR		;TEST FOR VARAIABLE
1253++ 3050 D2 B7 30    	JP	NC,LOOKU	;IF SO, LOOK IT UP
1254++ 3053 FE 3F       	CP	'?'		;TEST FOR RANDOM NUMBER RETERIVAL
1255++ 3055 CA 72 32    	JP	Z,RANDR		;GET RANDOM VALUE
1256++ 3058 FE 23       	CP	'#'		;TEST FOR HEX CONSTANT
1257++ 305A CA 69 30    	JP	Z,HEXVL		;IF SO, GET HEV VALUE
1258++ 305D CD 6A 2A    	CALL	NUM		;TEST FOR A NUMBER
1259++ 3060 DA 29 2A    	JP	C,SYNT		;IF NOT, I DON'T KNOW WHAT HE'S DOING
1260++ 3063             ;* DECIMAL NUMBER
1261++ 3063 CD C5 2F    CALN:	CALL	EVAL		;EVALUATE DECIMAL NUMBER
1262++ 3066 C3 BB 30    	JP	OLOOK		;LOOK FOR OPERATOR
1263++ 3069             ;* HEX. NUMBER
1264++ 3069 1B          HEXVL:	DEC	DE		;BACK UP IN SOURCE
1265++ 306A 3A 36 42    	LD	A,(P)		;GET ENDING POSITION
1266++ 306D BB          	CP	E		;TEST FOR PASSED THE LIMIT
1267++ 306E CA 7F 30    	JP	Z,HEXGO		;IF SO, THATS IT
1268++ 3071 1A          	LD	A,(DE)		;GET CHARACTER FROM SOURCE
1269++ 3072 CD 6A 2A    	CALL	NUM		;TEST FOR VALID DIGIT
1270++ 3075 D2 69 30    	JP	NC,HEXVL	;KEEP GOING TILL WE GET TO START OF STRING
1271++ 3078 D6 41       	SUB	'A'		;TEST FOR VALID LETTER
1272++ 307A FE 06       	CP	6		;OF 'A' TO 'F'
1273++ 307C DA 69 30    	JP	C,HEXVL		;IF SO, KEEP LOOKING
1274++ 307F 21 00 00    HEXGO:	LD	HL,0		;START WITH A ZERO
1275++ 3082 44          	LD	B,H		;FLAG TO SEE IF ANY DIGITS
1276++ 3083 D5          	PUSH	DE		;SAVE POSITION IN SOURCE
1277++ 3084 13          GETHX:	INC	DE		;ADVANCE TO NEXT DIGIT OF HEX NUMBER
1278++ 3085 1A          	LD	A,(DE)		;GET DIGIT
1279++ 3086 FE 23       	CP	'#'		;TEST FOR END OF STRING
1280++ 3088 CA 9E 30    	JP	Z,HGON		;IF SO, WE ARE DONE
1281++ 308B 47          	LD	B,A		;SET FLAG SO WE KNOW WE GOT AT LEAST ONE DIGIT
1282++ 308C 29          	ADD	HL,HL		;SHIFT H-L
1283++ 308D 29          	ADD	HL,HL		;RIGHT IN ORDER
1284++ 308E 29          	ADD	HL,HL		;TO MAKE ROOM FOR
1285++ 308F 29          	ADD	HL,HL		;THE NEW DIGIT
1286++ 3090 D6 30       	SUB	'0'		;REDUCE TO BINARY
1287++ 3092 FE 0A       	CP	10		;TEST FOR FURTHER REDUCTION NEEDED
1288++ 3094 DA 99 30    	JP	C,HISG		;IF NOT, PROCESS
1289++ 3097 D6 07       	SUB	7		;CONVERT LETTER TO BINARY
1290++ 3099 B5          HISG:	OR	L		;ADD IN BOTTOM DIGIT OF RESULT
1291++ 309A 6F          	LD	L,A		;REPLACE IN RESULT
1292++ 309B C3 84 30    	JP	GETHX		;GET NEXT DIGIT
1293++ 309E D1          HGON:	POP	DE		;GET POSITION IN SOURCE BACK
1294++ 309F 78          	LD	A,B		;GET FLAG
1295++ 30A0 A7          	AND	A		;TEST FOR DIGIT'S PROCESSED
1296++ 30A1 C2 BB 30    	JP	NZ,OLOOK	;NO PROBLEM
1297++ 30A4 C3 29 2A    	JP	SYNT		;'#' WITH NO DIGITS... ERROR
1298++ 30A7             ;* A ')' HAS BEEN DETECTED
1299++ 30A7 CD 2C 30    BRKTS:	CALL	DOEXP		;RECURSE ON OURSELVES
1300++ 30AA C3 BA 30    	JP	DCLB		;CONTINUE WITH VALUE
1301++ 30AD             ;* LOOK UP AN ARRAY VALUE
1302++ 30AD F1          ARYL:	POP	AF		;GET OPERATOR BACK
1303++ 30AE F5          	PUSH	AF		;STASH OPERATOR
1304++ 30AF FE 3D       	CP	'='		;TEST FOR ASSIGNMENT
1305++ 30B1 C4 63 2E    	CALL	NZ,ALOOK	;IF NOT, GET VALUE
1306++ 30B4 C3 BA 30    	JP	DCLB		;CONTINUE WITH VALUE
1307++ 30B7             ;* GET VARIABLE CONTENTS
1308++ 30B7 CD D3 2E    LOOKU:	CALL	LOOK		;LOOK UP VALUE OF VARIABLE
1309++ 30BA 1B          DCLB:	DEC	DE		;BACK UP IN SOURCE
1310++ 30BB F1          OLOOK:	POP	AF		;GET OPERATOR BACK
1311++ 30BC C1          	POP	BC		;GET OLD VALUE BACK
1312++ 30BD             ;* 16 BIT ADDITION
1313++ 30BD FE 2B       	CP	'+'		;TEST FOR ADDITION
1314++ 30BF CA CE 30    	JP	Z,ADD		;IF SO, PERFORM ADD
1315++ 30C2             ;* SIXTEEN BIT SUBTRACTION
1316++ 30C2 FE 2D       	CP	'-'		;TEST FOR SUBTRACTION
1317++ 30C4 C2 D2 30    	JP	NZ,MULT		;NO, TRY MULTIPLICATION
1318++ 30C7 78          	LD	A,B		;GET B
1319++ 30C8 2F          	CPL			;COMPLEMENT
1320++ 30C9 47          	LD	B,A		;RESAVE
1321++ 30CA 79          	LD	A,C		;GET C
1322++ 30CB 2F          	CPL			;COMPLEMENT
1323++ 30CC 4F          	LD	C,A		;RESAVE
1324++ 30CD 03          	INC	BC		;ADD 1 GIVING TWO'S COMPLEMENT
1325++ 30CE 09          ADD:	ADD	HL,BC		;ADD TO NEW VALUE
1326++ 30CF C3 31 32    	JP	EGO		;CONTINUE
1327++ 30D2             ;* 16 BIT MULTIPLICATION
1328++ 30D2 FE 2A       MULT:	CP	'*'		;TEST FOR MULTIPLY
1329++ 30D4 C2 01 31    	JP	NZ,DIV		;NO, TRY DIVIDE
1330++ 30D7 78          	LD	A,B		;TEST OLD VALUE FOR ZERO
1331++ 30D8 B1          	OR	C		;AS IT IS A
1332++ 30D9 CA 2E 32    	JP	Z,EGZ		;SPECIAL CASE
1333++ 30DC CD E2 30    	CALL	DMULT		;PERFORM THE MULTIPLY
1334++ 30DF C3 31 32    	JP	EGO		;AND CONTINUE
1335++ 30E2             ;* MULTIPLY SUBROUTINE (ALSO USED BY RANDOM NUMBER GENERATOR)
1336++ 30E2 D5          DMULT:	PUSH	DE		;SAVE POSITION IN SOURCE
1337++ 30E3 11 00 00    	LD	DE,0		;START OUT WITH A ZERO
1338++ 30E6 A7          MUL1:	AND	A		;INSURE CARRY CLEAR
1339++ 30E7 78          	LD	A,B		;GET B
1340++ 30E8 1F          	RRA			;ROTATE
1341++ 30E9 47          	LD	B,A		;RESAVE
1342++ 30EA 79          	LD	A,C		;GET C
1343++ 30EB 1F          	RRA			;ROTATE WITH CARRY
1344++ 30EC 4F          	LD	C,A		;REPLACE
1345++ 30ED F5          	PUSH	AF		;SAVE FLAGS
1346++ 30EE B0          	OR	B		;TEST FOR B-C = ZER0
1347++ 30EF CA FD 30    	JP	Z,MEXIT		;IF SO, WE ARE DONE
1348++ 30F2 F1          	POP	AF		;GET FLAGS BACK
1349++ 30F3 D2 F9 30    	JP	NC,NOMAD	;NO ONE BIT, DON'T ADD
1350++ 30F6 EB          	EX	DE,HL		;SWAP SO WE CAN
1351++ 30F7 19          	ADD	HL,DE		;ADD TO D-E
1352++ 30F8 EB          	EX	DE,HL		;AND SWAP BACK
1353++ 30F9 29          NOMAD:	ADD	HL,HL		;SHIFT H-L RIGHT BY ONE BIT
1354++ 30FA C3 E6 30    	JP	MUL1		;KEEP GOING
1355++ 30FD 19          MEXIT:	ADD	HL,DE		;ADD RESULT
1356++ 30FE F1          	POP	AF		;CLEAN UP STACK
1357++ 30FF D1          	POP	DE		;RESTORE SOURCE POSITION
1358++ 3100 C9          	RET
1359++ 3101             ;* 16 BIT DIVISION
1360++ 3101 FE 25       DIV:	CP	'%'		;TEST FOR DIVIDE
1361++ 3103 C2 59 31    	JP	NZ,FLOR		;NO, TRY FLOR
1362++ 3106 78          	LD	A,B		;TEST FOR AN OLD
1363++ 3107 B1          	OR	C		;VALUE OF ZERO,
1364++ 3108 CA 4D 31    	JP	Z,DIVZE		;BECAUSE THAT IS  A BAD THING
1365++ 310B D5          	PUSH	DE		;SAVE SOURCE POSITION
1366++ 310C CD 17 31    	CALL	DODIV		;PERFORM DIVIDE OPERATION
1367++ 310F 22 22 42    	LD	(VARS+34),HL	;SET 'R' REMAINDER VARIABLE
1368++ 3112 EB          	EX	DE,HL		;PLACE RESULT IN H-L
1369++ 3113 D1          	POP	DE		;RESTORE SOURCE POSITION
1370++ 3114 C3 31 32    	JP	EGO		;AND CARRY ON
1371++ 3117             ;*
1372++ 3117             ;* PERFORMS 16 BIT(HL) BY 16 BIT(BC) DIVIDE, RESULT IN DE, REM IN HL
1373++ 3117             ;*
1374++ 3117 78          DODIV:	LD	A,B		;GET CONTENTS OV B
1375++ 3118 2F          	CPL			;INVERT
1376++ 3119 47          	LD	B,A		;REPLECE
1377++ 311A 79          	LD	A,C		;GET CONTENTS IN C
1378++ 311B 2F          	CPL			;INVERT
1379++ 311C 4F          	LD	C,A		;REPLACE
1380++ 311D 03          	INC	BC		;COMPLETE TWO COMPLEMENT OPERATION
1381++ 311E EB          	EX	DE,HL		;COPY HL TO DE, LOWER HALF OF 32 BIT VALUE
1382++ 311F 21 00 00    	LD	HL,0		;ZERO HIGHER HALF
1383++ 3122 CD 25 31    	CALL	DIVBYT		;PERFORM FIRST HALF
1384++ 3125 7A          DIVBYT:	LD	A,D		;GET UPPER HALF
1385++ 3126 53          	LD	D,E		;SAVE LOWER HALF
1386++ 3127 1E 08       	LD	E,8		;GET LOOP COUNT
1387++ 3129 29          DIVTOP:	ADD	HL,HL		;SHIFT LEFT
1388++ 312A DA 41 31    	JP	C,OVER1		;OVERFLOWED
1389++ 312D 87          	ADD	A,A		;SHIFT  RESULT
1390++ 312E D2 32 31    	JP	NC,SUBB		;IF NO CARRY, DON'T INC
1391++ 3131 23          	INC	HL		;ADVANCE UPPER VALUE
1392++ 3132 E5          SUBB:	PUSH	HL		;SAVE VALUE
1393++ 3133 09          	ADD	HL,BC		;SUBTRACT LOWER HALF OF FRACTION
1394++ 3134 DA 3B 31    	JP	C,OKKK		;IF WRAP PAST ZERO
1395++ 3137 E1          	POP	HL		;RESTORE VALUE
1396++ 3138 C3 47 31    	JP	NXLP		;FINISH LOOP
1397++ 313B 33          OKKK:	INC	SP		;FIX UP
1398++ 313C 33          	INC	SP		;STACK
1399++ 313D 3C          	INC	A		;ADVANCE RESULT
1400++ 313E C3 47 31    	JP	NXLP		;FINISH LOOP
1401++ 3141 8F          OVER1:	ADC	A,A		;SHIFT RESULT, +1 FOR CARRY
1402++ 3142 D2 46 31    	JP	NC,OVRSUB	;IF NO WRAP
1403++ 3145 23          	INC	HL		;INC. VALUE
1404++ 3146 09          OVRSUB:	ADD	HL,BC		;SUBTRACT LOWER
1405++ 3147 1D          NXLP:	DEC	E		;REDUCE LOOP COUNTER
1406++ 3148 C2 29 31    	JP	NZ,DIVTOP	;LOOP IF NOT FINISHED
1407++ 314B 5F          	LD	E,A		;LOWER BYTE OF RESULT
1408++ 314C C9          	RET
1409++ 314D             ;*
1410++ 314D             ;* HE SHOULD KNOW THAT HE CAN'T DIVIDE BY ZERO, BUT JUST IN CASE...
1411++ 314D             ;* WE WILL TELL HIM ANYWAY
1412++ 314D             ;*
1413++ 314D 21 56 34    DIVZE:	LD	HL,DER		;ADDRESS OF 'DIVIDE BYE ZERO MESSAGE'
1414++ 3150 C3 2D 2A    	JP	ERR		;HANDLE LIKE ANY OTHER ERROR
1415++ 3153             ;* COMPARES H-L TO B-C, Z=1 IF HL=BC, C=1 IF HL<BC
1416++ 3153 7C          COMP:	LD	A,H		;GET HIGH BYTE OF HL
1417++ 3154 B8          	CP	B		;COMPARE WITH HIGH BYTE OF BC
1418++ 3155 C0          	RET	NZ		;IF NOT SAME, LOWER BYTE CAN BE IGNORED
1419++ 3156 7D          	LD	A,L		;GET LOW BYTE OF HL
1420++ 3157 B9          	CP	C		;COMPARE WITH LOW BYTE OF BC
1421++ 3158 C9          	RET
1422++ 3159             ;* FLOOR, RETURNS THE LESSER OF THE TWO NUMBERS
1423++ 3159 FE 92       FLOR:	CP	$92		;IS IT FLOOR?
1424++ 315B C2 69 31    	JP	NZ,CEIL		;NO, TRY CEILING
1425++ 315E CD 53 31    	CALL	COMP		;COMPARE NEW TO OLD
1426++ 3161 DA 31 32    	JP	C,EGO		;IF LESS, WE ARE OK (RESULT IS ALREADY IN HL)
1427++ 3164 60          SWAP:	LD	H,B		;MAKE OLD NUMBER..
1428++ 3165 69          	LD	L,C		;INTO THE NEW NUMBER..
1429++ 3166 C3 31 32    	JP	EGO		;CONTINUE
1430++ 3169             ;* CEILING, RETURNS THE GREATER OF THE TWO NUMBERS
1431++ 3169 FE 2F       CEIL:	CP	'/'		;IS IT CEILING?
1432++ 316B C2 77 31    	JP	NZ,LAND		;NO, TRY LOGICAL AND
1433++ 316E CD 53 31    	CALL	COMP		;COMPARE NEW AND OLD
1434++ 3171 D2 31 32    	JP	NC,EGO		;IF GREATER, WE ARE OK (RESULT ALREADY IN HL)
1435++ 3174 C3 64 31    	JP	SWAP		;MAKE OLD NEW AND CONTINUE
1436++ 3177             ;* LOGICAL AND
1437++ 3177 FE 26       LAND:	CP	'&'		;IF IT LOGICAL AND ?
1438++ 3179 C2 84 31    	JP	NZ,LOR		;NO, TRY LOGICAL OR
1439++ 317C 78          	LD	A,B		;GET HIGH BYTE OF OLD
1440++ 317D A4          	AND	H		;AND WITH HIGH BYTE OF NEW
1441++ 317E 67          	LD	H,A		;AND REPLACE HIGH BYTE OF NEW
1442++ 317F 7D          	LD	A,L		;GET LOW BYTE OF OLD
1443++ 3180 A1          	AND	C		;AND WITH LOW BYTE OF NEW
1444++ 3181 C3 8E 31    	JP	CPYL		;CONTINUE
1445++ 3184             ;* LOGICAL OR
1446++ 3184 FE 7C       LOR:	CP	'|'		;TEST FOR LOGICAL OR
1447++ 3186 C2 92 31    	JP	NZ,GRTR		;NO, TRY GREATER THAN
1448++ 3189 7C          	LD	A,H		;GET HIGH BYTE OF NEW
1449++ 318A B0          	OR	B		;OR WITH HIGH BYTE OF OLD
1450++ 318B 67          	LD	H,A		;AND REPLACE HIGH BYTE OF NEW
1451++ 318C 7D          	LD	A,L		;GET LOW BYTE OF NEW
1452++ 318D B1          	OR	C		;OR WITH LOW BYTE OF OLD
1453++ 318E 6F          CPYL:	LD	L,A		;AND REPLACE LOW BYTE OF NEW
1454++ 318F C3 31 32    	JP	EGO		;CONTINUE
1455++ 3192             ;* GREATER THAN, RETURNS ONE OR ZERO
1456++ 3192 FE 3E       GRTR:	CP	'>'		;TEST FOR GREATER THAN
1457++ 3194 C2 A3 31    	JP	NZ,LETH		;IF NOT, TRY LESS THAN
1458++ 3197 CD 53 31    	CALL	COMP		;COMPARE OLD AND NEW
1459++ 319A CA 2E 32    	JP	Z,EGZ		;FALSE IF .EQUAL
1460++ 319D DA 2E 32    	JP	C,EGZ		;FALSE IF LESS THAN
1461++ 31A0 C3 28 32    	JP	EG1		;TRUE IF NOT LESS OR .EQUAL
1462++ 31A3             ;* LESS THAN, RETURNS ONE OR ZERO
1463++ 31A3 FE 3C       LETH:	CP	'<'		;IS IT LESS THAN?
1464++ 31A5 C2 B1 31    	JP	NZ,ENOP		;NO, TRY NO-OP OPERATOR
1465++ 31A8 CD 53 31    	CALL	COMP		;COMPARE OLD AND NEW
1466++ 31AB DA 28 32    	JP	C,EG1		;TRUE IF LESS
1467++ 31AE C3 2E 32    	JP	EGZ		;FALSE IF NOT LESS
1468++ 31B1             ;* NO-OP OPERATOR, RETURNS NEW VALUE ONLY
1469++ 31B1 FE 59       ENOP:	CP	$59		;IS IT NO-OP? ';'
1470++ 31B3 CA 31 32    	JP	Z,EGO		;IF SO, DON'T DO ANYTHING
1471++ 31B6             ;* ASSIGNMENT, SET A VARIABLE'S VALUE
1472++ 31B6 FE 3D       ASST:	CP	'='		;TEST FOR ASSIGNMENT
1473++ 31B8 C2 F3 31    	JP	NZ,EQUAL	;IF NOT, TRY .EQUALITY
1474++ 31BB 32 37 42    	LD	(EFLAG),A	;SET ASSIGNMENT FLAG
1475++ 31BE 13          	INC	DE		;BACK UP TO VARIABLE NAME
1476++ 31BF 1A          	LD	A,(DE)		;GET VARIABLE CHARACTER
1477++ 31C0 FE 5D       	CP	']'		;TEST FOR ARRAY STORAGE
1478++ 31C2 CA D9 31    	JP	Z,ASTOR		;IF SO, STORE INTO ARRAY
1479++ 31C5 60          	LD	H,B		;GET OLD VALUE
1480++ 31C6 69          	LD	L,C		;INTO H-L (WHERE STORE WANTS THEM)
1481++ 31C7 FE 3F       	CP	'?'		;TEST FOR SETTING RANDOM SEED
1482++ 31C9 CA D3 31    	JP	Z,SRSEED	;IF SO, SET THE SEED
1483++ 31CC CD C1 2E    	CALL	STOR		;STORE VALUE INTO VARIABLE
1484++ 31CF 1B          STRT:	DEC	DE		;STEP BACK FROM VARIABLE
1485++ 31D0 C3 31 32    	JP	EGO		;AND CONTINUE
1486++ 31D3             ;* SET THE RANDOM SEED
1487++ 31D3 22 FE 41    SRSEED:	LD	(SEED),HL	;SO WE CAN STORE IN SEED
1488++ 31D6 C3 CF 31    	JP	STRT		;AND CONTINUE
1489++ 31D9             ;* SET THE VALUE OF AN ARRAY ELEMENT
1490++ 31D9 E5          ASTOR:	PUSH	HL		;SAVE H-L
1491++ 31DA CD 2C 30    	CALL	DOEXP		;CALCULATE INDEX VALUE
1492++ 31DD 1B          	DEC	DE		;BACK UP PAST '['
1493++ 31DE 1A          	LD	A,(DE)		;GET ARRAY NAME
1494++ 31DF CD 78 2E    	CALL	LOOKT		;LOOK UP IT'S ADDRESS IN THE TABLE
1495++ 31E2 44          	LD	B,H		;GET ARRAY ADDRESS
1496++ 31E3 4D          	LD	C,L		;INTO B-C
1497++ 31E4 E1          	POP	HL		;RERSTORE H-L
1498++ 31E5 1A          	LD	A,(DE)		;GET ARRAY NAME BACK
1499++ 31E6 FE 40       	CP	'@'		;TEST FOR 'MAGIC', MEMORY REFERENCE
1500++ 31E8 CA EE 31    	JP	Z,STMEM		;IF SO, SET MEMORY LOCATION
1501++ 31EB 7C          	LD	A,H		;GET HIGH BYTE OF VALUE
1502++ 31EC 02          	LD	(BC),A		;STASH IN ARRAY
1503++ 31ED 03          	INC	BC		;POINT TO NEXT
1504++ 31EE 7D          STMEM:	LD	A,L		;GET LOW BYTE OF VALUE
1505++ 31EF 02          	LD	(BC),A		;STASH IN ARRAY
1506++ 31F0 C3 CF 31    	JP	STRT		;CONTINUE
1507++ 31F3             ;*;TEST FOR .EQUALITY.  ('==')
1508++ 31F3 D6 81       EQUAL:	SUB	$81		;IS A '=='?
1509++ 31F5 C2 01 32    	JP	NZ,GEQL		;IF NOT, TRY GREATER OR .EQUAL
1510++ 31F8 CD 53 31    	CALL	COMP		;COMPARE OLD AND NEW
1511++ 31FB CA 28 32    	JP	Z,EG1		;TRUE IF .EQUAL
1512++ 31FE C3 2E 32    	JP	EGZ		;FALSE IF NOT .EQUAL
1513++ 3201             ;* GREATER OR .EQUAL.  ('>=')
1514++ 3201 3D          GEQL:	DEC	A		;TEST FOR '>='?
1515++ 3202 C2 0E 32    	JP	NZ,LEQL		;NO, TRY LESS OR .EQUAL
1516++ 3205 CD 53 31    	CALL	COMP		;COMPARE OLD AND NEW
1517++ 3208 DA 2E 32    	JP	C,EGZ		;FALSE IF LESS THAN
1518++ 320B C3 28 32    	JP	EG1		;TRUE IF GREATER OR .EQUAL
1519++ 320E             ;* LESS OR .EQUAL.  ('<=')
1520++ 320E 3D          LEQL:	DEC	A		;TEST FOR '<='?
1521++ 320F C2 1E 32    	JP	NZ,NEQL		;IF NOT, TRY NOT .EQUAL
1522++ 3212 CD 53 31    	CALL	COMP		;COMPARE OLD AND NEW
1523++ 3215 CA 28 32    	JP	Z,EG1		;TRUE IF SAME
1524++ 3218 DA 28 32    	JP	C,EG1		;TRUE IF LESS THAN
1525++ 321B C3 2E 32    	JP	EGZ		;FALSE OTHERWISE
1526++ 321E             ;*;TEST FOR NOT .EQUAL.  ('-=')
1527++ 321E 3D          NEQL:	DEC	A		;IS IT '-='?
1528++ 321F C2 29 2A    	JP	NZ,SYNT		;BEATS ME WHAT IT IS!
1529++ 3222 CD 53 31    	CALL	COMP		;COMPARE OLD AND NEW
1530++ 3225 CA 2E 32    	JP	Z,EGZ		;IF SAME, FALSE
1531++ 3228             ;* RETURN RESULT OF ONE
1532++ 3228 21 01 00    EG1:	LD	HL,1		;SET RESULT TO ONE
1533++ 322B C3 31 32    	JP	EGO		;PASS ON RESULT
1534++ 322E             ;* RETURN RESULT OF ZERO
1535++ 322E 21 00 00    EGZ:	LD	HL,0		;SET RESULT TO ZERO
1536++ 3231             ;* END OF OPERATION, GET NEXT OPERATOR
1537++ 3231 CD 65 32    EGO:	CALL	FE		;GET NEXT CHARACTER
1538++ 3234 C8          	RET	Z		;IF WE PASS BEGINNING OF EXPRESSION, QUIT
1539++ 3235 FE 28       	CP	'('		;ARE WE RETURNING FROM A NEST?
1540++ 3237 C8          	RET	Z		;IF SO, BACK UP ONE LEVEL
1541++ 3238 FE 5B       	CP	'['		;FINISHED AN ARRAY INDEX EVALUATION?
1542++ 323A C8          	RET	Z		;RETURN TO MAIN EXPRESSION
1543++ 323B FE 3D       	CP	'='		;IF IT A MULTI-CHARACTER OPERATOR
1544++ 323D C2 3D 30    	JP	NZ,EGO1		;IF NOT, DON'T PRE-EVALUATE
1545++ 3240 1B          	DEC	DE		;BACK UP TO PRECEDING CHARACTER
1546++ 3241 1A          	LD	A,(DE)		;GET PRECEDING CHARACTER
1547++ 3242 FE 3D       	CP	'='		;IS IT '=='?
1548++ 3244 06 81       	LD	B,$81		;SET UNIQUE CODE
1549++ 3246 CA 61 32    	JP	Z,EGO2		;IF '==' THEN WE HAVE IT
1550++ 3249 04          	INC	B		;NEXT UNIQUE CODE
1551++ 324A FE 3E       	CP	'>'		;IS IT '>='?
1552++ 324C CA 61 32    	JP	Z,EGO2		;IF SO, WE HAVE IT
1553++ 324F 04          	INC	B		;NEXT UNIQUE CODE
1554++ 3250 FE 3C       	CP	'<'		;IS IT '<='?
1555++ 3252 CA 61 32    	JP	Z,EGO2		;IF SO, WE HAVE IT
1556++ 3255 04          	INC	B		;NEXT UNIQUE CODE
1557++ 3256 FE 2D       	CP	'-'		;IS IT '-='?
1558++ 3258 CA 61 32    	JP	Z,EGO2		;IF SO, WE HAVE IT
1559++ 325B 13          	INC	DE		;WASN'T A TWO CHARACTER OPERATOR. BACK UP
1560++ 325C 3E 3D       	LD	A,'='		;MUST HAVE BEEN A SIMPLE '='
1561++ 325E C3 3D 30    	JP	EGO1		;CONTINUE EVALUATING EXPRESSION
1562++ 3261 78          EGO2:	LD	A,B		;SET OPERATOR TO OUR UNIQUE CODE
1563++ 3262 C3 3D 30    	JP	EGO1		;AND CONTINUE EVALUATING EXPRESSION
1564++ 3265             ;* FINDS NEXT CHARACTER IN EXPRESSION, SETS Z FLAG IF WE PASS THE BEGINNING
1565++ 3265 3A 36 42    FE:	LD	A,(P)		;GET ADDRESS OF BEGINNING OF LINE
1566++ 3268 BB          	CP	E		;ARE WE THERE??
1567++ 3269 C8          	RET	Z		;IF SO, WE ARE FINISHED
1568++ 326A 1A          	LD	A,(DE)		;GET CHARACTER FROM SOURCE
1569++ 326B FE 20       	CP	' '		;IS A (USELESS) BLANK?
1570++ 326D C0          	RET	NZ		;IF NOT, WE ARE FINISHED
1571++ 326E 1B          	DEC	DE		;BACK UP ANOTHER CHARACTER
1572++ 326F C3 65 32    	JP	FE		;AND TRY AGAIN
1573++ 3272             ;* CALCULATE A PSEUDO-RANDOM VALUE
1574++ 3272 2A FE 41    RANDR:	LD	HL,(SEED)	;GET RANDOM SEED
1575++ 3275 7C          	LD	A,H		;GET HIGH BYTE OF SEED
1576++ 3276 E6 F7       	AND	$F7		;AND WITH HIGH MASK
1577++ 3278 F5          	PUSH	AF		;SAVE PARITY FLAG
1578++ 3279 7D          	LD	A,L		;GET LOW BYTE OF SEED
1579++ 327A E6 42       	AND	$42		;AND WITH LOW BYTE OF MASK
1580++ 327C F5          	PUSH	AF		;SAVE PARITY FLAG
1581++ 327D C1          	POP	BC		;GET FLAGS IN C
1582++ 327E 79          	LD	A,C		;COPY TO A
1583++ 327F C1          	POP	BC		;GET FIRST SET OF FLAGS IN C
1584++ 3280 A9          	XOR	C		;COMPUTE PARITY FOR ENTIRE WORD
1585++ 3281 0F          	RRCA			;MOVE COMPUTED
1586++ 3282 0F          	RRCA			;PARITY INTO
1587++ 3283 0F          	RRCA			;THE CARRY FLAG
1588++ 3284 3F          	CCF			;COMP, SO SHIFT IN 1 IF EVEN
1589++ 3285 7D          	LD	A,L		;GET LOW BYTE OF SEED
1590++ 3286 17          	RLA			;SHIFT IN CARRY, OUT HIGH BIT
1591++ 3287 6F          	LD	L,A		;RESAVE
1592++ 3288 7C          	LD	A,H		;GET HIGH BYTE OF SEED
1593++ 3289 17          	RLA			;SHIFT IN CARRY (HIGH BIT OF OLD LOWER)
1594++ 328A 67          	LD	H,A		;RESAVE
1595++ 328B 22 FE 41    	LD	(SEED),HL	;RESULT IS NEW SEED
1596++ 328E C3 BA 30    	JP	DCLB		;KEEP GOING
1597++ 3291             ;*
1598++ 3291             ;* EVALUATES A CHARACTER EXPRESSION
1599++ 3291             ;*
1600++ 3291 CD 68 33    CEXP:	CALL	CLBF		;CLEAR EXTRA BUFFER
1601++ 3294 13          	INC	DE		;SKIP TO END OF EXPRESSION
1602++ 3295 3E 2B       	LD	A,'+'		;TO BEGIN, CONCATINATE A NULL STRING
1603++ 3297 F5          CG1:	PUSH	AF		;STACK THE OPERATOR FOR LATER
1604++ 3298 CD 75 33    	CALL	PUSHB		;COPY NEW BUFFER INTO OLD BUFFER
1605++ 329B CD 68 33    	CALL	CLBF		;CLEAR THE NEW BUFFER
1606++ 329E 1B          	DEC	DE		;BACK UP IN SOURCE
1607++ 329F CD 65 32    	CALL	FE		;GET CHARACTER AND;TEST FOR END
1608++ 32A2 FE 22       	CP	$22		;TEST FOR QUOTE
1609++ 32A4 CA BC 32    	JP	Z,CQ		;IF SO, HANDLE QUOTED STRING
1610++ 32A7 FE 24       	CP	'$'		;TEST FOR CHARACTER VARIABLE
1611++ 32A9 C2 29 2A    	JP	NZ,SYNT		;IF NOT, IT'S NOT ANYTHING I RECOGNISE
1612++ 32AC 1B          CV:	DEC	DE		;BACK UP PAST DOLLAR SIGN
1613++ 32AD 1A          	LD	A,(DE)		;GET VARIABLE NAME
1614++ 32AE FE 5D       	CP	']'		;TEST FOR INDEX INTO CHARACTER VARIABLE
1615++ 32B0 CA 88 33    	JP	Z,CINDX		;GET INDEX VALUE
1616++ 32B3 CD 8F 2E    	CALL	LTA		;GET ADDRESS OF VARIABLE
1617++ 32B6 D5          	PUSH	DE		;SAVE SOURCE POSITION
1618++ 32B7 EB          	EX	DE,HL		;SWAP ADDRESS TO D-E
1619++ 32B8 1B          	DEC	DE		;BACK UP IN SOURCE
1620++ 32B9 C3 C9 32    	JP	Q0		;SAVE VARIABLE IN NEW BUFFER
1621++ 32BC             ;* BACKUP TO PRECEDING QUOTE
1622++ 32BC 1B          CQ:	DEC	DE		;BACKUP IN SOURCE
1623++ 32BD 1A          	LD	A,(DE)		;GET CHARACTER FROM SOURCE
1624++ 32BE FE 0D       	CP	$0D		;TEST FOR END OF LINE
1625++ 32C0 CA 29 2A    	JP	Z,SYNT		;IF SO, THERE IS NO CLOSEING QUOTE
1626++ 32C3 FE 22       	CP	$22		;TEST FOR CLOSEING QUOTE
1627++ 32C5 C2 BC 32    	JP	NZ,CQ		;IF NO, KEEP LOOKING
1628++ 32C8 D5          	PUSH	DE		;SAVE ENDING POSITION
1629++ 32C9 21 64 40    Q0:	LD	HL,XBF		;GET ADDRESS OF NEW (EXTRA) BUFFER
1630++ 32CC 13          Q1:	INC	DE		;ADVANCE TO SOURCE OR VARIABLE CHARACTER
1631++ 32CD 1A          	LD	A,(DE)		;GET CHARACTER
1632++ 32CE FE 22       	CP	$22		;TEST FOR CLOSEING QUOTE
1633++ 32D0 CA DD 32    	JP	Z,Q2		;IF SO, STOP COPYING
1634++ 32D3 FE FF       	CP	$FF		;TEST FOR END OF VARIABLE
1635++ 32D5 CA DD 32    	JP	Z,Q2		;IF SO, STOP COPYING
1636++ 32D8 77          	LD	(HL),A		;SAVE IN BUFFER
1637++ 32D9 23          	INC	HL		;ADVANCE IN BUFFER
1638++ 32DA C3 CC 32    	JP	Q1		;KEEP COPYING
1639++ 32DD D1          Q2:	POP	DE		;GET POSITION BACK
1640++ 32DE 1B          Q3:	DEC	DE		;BACK UP TO OPERATOR
1641++ 32DF F1          	POP	AF		;GET OPERATOR
1642++ 32E0 FE 2B       	CP	'+'		;TEST FOR CONCATIONATION
1643++ 32E2 C2 FA 32    	JP	NZ,Q5		;NO, TRY ASSIGNMENT
1644++ 32E5             ;* CONCATONATION. XBF=XBF+TB
1645++ 32E5 01 32 40    QPP:	LD	BC,TB		;ADDRESS OF TEMPORARY BUFFER
1646++ 32E8 0A          Q4:	LD	A,(BC)		;GET CHARACTER FROM BUFFER
1647++ 32E9 77          	LD	(HL),A		;MOVE TO BUFFER
1648++ 32EA 03          	INC	BC		;ADVANCE IN OLD
1649++ 32EB 23          	INC	HL		;ADVANCE IN NEW
1650++ 32EC 79          	LD	A,C		;GET ADDRESS IN OLD
1651++ 32ED FE 55       	CP	((TB+35) & $FF)	;TEST FOR OVER
1652++ 32EF DA E8 32    	JP	C,Q4		;IF SO, STOP
1653++ 32F2 2A 64 40    	LD	HL,(XBF)	;GET CHARACTER FROM BUFFER
1654++ 32F5 26 00       	LD	H,0		;SET HIGH BYTE TO ZERO
1655++ 32F7 C3 43 33    	JP	Q9		;CONTINUE
1656++ 32FA             ;* ASSIGNMENT
1657++ 32FA FE 3D       Q5:	CP	'='		;TEST FOR ASSIGNMENT
1658++ 32FC C2 13 33    	JP	NZ,Q6		;IF NOT, TRY .EQUALITY
1659++ 32FF 13          	INC	DE		;SKIP TO VARIABLE NAME
1660++ 3300 13          	INC	DE		;SKIP TO DOLLARSIGN
1661++ 3301 1A          	LD	A,(DE)		;GET DOLLARSIGN
1662++ 3302 1B          	DEC	DE		;BACK UP TO VARIABLE NAME
1663++ 3303 FE 24       	CP	'$'		;TEST FOR DOLLAR SIGN
1664++ 3305 C2 29 2A    	JP	NZ,SYNT		;IF NOT, THIS AIN'T NO CHARACTER VARIABLE
1665++ 3308 32 37 42    	LD	(EFLAG),A	;SET ASSIGNMENT FLAG
1666++ 330B 1A          	LD	A,(DE)		;GET VARIABLE NAME
1667++ 330C 1B          	DEC	DE		;BACK UP BAST NAME
1668++ 330D CD 8F 2E    	CALL	LTA		;GET IT'S ADDRESS
1669++ 3310 C3 E5 32    	JP	QPP		;COPY IT OVER
1670++ 3313             ;*;TEST FOR .EQUALITY
1671++ 3313 FE 81       Q6:	CP	$81		;TEST FOR '=='
1672++ 3315 C2 37 33    	JP	NZ,X0		;NO, TRY '=-'
1673++ 3318 CD 1E 33    	CALL	COMSTR		;COMPARE STRINGS
1674++ 331B C3 43 33    	JP	Q9		;CONTINUE
1675++ 331E             ;* COMPARES STRINGS. SETS H-L TO 1 OR 0 IF .EQUAL OR NOT .EQUAL
1676++ 331E 01 32 40    COMSTR:	LD	BC,TB		;GET ADDRESS OF OLD STRING
1677++ 3321 21 64 40    	LD	HL,XBF		;ADDRESS OF NEW STRING
1678++ 3324 0A          Q7:	LD	A,(BC)		;GET CHARACTER FROM OLD
1679++ 3325 BE          	CP	(HL)		;TEST AGAINST NEW
1680++ 3326 C2 33 33    	JP	NZ,Q8		;IF NOT, THEY ARE UN.EQUAL
1681++ 3329 03          	INC	BC		;NEXT PLACE IN OLD
1682++ 332A 23          	INC	HL		;NEXT PLACE IN NEW
1683++ 332B 3C          	INC	A		;TEST FOR END OF STRING
1684++ 332C C2 24 33    	JP	NZ,Q7		;IF NOT, CONTINUE;TESTING
1685++ 332F 21 01 00    	LD	HL,1		;INDICATE THEY ARE .EQUAL
1686++ 3332 C9          	RET
1687++ 3333 21 00 00    Q8:	LD	HL,0		;INDICATE NOT .EQUAL
1688++ 3336 C9          	RET
1689++ 3337             ;* NOT .EQUAL .. '-='
1690++ 3337 FE 82       X0:	CP	$82		;TEST FOR '-='
1691++ 3339 C2 29 2A    	JP	NZ,SYNT		;BEATS ME, BUT IT ISN'T RIGHT
1692++ 333C CD 1E 33    	CALL	COMSTR		;TEST STRINGS
1693++ 333F 7D          	LD	A,L		;GET RESULT
1694++ 3340 EE 01       	XOR	1		;AND COMPLEMENT IT
1695++ 3342 6F          	LD	L,A		;REPLACE IN RESULT
1696++ 3343             ;* GET NEXT STRING
1697++ 3343 CD 65 32    Q9:	CALL	FE		;GET NEXT CHARACTER
1698++ 3346 37          	SCF			;INDICATE CHARACTER EXPRESSION
1699++ 3347 C8          	RET	Z		;IF END OF LINE, QUIT
1700++ 3348 FE 28       	CP	'('		;TEST FOR END OF NUMERIC SUBSTRING
1701++ 334A C8          	RET	Z		;QUIT, INDICATING NUMBERIC RESULT
1702++ 334B FE 3D       	CP	'='		;TEST FOR .EQUAL,ASSIGNMENT, OR NOT .EQUALS
1703++ 334D C2 97 32    	JP	NZ,CG1		;NO, NO NEED TO;TEST FURTHER
1704++ 3350 1B          QTST:	DEC	DE		;BACK UP TO PREVIOUS CHARACTER
1705++ 3351 1A          	LD	A,(DE)		;GET CHARACTER
1706++ 3352 47          	LD	B,A		;SAVE FOR COMPARISON
1707++ 3353 FE 3D       	CP	'='		;TEST FOR '=='
1708++ 3355 3E 81       	LD	A,$81		;INDICATE '=='
1709++ 3357 CA 97 32    	JP	Z,CG1		;CONTINUE
1710++ 335A 78          	LD	A,B		;GET CHARACTER BACK
1711++ 335B FE 2D       	CP	'-'		;TEST FOR '-='
1712++ 335D 3E 82       	LD	A,$82		;INDICATE '-='
1713++ 335F CA 97 32    	JP	Z,CG1		;CONTINUE
1714++ 3362 13          	INC	DE		;ADVANCE BACK TO PREVIOUS CHARACTER
1715++ 3363 3E 3D       	LD	A,'='		;INDICATE '='
1716++ 3365 C3 97 32    	JP	CG1		;CONTINUE
1717++ 3368             ;* CLEARS THE TEXT BUFFER
1718++ 3368 21 64 40    CLBF:	LD	HL,XBF		;GET ADDRESS OF BUFFER
1719++ 336B 3E 28       	LD	A,40		;CLEAR FOR LENGTH OF 40
1720++ 336D 36 FF       CL2:	LD	(HL),$FF	;CLEAR TO NULL CHARACTER
1721++ 336F 23          	INC	HL		;NEXT POSITION IN BUFFER
1722++ 3370 3D          	DEC	A		;REDUCE COUNT OF REMAINING
1723++ 3371 C2 6D 33    	JP	NZ,CL2		;KEEP GOING TILL WE ARE FINISHED
1724++ 3374 C9          	RET
1725++ 3375             ;* COPY'S NEW BUFFER INTO OLD BUFFER
1726++ 3375 D5          PUSHB:	PUSH	DE		;SAVE POSITION IS SOURCE
1727++ 3376 11 64 40    	LD	DE,XBF		;GET ADDRESS OF NEW BUFFER
1728++ 3379 21 32 40    	LD	HL,TB		;GET ADDRESS OF OLD BUFFER
1729++ 337C 06 28       	LD	B,40		;COPY 40 CHARACTERS
1730++ 337E 1A          PU1:	LD	A,(DE)		;GET CHARACTER FROM NEW
1731++ 337F 77          	LD	(HL),A		;SAVE IN OLD
1732++ 3380 23          	INC	HL		;NEXT POSITION IN OLD
1733++ 3381 13          	INC	DE		;NEXT POSITION IN NEW
1734++ 3382 05          	DEC	B		;REDUCE COUNT
1735++ 3383 C2 7E 33    	JP	NZ,PU1		;KEEP GOING TILL 40 ARE MOVED
1736++ 3386 D1          	POP	DE		;RESTORE POSITION IN SOURCE
1737++ 3387 C9          	RET
1738++ 3388             ;* INDEXED CHARACTER VARIABLE, EXTRACT A SINGLE CHARACTER
1739++ 3388 CD 2C 30    CINDX:	CALL	DOEXP		;EVALUATE INDEX EXPRESSION
1740++ 338B 7D          	LD	A,L		;GET INDEX VALUE
1741++ 338C F5          	PUSH	AF		;SAVE INDEX VALUE
1742++ 338D 1B          	DEC	DE		;BACK UP TO VARIABLE NAME
1743++ 338E 1A          	LD	A,(DE)		;GET VARIABLE NAME
1744++ 338F FE 40       	CP	'@'		;TEST FOR 'MAGIC' CHR$ VARIABLE
1745++ 3391 CA A8 33    	JP	Z,CHR		;IF SO, HANDLE SPECIAL CASE
1746++ 3394 CD 8F 2E    	CALL	LTA		;GET TEXT VARIABLE ADDRESS
1747++ 3397 F1          	POP	AF		;GET INDEX BACK
1748++ 3398 FE 23       	CP	35		;TEST FOR TOO BIG
1749++ 339A D2 89 2E    	JP	NC,DIMERR	;IF SO, TELL HIM HE SCREWED UP
1750++ 339D 4F          	LD	C,A		;GET INTO A DOUBLE PAIR
1751++ 339E 09          	ADD	HL,BC		;SO WE CAN DAD IT TO THE ADDRESS
1752++ 339F 7E          	LD	A,(HL)		;AND GET THE CHARACTER
1753++ 33A0 21 64 40    FILBUF:	LD	HL,XBF		;ADDRESS OF TEXT BUFFER
1754++ 33A3 77          	LD	(HL),A		;PLACE CHARACTER THERE
1755++ 33A4 23          	INC	HL		;BUMP TO NEXT POSITION
1756++ 33A5 C3 DE 32    	JP	Q3		;AND FILL WITH NULLS
1757++ 33A8             ;*
1758++ 33A8             ;* 'MAGIC' CHARACTER ARRAY, RETURNS CHARACTER WITH VALUE OF IT'S INDEX
1759++ 33A8             ;*
1760++ 33A8 F1          CHR:	POP	AF		;GET INDEX VALUE
1761++ 33A9 C3 A0 33    	JP	FILBUF		;SAVE IN BUFFER AND PAD WITH NULLS
1762++ 33AC             	
1763++ 33AC             		
1764++ 33AC             	
1765++ 33AC             ;* END OF BASIC INTERPRETER CODE SECTION
1766++ 33AC             ;*
1767++ 33AC             ;**********************************************************************
1768++ 33AC             ;*                          COMMAND TABLE
1769++ 33AC             ;*
1770++ 33AC             ;*   FORMAT IS:
1771++ 33AC             ;*               COMMAND WORDS, HIGH BIT SET ON LAST CHARACTER
1772++ 33AC             ;*               ADDRESS OF COMMAND PROCESSOR FOLLOWES
1773++ 33AC             ;*               ENTRY OF HEX 00 INDICATES LAST ENTRY IN TABLE (DEFAULT)
1774++ 33AC             ;*
1775++ 33AC             ;**********************************************************************
1776++ 33AC             ;*
1777++ 33AC             ;* COMMANDS ALLOWED ONLY FROM WITHING A PROGRAM..
1778++ 33AC 4E 45 58    PTAB:	.TEXT	"NEX"
1779++ 33AF D4          	.DB	'T'+$80
1780++ 33B0 E9 2C       	.DW	NEXT
1781++ 33B2 54 48 45    	.TEXT	"THE"
1782++ 33B5 CE          	.DB	'N'+$80
1783++ 33B6 3A 2C       	.DW	THEN
1784++ 33B8 47 4F 53 55 	.TEXT	"GOSU"
1785++ 33BC C2          	.DB	'B'+$80
1786++ 33BD 43 2C       	.DW	GOSUB
1787++ 33BF 52 45 54 55 	.TEXT	"RETUR"
1787++ 33C3 52 
1788++ 33C4 CE          	.DB	'N'+$80
1789++ 33C5 76 2C       	.DW	RETURN
1790++ 33C7 46 4F       	.TEXT	"FO"
1791++ 33C9 D2          	.DB	'R'+$80
1792++ 33CA 83 2C       	.DW	FOR
1793++ 33CC 49          	.TEXT	"I"
1794++ 33CD C6          	.DB	'F'+$80
1795++ 33CE 1E 2D       	.DW	IF
1796++ 33D0 44 41 54    DATCMD:	.TEXT	"DAT"
1797++ 33D3 C1          	.DB	'A'+$80
1798++ 33D4 1B 2C       	.DW	RNEXT
1799++ 33D6 4C 49       	.TEXT	"LI"
1800++ 33D8 C6          	.DB	'F'+$80
1801++ 33D9 41 2D       	.DW	LIF
1802++ 33DB             ;* COMMANDS ALLOWED FROM BOTH A PROGRAM, AND INTERACTIVE KEYBOARD ENTRY
1803++ 33DB 47 4F 54    KTAB:	.TEXT	"GOT"
1804++ 33DE CF          	.DB	'O'+$80
1805++ 33DF 4B 2C       	.DW	GOTO
1806++ 33E1 4C 45       	.TEXT	"LE"
1807++ 33E3 D4          	.DB	'T'+$80
1808++ 33E4 DA 2C       	.DW	LET
1809++ 33E6 50 52 49 4E 	.TEXT	"PRIN"
1810++ 33EA D4          	.DB	'T'+$80
1811++ 33EB 67 2D       	.DW	PRINT
1812++ 33ED 55 53       	.TEXT	"US"
1813++ 33EF D2          	.DB	'R'+$80
1814++ 33F0 A2 2E       	.DW	USR
1815++ 33F2 52 45 41    	.TEXT	"REA"
1816++ 33F5 C4          	.DB	'D'+$80
1817++ 33F6 FB 2E       	.DW	READ
1818++ 33F8 50 4C 4F    	.TEXT	"PLO"
1819++ 33FB D4          	.DB	'T'+$80
1820++ 33FC 4C 2D       	.DW	PLOT
1821++ 33FE 52 45       	.TEXT	"RE"
1822++ 3400 CD          	.DB	'M'+$80
1823++ 3401 1D 2D       	.DW	REM
1824++ 3403 44 49       	.TEXT	"DI"
1825++ 3405 CD          	.DB	'M'+$80
1826++ 3406 18 2E       	.DW	DIM
1827++ 3408 52 55       	.TEXT	"RU"
1828++ 340A CE          	.DB	'N'+$80
1829++ 340B F4 2B       	.DW	RUN
1830++ 340D 4F 52 44 45 	.TEXT	"ORDE"
1831++ 3411 D2          	.DB	'R'+$80
1832++ 3412 E0 2E       	.DW	ORDER
1833++ 3414 49 4E 50 55 	.TEXT	"INPU"
1834++ 3418 D4          	.DB	'T'+$80
1835++ 3419 A5 2D       	.DW	INPUT
1836++ 341B 43 4C 45 41 	.TEXT	"CLEA"
1837++ 341F D2          	.DB	'R'+$80
1838++ 3420 BC 2B       	.DW	CLEAR
1839++ 3422 53 54 4F    	.TEXT	"STO"
1840++ 3425 D0          	.DB	'P'+$80
1841++ 3426 34 2C       	.DW	STOP
1842++ 3428 45 4E       	.TEXT	"EN"
1843++ 342A C4          	.DB	'D'+$80
1844++ 342B D4 29       	.DW	INIT
1845++ 342D 4C 49 53    	.TEXT	"LIS"
1846++ 3430 D4          	.DB	'T'+$80
1847++ 3431 78 2B       	.DW	LIST
1848++ 3433 4E 45       	.TEXT	"NE"
1849++ 3435 D7          	.DB	'W'+$80
1850++ 3436 CC 29       	.DW	NEW
1851++ 3438 53 49 5A    	.TEXT	"SIZ"
1852++ 343B C5          	.DB	'E'+$80
1853++ 343C 85 2F       	.DW	SIZE
1854++ 343E 4C 4F 41    	.TEXT	"LOA"
1855++ 3441 C4          	.DB	'D'+$80
1856++ 3442 A5 2F       	.DW	LOAD
1857++ 3444 53 41 56    	.TEXT	"SAV"
1858++ 3447 C5          	.DB	'E'+$80
1859++ 3448 B4 2F       	.DW	SAVE
1860++ 344A 4D 4F 4E 49 	.TEXT	"MONITO"
1860++ 344E 54 4F 
1861++ 3450 D2          	.DB	'R'+$80
1862++ 3451 71 27       	.DW	EXIT
1863++ 3453 00          	.DB	0		;UNRECOGNIZED COMMAND, ASSUME 'LET'
1864++ 3454 DA 2C       	.DW	LET
1865++ 3456             ;*
1866++ 3456             ;***************************************************************
1867++ 3456             ;*                    STRINGS AND MESSAGES
1868++ 3456             ;***************************************************************
1869++ 3456             ;*
1870++ 3456             ;* ERROR MESSAGES..
1871++ 3456             ;*
1872++ 3456 44 49 56 49 DER:	.TEXT	"DIVIDE BY ZERO" ;DIVIDE BY ZERO
1872++ 345A 44 45 20 42 
1872++ 345E 59 20 5A 45 
1872++ 3462 52 4F 
1873++ 3464 00          	.DB	0
1874++ 3465 42 41 44 20 IERMS:	.TEXT	"BAD DATA - RETRY" ;BAD RESPONSE TO INPUT STATEMENT
1874++ 3469 44 41 54 41 
1874++ 346D 20 2D 20 52 
1874++ 3471 45 54 52 59 
1875++ 3475 0D 0A 00    	.DB	$0D,$0A,0
1876++ 3478 4E 45 53 54 CSTK:	.TEXT	"NESTING"	;INVALID FOR/NEXT, GOSUB/RETURN NESTING
1876++ 347C 49 4E 47 
1877++ 347F 00          	.DB	0
1878++ 3480 4C 49 4E 45 LIN:	.TEXT	"LINE NUMBER"	;GOTO, GOSUB, OR ORDER TO UNKNOWN LINE
1878++ 3484 20 4E 55 4D 
1878++ 3488 42 45 52 
1879++ 348B 00          	.DB	0
1880++ 348C 4E 4F 20 50 NP:	.TEXT	"NO PROGRAM"	;RUN OR SAVE EMPTY PROGRAM
1880++ 3490 52 4F 47 52 
1880++ 3494 41 4D 
1881++ 3496 00          	.DB	0
1882++ 3497 20 49 4E 20 INL:	.TEXT	" IN LINE "	;INDICATES LINE ERROR WAS IN
1882++ 349B 4C 49 4E 45 
1882++ 349F 20 
1883++ 34A0 00          	.DB	0
1884++ 34A1 53 59 4E 54 SYN:	.TEXT	"SYNTAX"	;DOES NOT FOLLOW SYNTAX RULES
1884++ 34A5 41 58 
1885++ 34A7 00          	.DB	0
1886++ 34A8 44 41 54 41 DTXT:	.TEXT	"DATA"		;BAD LINE OR DATA TYPE
1887++ 34AC 00          	.DB	0
1888++ 34AD 44 49 4D 45 OVM:	.TEXT	"DIMENSION"	;TO MANY ARRAYS, ARGUMENT OUT OF RANGE
1888++ 34B1 4E 53 49 4F 
1888++ 34B5 4E 
1889++ 34B6 00          	.DB	0
1890++ 34B7             ;*
1891++ 34B7             ;* INFORMATIONAL MESSAGES..
1892++ 34B7             ;*
1893++ 34B7 52 45 41 44 RDY:	.TEXT	"READY."	;READY PROMPT
1893++ 34BB 59 2E 
1894++ 34BD 0D 0A 00    	.DB	$0D,$0A,0
1895++ 34C0 53 54 4F 50 STMSG:	.TEXT	"STOP"		;INDICATES PROGRAM STOPPED
1896++ 34C4 00          	.DB	0
1897++ 34C5 20 45 52 52 EM:	.TEXT	" ERROR"	;INDICATES ERROR OCCURED
1897++ 34C9 4F 52 
1898++ 34CB 00          	.DB	0
1899++ 34CC 20 42 59 54 SIMSG:	.TEXT	" BYTES"	;DISPLAYED IN RESPONSE TO 'SIZE'
1899++ 34D0 45 53 
1900++ 34D2 0D 0A 00    	.DB	$0D,$0A,0
1901++ 34D5             TXT_BASICID:	
1902++ 34D5 4D 49 43 52 	.TEXT	"MICRO-BASIC V0.1"	
1902++ 34D9 4F 2D 42 41 
1902++ 34DD 53 49 43 20 
1902++ 34E1 56 30 2E 31 
1903++ 34E5 0D 0A 00    	.DB	$0D,$0A,0
1904++ 34E8             ENDIT	.EQU	*
1905++ 34E8             
2454+  34E8                             
2455+  34E8                             .ds      $3FFF - $	
2456+  3FFF 00                          .db      $00
2457+  4000             		0046   4000             
0047   4000             ; vim:ts=8:expandtab:filetype=z8a:syntax=z8a:
0048   4000             
0049   4000             	.END
tasm: Number of errors = 0
